var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  findMissingOptions: () => findMissingOptions,
  partialParse: () => partialParse
});
module.exports = __toCommonJS(src_exports);

// src/noop.ts
var noop = () => {
};

// src/index.ts
var import_camelcase = __toESM(require("camelcase"), 1);
var import_commander = require("commander");
var findMissingOptions = (command, providedOptionsByCommand) => {
  const missingOptionsByCommand = /* @__PURE__ */ new Map();
  let currentCommand = command;
  while (currentCommand) {
    const missingOptions = /* @__PURE__ */ new Set();
    const providedOptions = providedOptionsByCommand.get(currentCommand);
    for (const option of currentCommand.options) {
      const key = option.negate ? (0, import_camelcase.default)(option.long.replace(/^--no-/, "")) : (0, import_camelcase.default)(option.long ?? option.short);
      if (providedOptions?.[key] !== void 0) {
        continue;
      }
      missingOptions.add(key);
    }
    missingOptionsByCommand.set(currentCommand, missingOptions);
    currentCommand = currentCommand.parent;
  }
  return missingOptionsByCommand;
};
var copyCommandSettings = (source, target) => {
  for (const keysToCopy of [
    "_allowExcessArguments",
    "_allowUnknownOption",
    "_combineFlagAndOptionalValue",
    "_defaultCommandName",
    "_enablePositionalOptions",
    "_passThroughOptions"
  ]) {
    target[keysToCopy] = source[keysToCopy];
  }
  target.name(source.name());
  target.aliases(source.aliases());
  for (const argument of source.registeredArguments) {
    target.addArgument(argument);
  }
  if (source.version()) {
    target.version(
      source.version(),
      source.options.find(
        (option) => option.attributeName() === source._versionOptionName
      )?.flags
    );
  }
};
var disableCommandOutput = (command) => {
  command.configureOutput({
    writeOut: noop,
    writeErr: noop,
    outputError: noop
  });
};
var cloneOption = (option) => {
  const newOption = new import_commander.Option(option.flags, option.description);
  newOption.makeOptionMandatory(false);
  newOption.default(option.defaultValue, option.defaultValueDescription);
  newOption.preset(option.presetArg);
  newOption.env(option.envVar);
  if (option.parseArg) {
    newOption.argParser(option.parseArg);
  }
  if (option.argChoices) {
    newOption.choices(option.argChoices);
  }
  newOption.conflicts(
    option.conflictsWith
  );
  newOption.implied = option.implied;
  return newOption;
};
var partialParse = (command, argv, options) => {
  const providedOptions = /* @__PURE__ */ new Map();
  const providedOptionsSources = /* @__PURE__ */ new Map();
  const commandsMap = /* @__PURE__ */ new Map();
  let matchedCommand;
  const setProvidedOptionSource = (command2, optionKey, source) => {
    if (!source) {
      return;
    }
    const sourcesMap = providedOptionsSources.get(command2) ?? /* @__PURE__ */ new Map();
    sourcesMap.set(optionKey, source);
    providedOptionsSources.set(command2, sourcesMap);
  };
  const createParserCommand = (parserCommand2, command2) => {
    commandsMap.set(parserCommand2, command2);
    copyCommandSettings(command2, parserCommand2);
    disableCommandOutput(parserCommand2);
    parserCommand2.exitOverride();
    for (const option of command2.options) {
      if (parserCommand2.options.some(
        (parserCommandOption) => parserCommandOption.flags === option.flags
      )) {
        continue;
      }
      parserCommand2.addOption(cloneOption(option));
    }
    parserCommand2.hook("preSubcommand", (thisCommand, actionCommand) => {
      for (const cmd of [thisCommand, actionCommand]) {
        providedOptions.set(commandsMap.get(cmd), cmd.opts());
        for (const optionKey of Object.keys(cmd.opts())) {
          setProvidedOptionSource(
            cmd,
            optionKey,
            cmd.getOptionValueSource(optionKey)
          );
        }
      }
    });
    parserCommand2.action(() => {
      providedOptions.set(
        commandsMap.get(parserCommand2),
        parserCommand2.opts()
      );
      for (const optionKey of Object.keys(parserCommand2.opts())) {
        setProvidedOptionSource(
          commandsMap.get(parserCommand2),
          optionKey,
          parserCommand2.getOptionValueSource(optionKey)
        );
      }
      matchedCommand = command2;
    });
    for (const subcommand of command2.commands) {
      const parserSubcommand = parserCommand2.command(subcommand.name());
      createParserCommand(parserSubcommand, subcommand);
    }
    return parserCommand2;
  };
  const parserCommand = createParserCommand(new import_commander.Command(), command);
  parserCommand.parse(argv, options);
  const missingOptions = matchedCommand ? findMissingOptions(matchedCommand, providedOptions) : /* @__PURE__ */ new Map();
  return {
    matchedCommand,
    missingOptions,
    providedOptions,
    providedOptionsSources
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  findMissingOptions,
  partialParse
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9ub29wLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBub29wIH0gZnJvbSBcIi4vbm9vcC50c1wiO1xuaW1wb3J0IGNhbWVsQ2FzZSBmcm9tIFwiY2FtZWxjYXNlXCI7XG5pbXBvcnQge1xuICB0eXBlIE9wdGlvblZhbHVlcyxcbiAgQ29tbWFuZCxcbiAgdHlwZSBQYXJzZU9wdGlvbnMsXG4gIE9wdGlvbixcbiAgdHlwZSBPcHRpb25WYWx1ZVNvdXJjZSxcbn0gZnJvbSBcImNvbW1hbmRlclwiO1xuXG5leHBvcnQgY29uc3QgZmluZE1pc3NpbmdPcHRpb25zID0gKFxuICBjb21tYW5kOiBDb21tYW5kLFxuICBwcm92aWRlZE9wdGlvbnNCeUNvbW1hbmQ6IE1hcDxDb21tYW5kLCBPcHRpb25WYWx1ZXM+LFxuKSA9PiB7XG4gIGNvbnN0IG1pc3NpbmdPcHRpb25zQnlDb21tYW5kID0gbmV3IE1hcDxDb21tYW5kLCBTZXQ8c3RyaW5nPj4oKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICBsZXQgY3VycmVudENvbW1hbmQ6IENvbW1hbmQgfCB1bmRlZmluZWQgfCBudWxsID0gY29tbWFuZDtcblxuICB3aGlsZSAoY3VycmVudENvbW1hbmQpIHtcbiAgICBjb25zdCBtaXNzaW5nT3B0aW9ucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHByb3ZpZGVkT3B0aW9ucyA9IHByb3ZpZGVkT3B0aW9uc0J5Q29tbWFuZC5nZXQoY3VycmVudENvbW1hbmQpO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGN1cnJlbnRDb21tYW5kLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IG9wdGlvbi5uZWdhdGVcbiAgICAgICAgPyBjYW1lbENhc2Uob3B0aW9uLmxvbmchLnJlcGxhY2UoL14tLW5vLS8sIFwiXCIpKVxuICAgICAgICA6IGNhbWVsQ2FzZSgob3B0aW9uLmxvbmcgPz8gb3B0aW9uLnNob3J0KSEpO1xuXG4gICAgICBpZiAocHJvdmlkZWRPcHRpb25zPy5ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBtaXNzaW5nT3B0aW9ucy5hZGQoa2V5KTtcbiAgICB9XG5cbiAgICBtaXNzaW5nT3B0aW9uc0J5Q29tbWFuZC5zZXQoY3VycmVudENvbW1hbmQsIG1pc3NpbmdPcHRpb25zKTtcbiAgICBjdXJyZW50Q29tbWFuZCA9IGN1cnJlbnRDb21tYW5kLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBtaXNzaW5nT3B0aW9uc0J5Q29tbWFuZDtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnRpYWxQYXJzZVJlc3VsdCA9IHtcbiAgLyoqXG4gICAqIFRoZSBjb21tYW5kIHdob3NlIGFjdGlvbiB3aWxsIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBtYXRjaGVkQ29tbWFuZDogQ29tbWFuZCB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEEgbWFwIG9mIGNvbW1hbmRzIHRvIGEgc2V0IG9mIG1pc3Npbmcgb3B0aW9ucyBmb3IgdGhhdCBjb21tYW5kXG4gICAqL1xuICBtaXNzaW5nT3B0aW9uczogTWFwPENvbW1hbmQsIFNldDxzdHJpbmc+PjtcbiAgLyoqXG4gICAqIEEgbWFwIG9mIGNvbW1hbmRzIHRvIHRoZSBvcHRpb25zIHByb3ZpZGVkIGZvciB0aGF0IGNvbW1hbmRcbiAgICovXG4gIHByb3ZpZGVkT3B0aW9uczogTWFwPENvbW1hbmQsIE9wdGlvblZhbHVlcz47XG4gIC8qKlxuICAgKiBBIG1hcCBvZiBjb21tYW5kcyB0byBhIG1hcCBvZiBvcHRpb24ga2V5cyB0byB0aGUgc291cmNlIG9mIHRoZSBvcHRpb24gdmFsdWVcbiAgICovXG4gIHByb3ZpZGVkT3B0aW9uc1NvdXJjZXM6IE1hcDxcbiAgICBDb21tYW5kLFxuICAgIE1hcDxzdHJpbmcsIE9wdGlvblZhbHVlU291cmNlIHwgdW5kZWZpbmVkPlxuICA+O1xufTtcblxuY29uc3QgY29weUNvbW1hbmRTZXR0aW5ncyA9IChzb3VyY2U6IENvbW1hbmQsIHRhcmdldDogQ29tbWFuZCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleXNUb0NvcHkgb2YgW1xuICAgIFwiX2FsbG93RXhjZXNzQXJndW1lbnRzXCIsXG4gICAgXCJfYWxsb3dVbmtub3duT3B0aW9uXCIsXG4gICAgXCJfY29tYmluZUZsYWdBbmRPcHRpb25hbFZhbHVlXCIsXG4gICAgXCJfZGVmYXVsdENvbW1hbmROYW1lXCIsXG4gICAgXCJfZW5hYmxlUG9zaXRpb25hbE9wdGlvbnNcIixcbiAgICBcIl9wYXNzVGhyb3VnaE9wdGlvbnNcIixcbiAgXSBhcyBjb25zdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAodGFyZ2V0IGFzIGFueSlba2V5c1RvQ29weV0gPSAoc291cmNlIGFzIGFueSlba2V5c1RvQ29weV07XG4gIH1cblxuICB0YXJnZXQubmFtZShzb3VyY2UubmFtZSgpKTtcbiAgdGFyZ2V0LmFsaWFzZXMoc291cmNlLmFsaWFzZXMoKSk7XG4gIGZvciAoY29uc3QgYXJndW1lbnQgb2Ygc291cmNlLnJlZ2lzdGVyZWRBcmd1bWVudHMpIHtcbiAgICB0YXJnZXQuYWRkQXJndW1lbnQoYXJndW1lbnQpO1xuICB9XG5cbiAgaWYgKHNvdXJjZS52ZXJzaW9uKCkpIHtcbiAgICB0YXJnZXQudmVyc2lvbihcbiAgICAgIHNvdXJjZS52ZXJzaW9uKCkhLFxuICAgICAgc291cmNlLm9wdGlvbnMuZmluZChcbiAgICAgICAgKG9wdGlvbikgPT5cbiAgICAgICAgICBvcHRpb24uYXR0cmlidXRlTmFtZSgpID09PVxuICAgICAgICAgIChzb3VyY2UgYXMgQ29tbWFuZCAmIHsgX3ZlcnNpb25PcHRpb25OYW1lOiBzdHJpbmcgfSlcbiAgICAgICAgICAgIC5fdmVyc2lvbk9wdGlvbk5hbWUsXG4gICAgICApPy5mbGFncyxcbiAgICApO1xuICB9XG59O1xuXG5jb25zdCBkaXNhYmxlQ29tbWFuZE91dHB1dCA9IChjb21tYW5kOiBDb21tYW5kKSA9PiB7XG4gIGNvbW1hbmQuY29uZmlndXJlT3V0cHV0KHtcbiAgICB3cml0ZU91dDogbm9vcCxcbiAgICB3cml0ZUVycjogbm9vcCxcbiAgICBvdXRwdXRFcnJvcjogbm9vcCxcbiAgfSk7XG59O1xuXG5jb25zdCBjbG9uZU9wdGlvbiA9IChvcHRpb246IE9wdGlvbikgPT4ge1xuICBjb25zdCBuZXdPcHRpb24gPSBuZXcgT3B0aW9uKG9wdGlvbi5mbGFncywgb3B0aW9uLmRlc2NyaXB0aW9uKTtcbiAgbmV3T3B0aW9uLm1ha2VPcHRpb25NYW5kYXRvcnkoZmFsc2UpO1xuICBuZXdPcHRpb24uZGVmYXVsdChvcHRpb24uZGVmYXVsdFZhbHVlLCBvcHRpb24uZGVmYXVsdFZhbHVlRGVzY3JpcHRpb24pO1xuXG4gIG5ld09wdGlvbi5wcmVzZXQoKG9wdGlvbiBhcyBPcHRpb24gJiB7IHByZXNldEFyZzogdW5rbm93biB9KS5wcmVzZXRBcmcpO1xuICBuZXdPcHRpb24uZW52KChvcHRpb24gYXMgT3B0aW9uICYgeyBlbnZWYXI6IHN0cmluZyB9KS5lbnZWYXIpO1xuICBpZiAob3B0aW9uLnBhcnNlQXJnKSB7XG4gICAgbmV3T3B0aW9uLmFyZ1BhcnNlcihvcHRpb24ucGFyc2VBcmcpO1xuICB9XG5cbiAgaWYgKG9wdGlvbi5hcmdDaG9pY2VzKSB7XG4gICAgbmV3T3B0aW9uLmNob2ljZXMob3B0aW9uLmFyZ0Nob2ljZXMpO1xuICB9XG5cbiAgbmV3T3B0aW9uLmNvbmZsaWN0cyhcbiAgICAob3B0aW9uIGFzIE9wdGlvbiAmIHsgY29uZmxpY3RzV2l0aDogc3RyaW5nW10gfSkuY29uZmxpY3RzV2l0aCxcbiAgKTtcblxuICAobmV3T3B0aW9uIGFzIE9wdGlvbiAmIHsgaW1wbGllZDogdW5rbm93biB9KS5pbXBsaWVkID0gKFxuICAgIG9wdGlvbiBhcyBPcHRpb24gJiB7IGltcGxpZWQ6IHVua25vd24gfVxuICApLmltcGxpZWQ7XG5cbiAgcmV0dXJuIG5ld09wdGlvbjtcbn07XG5cbi8qKlxuICogUGFydGlhbGx5IHBhcnNlIGFyZ3YgZm9yIGEgY29tbWFuZCB3aXRob3V0IGV4ZWN1dGluZyB0aGUgYWN0aW9uLiBAc2VlIHtAbGluayBDb21tYW5kLnBhcnNlfVxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXRjaGVkIGNvbW1hbmQsIHRoZSBwcm92aWRlZCBvcHRpb25zLCBhbmQgdGhlIG1pc3Npbmcgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnRpYWxQYXJzZSA9IChcbiAgY29tbWFuZDogQ29tbWFuZCxcbiAgYXJndjogcmVhZG9ubHkgc3RyaW5nW10sXG4gIG9wdGlvbnM/OiBQYXJzZU9wdGlvbnMsXG4pOiBQYXJ0aWFsUGFyc2VSZXN1bHQgPT4ge1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSBuZXcgTWFwPENvbW1hbmQsIE9wdGlvblZhbHVlcz4oKTtcbiAgY29uc3QgcHJvdmlkZWRPcHRpb25zU291cmNlcyA9IG5ldyBNYXA8XG4gICAgQ29tbWFuZCxcbiAgICBNYXA8c3RyaW5nLCBPcHRpb25WYWx1ZVNvdXJjZSB8IHVuZGVmaW5lZD5cbiAgPigpO1xuICBjb25zdCBjb21tYW5kc01hcCA9IG5ldyBNYXA8Q29tbWFuZCwgQ29tbWFuZD4oKTtcbiAgbGV0IG1hdGNoZWRDb21tYW5kOiBDb21tYW5kIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHNldFByb3ZpZGVkT3B0aW9uU291cmNlID0gKFxuICAgIGNvbW1hbmQ6IENvbW1hbmQsXG4gICAgb3B0aW9uS2V5OiBzdHJpbmcsXG4gICAgc291cmNlOiBPcHRpb25WYWx1ZVNvdXJjZSB8IHVuZGVmaW5lZCxcbiAgKSA9PiB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VzTWFwID1cbiAgICAgIHByb3ZpZGVkT3B0aW9uc1NvdXJjZXMuZ2V0KGNvbW1hbmQpID8/XG4gICAgICBuZXcgTWFwPHN0cmluZywgT3B0aW9uVmFsdWVTb3VyY2U+KCk7XG4gICAgc291cmNlc01hcC5zZXQob3B0aW9uS2V5LCBzb3VyY2UpO1xuICAgIHByb3ZpZGVkT3B0aW9uc1NvdXJjZXMuc2V0KGNvbW1hbmQsIHNvdXJjZXNNYXApO1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZVBhcnNlckNvbW1hbmQgPSAocGFyc2VyQ29tbWFuZDogQ29tbWFuZCwgY29tbWFuZDogQ29tbWFuZCkgPT4ge1xuICAgIGNvbW1hbmRzTWFwLnNldChwYXJzZXJDb21tYW5kLCBjb21tYW5kKTtcblxuICAgIGNvcHlDb21tYW5kU2V0dGluZ3MoY29tbWFuZCwgcGFyc2VyQ29tbWFuZCk7XG4gICAgZGlzYWJsZUNvbW1hbmRPdXRwdXQocGFyc2VyQ29tbWFuZCk7XG4gICAgcGFyc2VyQ29tbWFuZC5leGl0T3ZlcnJpZGUoKTtcblxuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGNvbW1hbmQub3B0aW9ucykge1xuICAgICAgLy8gU2tpcCBhZGRpbmcgdGhlIG9wdGlvbiBpZiBpdCdzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgaWYgKFxuICAgICAgICBwYXJzZXJDb21tYW5kLm9wdGlvbnMuc29tZShcbiAgICAgICAgICAocGFyc2VyQ29tbWFuZE9wdGlvbikgPT4gcGFyc2VyQ29tbWFuZE9wdGlvbi5mbGFncyA9PT0gb3B0aW9uLmZsYWdzLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlckNvbW1hbmQuYWRkT3B0aW9uKGNsb25lT3B0aW9uKG9wdGlvbikpO1xuICAgIH1cblxuICAgIHBhcnNlckNvbW1hbmQuaG9vayhcInByZVN1YmNvbW1hbmRcIiwgKHRoaXNDb21tYW5kLCBhY3Rpb25Db21tYW5kKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNtZCBvZiBbdGhpc0NvbW1hbmQsIGFjdGlvbkNvbW1hbmRdKSB7XG4gICAgICAgIHByb3ZpZGVkT3B0aW9ucy5zZXQoY29tbWFuZHNNYXAuZ2V0KGNtZCkhLCBjbWQub3B0cygpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbktleSBvZiBPYmplY3Qua2V5cyhjbWQub3B0cygpKSkge1xuICAgICAgICAgIHNldFByb3ZpZGVkT3B0aW9uU291cmNlKFxuICAgICAgICAgICAgY21kLFxuICAgICAgICAgICAgb3B0aW9uS2V5LFxuICAgICAgICAgICAgY21kLmdldE9wdGlvblZhbHVlU291cmNlKG9wdGlvbktleSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGFyc2VyQ29tbWFuZC5hY3Rpb24oKCkgPT4ge1xuICAgICAgcHJvdmlkZWRPcHRpb25zLnNldChcbiAgICAgICAgY29tbWFuZHNNYXAuZ2V0KHBhcnNlckNvbW1hbmQpISxcbiAgICAgICAgcGFyc2VyQ29tbWFuZC5vcHRzKCksXG4gICAgICApO1xuXG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbktleSBvZiBPYmplY3Qua2V5cyhwYXJzZXJDb21tYW5kLm9wdHMoKSkpIHtcbiAgICAgICAgc2V0UHJvdmlkZWRPcHRpb25Tb3VyY2UoXG4gICAgICAgICAgY29tbWFuZHNNYXAuZ2V0KHBhcnNlckNvbW1hbmQpISxcbiAgICAgICAgICBvcHRpb25LZXksXG4gICAgICAgICAgcGFyc2VyQ29tbWFuZC5nZXRPcHRpb25WYWx1ZVNvdXJjZShvcHRpb25LZXkpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtYXRjaGVkQ29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YmNvbW1hbmQgb2YgY29tbWFuZC5jb21tYW5kcyBhcyBDb21tYW5kW10pIHtcbiAgICAgIGNvbnN0IHBhcnNlclN1YmNvbW1hbmQgPSBwYXJzZXJDb21tYW5kLmNvbW1hbmQoc3ViY29tbWFuZC5uYW1lKCkpO1xuICAgICAgY3JlYXRlUGFyc2VyQ29tbWFuZChwYXJzZXJTdWJjb21tYW5kLCBzdWJjb21tYW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VyQ29tbWFuZDtcbiAgfTtcblxuICBjb25zdCBwYXJzZXJDb21tYW5kID0gY3JlYXRlUGFyc2VyQ29tbWFuZChuZXcgQ29tbWFuZCgpLCBjb21tYW5kKTtcbiAgcGFyc2VyQ29tbWFuZC5wYXJzZShhcmd2LCBvcHRpb25zKTtcblxuICBjb25zdCBtaXNzaW5nT3B0aW9ucyA9IG1hdGNoZWRDb21tYW5kXG4gICAgPyBmaW5kTWlzc2luZ09wdGlvbnMobWF0Y2hlZENvbW1hbmQsIHByb3ZpZGVkT3B0aW9ucylcbiAgICA6IG5ldyBNYXA8Q29tbWFuZCwgU2V0PHN0cmluZz4+KCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVkQ29tbWFuZCxcbiAgICBtaXNzaW5nT3B0aW9ucyxcbiAgICBwcm92aWRlZE9wdGlvbnMsXG4gICAgcHJvdmlkZWRPcHRpb25zU291cmNlcyxcbiAgfTtcbn07XG4iLCAiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuZXhwb3J0IGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNDTyxJQUFNLE9BQU8sTUFBTTtBQUFDOzs7QURBM0IsdUJBQXNCO0FBQ3RCLHVCQU1PO0FBRUEsSUFBTSxxQkFBcUIsQ0FDaEMsU0FDQSw2QkFDRztBQUNILFFBQU0sMEJBQTBCLG9CQUFJLElBQTBCO0FBRzlELE1BQUksaUJBQTZDO0FBRWpELFNBQU8sZ0JBQWdCO0FBQ3JCLFVBQU0saUJBQWlCLG9CQUFJLElBQVk7QUFDdkMsVUFBTSxrQkFBa0IseUJBQXlCLElBQUksY0FBYztBQUNuRSxlQUFX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