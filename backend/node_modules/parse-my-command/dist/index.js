// src/noop.ts
var noop = () => {
};

// src/index.ts
import camelCase from "camelcase";
import {
  Command,
  Option
} from "commander";
var findMissingOptions = (command, providedOptionsByCommand) => {
  const missingOptionsByCommand = /* @__PURE__ */ new Map();
  let currentCommand = command;
  while (currentCommand) {
    const missingOptions = /* @__PURE__ */ new Set();
    const providedOptions = providedOptionsByCommand.get(currentCommand);
    for (const option of currentCommand.options) {
      const key = option.negate ? camelCase(option.long.replace(/^--no-/, "")) : camelCase(option.long ?? option.short);
      if (providedOptions?.[key] !== void 0) {
        continue;
      }
      missingOptions.add(key);
    }
    missingOptionsByCommand.set(currentCommand, missingOptions);
    currentCommand = currentCommand.parent;
  }
  return missingOptionsByCommand;
};
var copyCommandSettings = (source, target) => {
  for (const keysToCopy of [
    "_allowExcessArguments",
    "_allowUnknownOption",
    "_combineFlagAndOptionalValue",
    "_defaultCommandName",
    "_enablePositionalOptions",
    "_passThroughOptions"
  ]) {
    target[keysToCopy] = source[keysToCopy];
  }
  target.name(source.name());
  target.aliases(source.aliases());
  for (const argument of source.registeredArguments) {
    target.addArgument(argument);
  }
  if (source.version()) {
    target.version(
      source.version(),
      source.options.find(
        (option) => option.attributeName() === source._versionOptionName
      )?.flags
    );
  }
};
var disableCommandOutput = (command) => {
  command.configureOutput({
    writeOut: noop,
    writeErr: noop,
    outputError: noop
  });
};
var cloneOption = (option) => {
  const newOption = new Option(option.flags, option.description);
  newOption.makeOptionMandatory(false);
  newOption.default(option.defaultValue, option.defaultValueDescription);
  newOption.preset(option.presetArg);
  newOption.env(option.envVar);
  if (option.parseArg) {
    newOption.argParser(option.parseArg);
  }
  if (option.argChoices) {
    newOption.choices(option.argChoices);
  }
  newOption.conflicts(
    option.conflictsWith
  );
  newOption.implied = option.implied;
  return newOption;
};
var partialParse = (command, argv, options) => {
  const providedOptions = /* @__PURE__ */ new Map();
  const providedOptionsSources = /* @__PURE__ */ new Map();
  const commandsMap = /* @__PURE__ */ new Map();
  let matchedCommand;
  const setProvidedOptionSource = (command2, optionKey, source) => {
    if (!source) {
      return;
    }
    const sourcesMap = providedOptionsSources.get(command2) ?? /* @__PURE__ */ new Map();
    sourcesMap.set(optionKey, source);
    providedOptionsSources.set(command2, sourcesMap);
  };
  const createParserCommand = (parserCommand2, command2) => {
    commandsMap.set(parserCommand2, command2);
    copyCommandSettings(command2, parserCommand2);
    disableCommandOutput(parserCommand2);
    parserCommand2.exitOverride();
    for (const option of command2.options) {
      if (parserCommand2.options.some(
        (parserCommandOption) => parserCommandOption.flags === option.flags
      )) {
        continue;
      }
      parserCommand2.addOption(cloneOption(option));
    }
    parserCommand2.hook("preSubcommand", (thisCommand, actionCommand) => {
      for (const cmd of [thisCommand, actionCommand]) {
        providedOptions.set(commandsMap.get(cmd), cmd.opts());
        for (const optionKey of Object.keys(cmd.opts())) {
          setProvidedOptionSource(
            cmd,
            optionKey,
            cmd.getOptionValueSource(optionKey)
          );
        }
      }
    });
    parserCommand2.action(() => {
      providedOptions.set(
        commandsMap.get(parserCommand2),
        parserCommand2.opts()
      );
      for (const optionKey of Object.keys(parserCommand2.opts())) {
        setProvidedOptionSource(
          commandsMap.get(parserCommand2),
          optionKey,
          parserCommand2.getOptionValueSource(optionKey)
        );
      }
      matchedCommand = command2;
    });
    for (const subcommand of command2.commands) {
      const parserSubcommand = parserCommand2.command(subcommand.name());
      createParserCommand(parserSubcommand, subcommand);
    }
    return parserCommand2;
  };
  const parserCommand = createParserCommand(new Command(), command);
  parserCommand.parse(argv, options);
  const missingOptions = matchedCommand ? findMissingOptions(matchedCommand, providedOptions) : /* @__PURE__ */ new Map();
  return {
    matchedCommand,
    missingOptions,
    providedOptions,
    providedOptionsSources
  };
};
export {
  findMissingOptions,
  partialParse
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL25vb3AudHMiLCAiLi4vc3JjL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuIiwgImltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi9ub29wLnRzXCI7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gXCJjYW1lbGNhc2VcIjtcbmltcG9ydCB7XG4gIHR5cGUgT3B0aW9uVmFsdWVzLFxuICBDb21tYW5kLFxuICB0eXBlIFBhcnNlT3B0aW9ucyxcbiAgT3B0aW9uLFxuICB0eXBlIE9wdGlvblZhbHVlU291cmNlLFxufSBmcm9tIFwiY29tbWFuZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBmaW5kTWlzc2luZ09wdGlvbnMgPSAoXG4gIGNvbW1hbmQ6IENvbW1hbmQsXG4gIHByb3ZpZGVkT3B0aW9uc0J5Q29tbWFuZDogTWFwPENvbW1hbmQsIE9wdGlvblZhbHVlcz4sXG4pID0+IHtcbiAgY29uc3QgbWlzc2luZ09wdGlvbnNCeUNvbW1hbmQgPSBuZXcgTWFwPENvbW1hbmQsIFNldDxzdHJpbmc+PigpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIGxldCBjdXJyZW50Q29tbWFuZDogQ29tbWFuZCB8IHVuZGVmaW5lZCB8IG51bGwgPSBjb21tYW5kO1xuXG4gIHdoaWxlIChjdXJyZW50Q29tbWFuZCkge1xuICAgIGNvbnN0IG1pc3NpbmdPcHRpb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgcHJvdmlkZWRPcHRpb25zID0gcHJvdmlkZWRPcHRpb25zQnlDb21tYW5kLmdldChjdXJyZW50Q29tbWFuZCk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgY3VycmVudENvbW1hbmQub3B0aW9ucykge1xuICAgICAgY29uc3Qga2V5ID0gb3B0aW9uLm5lZ2F0ZVxuICAgICAgICA/IGNhbWVsQ2FzZShvcHRpb24ubG9uZyEucmVwbGFjZSgvXi0tbm8tLywgXCJcIikpXG4gICAgICAgIDogY2FtZWxDYXNlKChvcHRpb24ubG9uZyA/PyBvcHRpb24uc2hvcnQpISk7XG5cbiAgICAgIGlmIChwcm92aWRlZE9wdGlvbnM/LltrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG1pc3NpbmdPcHRpb25zLmFkZChrZXkpO1xuICAgIH1cblxuICAgIG1pc3NpbmdPcHRpb25zQnlDb21tYW5kLnNldChjdXJyZW50Q29tbWFuZCwgbWlzc2luZ09wdGlvbnMpO1xuICAgIGN1cnJlbnRDb21tYW5kID0gY3VycmVudENvbW1hbmQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG1pc3NpbmdPcHRpb25zQnlDb21tYW5kO1xufTtcblxuZXhwb3J0IHR5cGUgUGFydGlhbFBhcnNlUmVzdWx0ID0ge1xuICAvKipcbiAgICogVGhlIGNvbW1hbmQgd2hvc2UgYWN0aW9uIHdpbGwgYmUgZXhlY3V0ZWRcbiAgICovXG4gIG1hdGNoZWRDb21tYW5kOiBDb21tYW5kIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQSBtYXAgb2YgY29tbWFuZHMgdG8gYSBzZXQgb2YgbWlzc2luZyBvcHRpb25zIGZvciB0aGF0IGNvbW1hbmRcbiAgICovXG4gIG1pc3NpbmdPcHRpb25zOiBNYXA8Q29tbWFuZCwgU2V0PHN0cmluZz4+O1xuICAvKipcbiAgICogQSBtYXAgb2YgY29tbWFuZHMgdG8gdGhlIG9wdGlvbnMgcHJvdmlkZWQgZm9yIHRoYXQgY29tbWFuZFxuICAgKi9cbiAgcHJvdmlkZWRPcHRpb25zOiBNYXA8Q29tbWFuZCwgT3B0aW9uVmFsdWVzPjtcbiAgLyoqXG4gICAqIEEgbWFwIG9mIGNvbW1hbmRzIHRvIGEgbWFwIG9mIG9wdGlvbiBrZXlzIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIG9wdGlvbiB2YWx1ZVxuICAgKi9cbiAgcHJvdmlkZWRPcHRpb25zU291cmNlczogTWFwPFxuICAgIENvbW1hbmQsXG4gICAgTWFwPHN0cmluZywgT3B0aW9uVmFsdWVTb3VyY2UgfCB1bmRlZmluZWQ+XG4gID47XG59O1xuXG5jb25zdCBjb3B5Q29tbWFuZFNldHRpbmdzID0gKHNvdXJjZTogQ29tbWFuZCwgdGFyZ2V0OiBDb21tYW5kKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5c1RvQ29weSBvZiBbXG4gICAgXCJfYWxsb3dFeGNlc3NBcmd1bWVudHNcIixcbiAgICBcIl9hbGxvd1Vua25vd25PcHRpb25cIixcbiAgICBcIl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWVcIixcbiAgICBcIl9kZWZhdWx0Q29tbWFuZE5hbWVcIixcbiAgICBcIl9lbmFibGVQb3NpdGlvbmFsT3B0aW9uc1wiLFxuICAgIFwiX3Bhc3NUaHJvdWdoT3B0aW9uc1wiLFxuICBdIGFzIGNvbnN0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICh0YXJnZXQgYXMgYW55KVtrZXlzVG9Db3B5XSA9IChzb3VyY2UgYXMgYW55KVtrZXlzVG9Db3B5XTtcbiAgfVxuXG4gIHRhcmdldC5uYW1lKHNvdXJjZS5uYW1lKCkpO1xuICB0YXJnZXQuYWxpYXNlcyhzb3VyY2UuYWxpYXNlcygpKTtcbiAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBzb3VyY2UucmVnaXN0ZXJlZEFyZ3VtZW50cykge1xuICAgIHRhcmdldC5hZGRBcmd1bWVudChhcmd1bWVudCk7XG4gIH1cblxuICBpZiAoc291cmNlLnZlcnNpb24oKSkge1xuICAgIHRhcmdldC52ZXJzaW9uKFxuICAgICAgc291cmNlLnZlcnNpb24oKSEsXG4gICAgICBzb3VyY2Uub3B0aW9ucy5maW5kKFxuICAgICAgICAob3B0aW9uKSA9PlxuICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCkgPT09XG4gICAgICAgICAgKHNvdXJjZSBhcyBDb21tYW5kICYgeyBfdmVyc2lvbk9wdGlvbk5hbWU6IHN0cmluZyB9KVxuICAgICAgICAgICAgLl92ZXJzaW9uT3B0aW9uTmFtZSxcbiAgICAgICk/LmZsYWdzLFxuICAgICk7XG4gIH1cbn07XG5cbmNvbnN0IGRpc2FibGVDb21tYW5kT3V0cHV0ID0gKGNvbW1hbmQ6IENvbW1hbmQpID0+IHtcbiAgY29tbWFuZC5jb25maWd1cmVPdXRwdXQoe1xuICAgIHdyaXRlT3V0OiBub29wLFxuICAgIHdyaXRlRXJyOiBub29wLFxuICAgIG91dHB1dEVycm9yOiBub29wLFxuICB9KTtcbn07XG5cbmNvbnN0IGNsb25lT3B0aW9uID0gKG9wdGlvbjogT3B0aW9uKSA9PiB7XG4gIGNvbnN0IG5ld09wdGlvbiA9IG5ldyBPcHRpb24ob3B0aW9uLmZsYWdzLCBvcHRpb24uZGVzY3JpcHRpb24pO1xuICBuZXdPcHRpb24ubWFrZU9wdGlvbk1hbmRhdG9yeShmYWxzZSk7XG4gIG5ld09wdGlvbi5kZWZhdWx0KG9wdGlvbi5kZWZhdWx0VmFsdWUsIG9wdGlvbi5kZWZhdWx0VmFsdWVEZXNjcmlwdGlvbik7XG5cbiAgbmV3T3B0aW9uLnByZXNldCgob3B0aW9uIGFzIE9wdGlvbiAmIHsgcHJlc2V0QXJnOiB1bmtub3duIH0pLnByZXNldEFyZyk7XG4gIG5ld09wdGlvbi5lbnYoKG9wdGlvbiBhcyBPcHRpb24gJiB7IGVudlZhcjogc3RyaW5nIH0pLmVudlZhcik7XG4gIGlmIChvcHRpb24ucGFyc2VBcmcpIHtcbiAgICBuZXdPcHRpb24uYXJnUGFyc2VyKG9wdGlvbi5wYXJzZUFyZyk7XG4gIH1cblxuICBpZiAob3B0aW9uLmFyZ0Nob2ljZXMpIHtcbiAgICBuZXdPcHRpb24uY2hvaWNlcyhvcHRpb24uYXJnQ2hvaWNlcyk7XG4gIH1cblxuICBuZXdPcHRpb24uY29uZmxpY3RzKFxuICAgIChvcHRpb24gYXMgT3B0aW9uICYgeyBjb25mbGljdHNXaXRoOiBzdHJpbmdbXSB9KS5jb25mbGljdHNXaXRoLFxuICApO1xuXG4gIChuZXdPcHRpb24gYXMgT3B0aW9uICYgeyBpbXBsaWVkOiB1bmtub3duIH0pLmltcGxpZWQgPSAoXG4gICAgb3B0aW9uIGFzIE9wdGlvbiAmIHsgaW1wbGllZDogdW5rbm93biB9XG4gICkuaW1wbGllZDtcblxuICByZXR1cm4gbmV3T3B0aW9uO1xufTtcblxuLyoqXG4gKiBQYXJ0aWFsbHkgcGFyc2UgYXJndiBmb3IgYSBjb21tYW5kIHdpdGhvdXQgZXhlY3V0aW5nIHRoZSBhY3Rpb24uIEBzZWUge0BsaW5rIENvbW1hbmQucGFyc2V9XG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hdGNoZWQgY29tbWFuZCwgdGhlIHByb3ZpZGVkIG9wdGlvbnMsIGFuZCB0aGUgbWlzc2luZyBvcHRpb25zLlxuICovXG5leHBvcnQgY29uc3QgcGFydGlhbFBhcnNlID0gKFxuICBjb21tYW5kOiBDb21tYW5kLFxuICBhcmd2OiByZWFkb25seSBzdHJpbmdbXSxcbiAgb3B0aW9ucz86IFBhcnNlT3B0aW9ucyxcbik6IFBhcnRpYWxQYXJzZVJlc3VsdCA9PiB7XG4gIGNvbnN0IHByb3ZpZGVkT3B0aW9ucyA9IG5ldyBNYXA8Q29tbWFuZCwgT3B0aW9uVmFsdWVzPigpO1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnNTb3VyY2VzID0gbmV3IE1hcDxcbiAgICBDb21tYW5kLFxuICAgIE1hcDxzdHJpbmcsIE9wdGlvblZhbHVlU291cmNlIHwgdW5kZWZpbmVkPlxuICA+KCk7XG4gIGNvbnN0IGNvbW1hbmRzTWFwID0gbmV3IE1hcDxDb21tYW5kLCBDb21tYW5kPigpO1xuICBsZXQgbWF0Y2hlZENvbW1hbmQ6IENvbW1hbmQgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc2V0UHJvdmlkZWRPcHRpb25Tb3VyY2UgPSAoXG4gICAgY29tbWFuZDogQ29tbWFuZCxcbiAgICBvcHRpb25LZXk6IHN0cmluZyxcbiAgICBzb3VyY2U6IE9wdGlvblZhbHVlU291cmNlIHwgdW5kZWZpbmVkLFxuICApID0+IHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZXNNYXAgPVxuICAgICAgcHJvdmlkZWRPcHRpb25zU291cmNlcy5nZXQoY29tbWFuZCkgPz9cbiAgICAgIG5ldyBNYXA8c3RyaW5nLCBPcHRpb25WYWx1ZVNvdXJjZT4oKTtcbiAgICBzb3VyY2VzTWFwLnNldChvcHRpb25LZXksIHNvdXJjZSk7XG4gICAgcHJvdmlkZWRPcHRpb25zU291cmNlcy5zZXQoY29tbWFuZCwgc291cmNlc01hcCk7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlUGFyc2VyQ29tbWFuZCA9IChwYXJzZXJDb21tYW5kOiBDb21tYW5kLCBjb21tYW5kOiBDb21tYW5kKSA9PiB7XG4gICAgY29tbWFuZHNNYXAuc2V0KHBhcnNlckNvbW1hbmQsIGNvbW1hbmQpO1xuXG4gICAgY29weUNvbW1hbmRTZXR0aW5ncyhjb21tYW5kLCBwYXJzZXJDb21tYW5kKTtcbiAgICBkaXNhYmxlQ29tbWFuZE91dHB1dChwYXJzZXJDb21tYW5kKTtcbiAgICBwYXJzZXJDb21tYW5kLmV4aXRPdmVycmlkZSgpO1xuXG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgY29tbWFuZC5vcHRpb25zKSB7XG4gICAgICAvLyBTa2lwIGFkZGluZyB0aGUgb3B0aW9uIGlmIGl0J3MgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICBpZiAoXG4gICAgICAgIHBhcnNlckNvbW1hbmQub3B0aW9ucy5zb21lKFxuICAgICAgICAgIChwYXJzZXJDb21tYW5kT3B0aW9uKSA9PiBwYXJzZXJDb21tYW5kT3B0aW9uLmZsYWdzID09PSBvcHRpb24uZmxhZ3MsXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyQ29tbWFuZC5hZGRPcHRpb24oY2xvbmVPcHRpb24ob3B0aW9uKSk7XG4gICAgfVxuXG4gICAgcGFyc2VyQ29tbWFuZC5ob29rKFwicHJlU3ViY29tbWFuZFwiLCAodGhpc0NvbW1hbmQsIGFjdGlvbkNvbW1hbmQpID0+IHtcbiAgICAgIGZvciAoY29uc3QgY21kIG9mIFt0aGlzQ29tbWFuZCwgYWN0aW9uQ29tbWFuZF0pIHtcbiAgICAgICAgcHJvdmlkZWRPcHRpb25zLnNldChjb21tYW5kc01hcC5nZXQoY21kKSEsIGNtZC5vcHRzKCkpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uS2V5IG9mIE9iamVjdC5rZXlzKGNtZC5vcHRzKCkpKSB7XG4gICAgICAgICAgc2V0UHJvdmlkZWRPcHRpb25Tb3VyY2UoXG4gICAgICAgICAgICBjbWQsXG4gICAgICAgICAgICBvcHRpb25LZXksXG4gICAgICAgICAgICBjbWQuZ2V0T3B0aW9uVmFsdWVTb3VyY2Uob3B0aW9uS2V5KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwYXJzZXJDb21tYW5kLmFjdGlvbigoKSA9PiB7XG4gICAgICBwcm92aWRlZE9wdGlvbnMuc2V0KFxuICAgICAgICBjb21tYW5kc01hcC5nZXQocGFyc2VyQ29tbWFuZCkhLFxuICAgICAgICBwYXJzZXJDb21tYW5kLm9wdHMoKSxcbiAgICAgICk7XG5cbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uS2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlckNvbW1hbmQub3B0cygpKSkge1xuICAgICAgICBzZXRQcm92aWRlZE9wdGlvblNvdXJjZShcbiAgICAgICAgICBjb21tYW5kc01hcC5nZXQocGFyc2VyQ29tbWFuZCkhLFxuICAgICAgICAgIG9wdGlvbktleSxcbiAgICAgICAgICBwYXJzZXJDb21tYW5kLmdldE9wdGlvblZhbHVlU291cmNlKG9wdGlvbktleSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoZWRDb21tYW5kID0gY29tbWFuZDtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3Qgc3ViY29tbWFuZCBvZiBjb21tYW5kLmNvbW1hbmRzIGFzIENvbW1hbmRbXSkge1xuICAgICAgY29uc3QgcGFyc2VyU3ViY29tbWFuZCA9IHBhcnNlckNvbW1hbmQuY29tbWFuZChzdWJjb21tYW5kLm5hbWUoKSk7XG4gICAgICBjcmVhdGVQYXJzZXJDb21tYW5kKHBhcnNlclN1YmNvbW1hbmQsIHN1YmNvbW1hbmQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZXJDb21tYW5kO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlckNvbW1hbmQgPSBjcmVhdGVQYXJzZXJDb21tYW5kKG5ldyBDb21tYW5kKCksIGNvbW1hbmQpO1xuICBwYXJzZXJDb21tYW5kLnBhcnNlKGFyZ3YsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IG1pc3NpbmdPcHRpb25zID0gbWF0Y2hlZENvbW1hbmRcbiAgICA/IGZpbmRNaXNzaW5nT3B0aW9ucyhtYXRjaGVkQ29tbWFuZCwgcHJvdmlkZWRPcHRpb25zKVxuICAgIDogbmV3IE1hcDxDb21tYW5kLCBTZXQ8c3RyaW5nPj4oKTtcblxuICByZXR1cm4ge1xuICAgIG1hdGNoZWRDb21tYW5kLFxuICAgIG1pc3NpbmdPcHRpb25zLFxuICAgIHByb3ZpZGVkT3B0aW9ucyxcbiAgICBwcm92aWRlZE9wdGlvbnNTb3VyY2VzLFxuICB9O1xufTtcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFDTyxJQUFNLE9BQU8sTUFBTTtBQUFDOzs7QUNBM0IsT0FBTyxlQUFlO0FBQ3RCO0FBQUEsRUFFRTtBQUFBLEVBRUE7QUFBQSxPQUVLO0FBRUEsSUFBTSxxQkFBcUIsQ0FDaEMsU0FDQSw2QkFDRztBQUNILFFBQU0sMEJBQTBCLG9CQUFJLElBQTBCO0FBRzlELE1BQUksaUJBQTZDO0FBRWpELFNBQU8sZ0JBQWdCO0FBQ3JCLFVBQU0saUJBQWlCLG9CQUFJLElBQVk7QUFDdkMsVUFBTSxrQkFBa0IseUJBQXlCLElBQUksY0FBYztBQUNuRSxlQUFXLFVBQVUsZUFBZSxTQUFTO0FBQzNDLFlBQU0sTUFBTSxPQUFPLFNBQ2YsVUFBVSxPQUFPLEtBQU0sUUFBUSxVQUFVLEVBQUUsQ0FBQyxJQUM1QyxVQUFXLE9BQU8sUUFBUSxPQUFPLEtBQU87QUFFNUMsVUFBSSxrQkFBa0IsR0FBRyxNQUFNLFFBQVc7QUFDeEM7QUFBQSxNQUNGO0FBRUEscUJBQWUsSUFBSSxHQUFHO0FBQUEsSUFDeEI7QUFFQSw0QkFBd0IsSUFBSSxnQkFBZ0IsY0FBYztBQUMxRCxxQkFBaUIsZUFBZTtBQUFBLEVBQ2xDO0FBRUEsU0FBTztBQUNUO0FBd0JBLElBQU0sc0JBQXNCLENBQUMsUUFBaUIsV0FBb0I7QUFDaEUsYUFBVyxjQUFjO0FBQUEsSUFDdkI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsR0FBWTtBQUVWLElBQUMsT0FBZSxVQUFVLElBQUssT0FBZSxVQUFVO0FBQUEsRUFDMUQ7QUFFQSxTQUFPLEtBQUssT0FBTyxLQUFLLENBQUM7QUFDekIsU0FBTyxRQUFRLE9BQU8sUUFBUSxDQUFDO0FBQy9CLGFBQVcsWUFBWSxPQUFPLHFCQUFxQjtBQUNqRCxXQUFPLFlBQVksUUFBUTtBQUFBLEVBQzdCO0FBRUEsTUFBSSxPQUFPLFFBQVEsR0FBRztBQUNwQixXQUFPO0FBQUEsTUFDTCxPQUFPLFFBQVE7QUFBQSxNQUNmLE9BQU8sUUFBUTtBQUFBLFFBQ2IsQ0FBQyxXQUNDLE9BQU8sY0FBYyxNQUNwQixPQUNFO0FBQUEsTUFDUCxHQUFHO0FBQUEsSUFDTDtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU0sdUJBQXVCLENBQUMsWUFBcUI7QUFDakQsVUFBUSxnQkFBZ0I7QUFBQSxJQUN0QixVQUFVO0FBQUEsSUFDVixVQUFVO0FBQUEsSUFDVixhQUFhO0FBQUEsRUFDZixDQUFDO0FBQ0g7QUFFQSxJQUFNLGNBQWMsQ0FBQyxXQUFtQjtBQUN0QyxRQUFNLFlBQVksSUFBSSxPQUFPLE9BQU8sT0FBTyxPQUFPLFdBQVc7QUFDN0QsWUFBVSxvQkFBb0IsS0FBSztBQUNuQyxZQUFVLFFBQVEsT0FBTyxjQUFjLE9BQU8sdUJBQXVCO0FBRXJFLFlBQVUsT0FBUSxPQUEyQyxTQUFTO0FBQ3RFLFlBQVUsSUFBSyxPQUF1QyxNQUFNO0FBQzVELE1BQUksT0FBTyxVQUFVO0FBQ25CLGNBQVUsVUFBVSxPQUFPLFFBQVE7QUFBQSxFQUNyQztBQUVBLE1BQUksT0FBTyxZQUFZO0FBQ3JCLGNBQVUsUUFBUSxPQUFPLFVBQVU7QUFBQSxFQUNyQztBQUVBLFlBQVU7QUFBQSxJQUNQLE9BQWdEO0FBQUEsRUFDbkQ7QUFFQSxFQUFDLFVBQTRDLFVBQzNDLE9BQ0E7QUFFRixTQUFPO0FBQ1Q7QUFPTyxJQUFNLGVBQWUsQ0FDMUIsU0FDQSxNQUNBLFlBQ3VCO0FBQ3ZCLFFBQU0sa0JBQWtCLG9CQUFJLElBQTJCO0FBQ3ZELFFBQU0seUJBQXlCLG9CQUFJLElBR2pDO0FBQ0YsUUFBTSxjQUFjLG9CQUFJLElBQXNCO0FBQzlDLE1BQUk7QUFFSixRQUFNLDBCQUEwQixDQUM5QkEsVUFDQSxXQUNBLFdBQ0c7QUFDSCxRQUFJLENBQUMsUUFBUTtBQUNYO0FBQUEsSUFDRjtBQUVBLFVBQU0sYUFDSix1QkFBdUIsSUFBSUEsUUFBTyxLQUNsQyxvQkFBSSxJQUErQjtBQUNyQyxlQUFXLElBQUksV0FBVyxNQUFNO0FBQ2hDLDJCQUF1QixJQUFJQSxVQUFTLFVBQVU7QUFBQSxFQUNoRDtBQUVBLFFBQU0sc0JBQXNCLENBQUNDLGdCQUF3QkQsYUFBcUI7QUFDeEUsZ0JBQVksSUFBSUMsZ0JBQWVELFFBQU87QUFFdEMsd0JBQW9CQSxVQUFTQyxjQUFhO0FBQzFDLHlCQUFxQkEsY0FBYTtBQUNsQyxJQUFBQSxlQUFjLGFBQWE7QUFFM0IsZUFBVyxVQUFVRCxTQUFRLFNBQVM7QUFFcEMsVUFDRUMsZUFBYyxRQUFRO0FBQUEsUUFDcEIsQ0FBQyx3QkFBd0Isb0JBQW9CLFVBQVUsT0FBTztBQUFBLE1BQ2hFLEdBQ0E7QUFDQTtBQUFBLE1BQ0Y7QUFFQSxNQUFBQSxlQUFjLFVBQVUsWUFBWSxNQUFNLENBQUM7QUFBQSxJQUM3QztBQUVBLElBQUFBLGVBQWMsS0FBSyxpQkFBaUIsQ0FBQyxhQUFhLGtCQUFrQjtBQUNsRSxpQkFBVyxPQUFPLENBQUMsYUFBYSxhQUFhLEdBQUc7QUFDOUMsd0JBQWdCLElBQUksWUFBWSxJQUFJLEdBQUcsR0FBSSxJQUFJLEtBQUssQ0FBQztBQUVyRCxtQkFBVyxhQUFhLE9BQU8sS0FBSyxJQUFJLEtBQUssQ0FBQyxHQUFHO0FBQy9DO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBLElBQUkscUJBQXFCLFNBQVM7QUFBQSxVQUNwQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRixDQUFDO0FBRUQsSUFBQUEsZUFBYyxPQUFPLE1BQU07QUFDekIsc0JBQWdCO0FBQUEsUUFDZCxZQUFZLElBQUlBLGNBQWE7QUFBQSxRQUM3QkEsZUFBYyxLQUFLO0FBQUEsTUFDckI7QUFFQSxpQkFBVyxhQUFhLE9BQU8sS0FBS0EsZUFBYyxLQUFLLENBQUMsR0FBRztBQUN6RDtBQUFBLFVBQ0UsWUFBWSxJQUFJQSxjQUFhO0FBQUEsVUFDN0I7QUFBQSxVQUNBQSxlQUFjLHFCQUFxQixTQUFTO0FBQUEsUUFDOUM7QUFBQSxNQUNGO0FBRUEsdUJBQWlCRDtBQUFBLElBQ25CLENBQUM7QUFFRCxlQUFXLGNBQWNBLFNBQVEsVUFBdUI7QUFDdEQsWUFBTSxtQkFBbUJDLGVBQWMsUUFBUSxXQUFXLEtBQUssQ0FBQztBQUNoRSwwQkFBb0Isa0JBQWtCLFVBQVU7QUFBQSxJQUNsRDtBQUVBLFdBQU9BO0FBQUEsRUFDVDtBQUVBLFFBQU0sZ0JBQWdCLG9CQUFvQixJQUFJLFFBQVEsR0FBRyxPQUFPO0FBQ2hFLGdCQUFjLE1BQU0sTUFBTSxPQUFPO0FBRWpDLFFBQU0saUJBQWlCLGlCQUNuQixtQkFBbUIsZ0JBQWdCLGVBQWUsSUFDbEQsb0JBQUksSUFBMEI7QUFFbEMsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7IiwKICAibmFtZXMiOiBbImNvbW1hbmQiLCAicGFyc2VyQ29tbWFuZCJdCn0K