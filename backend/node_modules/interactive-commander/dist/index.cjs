var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  InteractiveCommand: () => InteractiveCommand,
  InteractiveOption: () => InteractiveOption
});
module.exports = __toCommonJS(src_exports);

// src/interactive-command.ts
var import_commander2 = require("commander");
var import_parse_my_command = require("parse-my-command");

// src/interactive-option.ts
var inquirer = __toESM(require("@inquirer/prompts"), 1);
var import_commander = require("commander");
var parseArgToValidate = (parseArg) => (value) => {
  if (!parseArg) {
    return true;
  }
  try {
    parseArg(value, void 0);
    return true;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    throw error;
  }
};
var InteractiveOption = class extends import_commander.Option {
  readFunction = this._defaultReadFunction;
  _promptFunctions;
  constructor(flags, description, promptFunctions) {
    super(flags, description);
    this._promptFunctions = promptFunctions ? {
      confirm: promptFunctions.confirm ?? inquirer.confirm,
      input: promptFunctions.input ?? inquirer.input,
      select: promptFunctions.select ?? inquirer.select
    } : inquirer;
  }
  /**
   * Set a function that will be called to read the option value interactively.
   * When undefined is passed, the prompt will be skipped.
   *
   * @param readFunction
   * @returns
   */
  prompt(readFunction) {
    this.readFunction = readFunction;
    return this;
  }
  async _defaultReadFunction(currentValue, option, _command) {
    if (option.isBoolean() || option.negate) {
      const answer2 = await this._promptFunctions.confirm({
        message: option.description,
        default: option.negate ? !currentValue : Boolean(currentValue)
      });
      return option.negate ? !answer2 : answer2;
    }
    if (option.argChoices) {
      const answer2 = await this._promptFunctions.select({
        message: option.description,
        choices: [...option.argChoices].sort(
          (value) => currentValue !== void 0 && value === currentValue || currentValue === void 0 && value === option.defaultValue ? -1 : 0
        ).map((choice) => ({ value: choice }))
      });
      return option.parseArg ? option.parseArg(answer2, void 0) : answer2;
    }
    const answer = await this._promptFunctions.input({
      message: option.description,
      default: currentValue,
      validate: parseArgToValidate(option.parseArg)
    });
    if (!answer || answer.length === 0) {
      return;
    }
    return option.parseArg ? option.parseArg(answer, void 0) : answer;
  }
};

// src/interactive-command.ts
var InteractiveCommand = class _InteractiveCommand extends import_commander2.Command {
  _interactiveOptionName = "interactive";
  /**
   * The command that its parseAsync method is called
   */
  _isRootCommand = false;
  _hasHook = false;
  // The following will only be set on the root command
  _providedOptions;
  _missingOptions;
  _providedOptionsSources;
  _pluginRegistrations = /* @__PURE__ */ new Set();
  createCommand(name) {
    return new _InteractiveCommand(name);
  }
  createOption(flags, description) {
    return new InteractiveOption(flags, description);
  }
  version(...args) {
    const returnValue = super.version(...args);
    const versionOptionName = this._versionOptionName;
    if (!versionOptionName) {
      return returnValue;
    }
    const versionOption = this.options.find(
      (option) => option.attributeName() === versionOptionName
    );
    versionOption.prompt(void 0);
    return returnValue;
  }
  /**
   * Enable interactive mode
   *
   * This method recursively auto-registers the "-i, --interactive" flag which
   * prompts the user for missing (interactive) options.
   *
   * You can optionally supply the flags and description to override the
   * defaults.
   *
   * This method should almost always be called on the root command, after all
   * subcommands are hooks are added/configured.
   */
  interactive(flags, description) {
    const newOption = new import_commander2.Option(
      flags ?? "-i, --interactive",
      description ?? "interactive mode"
    );
    const existingOption = this.options.find(
      (option) => option.attributeName() === newOption.attributeName()
    );
    if (!existingOption) {
      this.addOption(newOption);
      this._interactiveOptionName = newOption.attributeName();
    }
    this.addHookIfAbsent();
    for (const command of this.commands) {
      if (!(command instanceof _InteractiveCommand)) {
        continue;
      }
      command.interactive(flags, description);
    }
    return this;
  }
  parse(argv, options) {
    throw new Error("parse is not supported! Use parseAsync instead!");
  }
  async parseAsync(argv, options) {
    await Promise.all(this._pluginRegistrations);
    this._isRootCommand = true;
    try {
      const { providedOptions, missingOptions, providedOptionsSources } = (0, import_parse_my_command.partialParse)(this, argv ?? process.argv, options);
      this._providedOptions = providedOptions;
      this._missingOptions = missingOptions;
      this._providedOptionsSources = providedOptionsSources;
    } catch (error) {
      if (!(error instanceof import_commander2.CommanderError || // This is needed for the minified version
      error.name === "CommanderError")) {
        throw error;
      }
      const commanderError = error;
      if (!["commander.helpDisplayed"].includes(commanderError.code)) {
        super.error(commanderError.message, commanderError);
      }
    }
    return super.parseAsync(argv, options);
  }
  use(argument_) {
    const registerFunction = typeof argument_ === "string" ? async (command) => {
      const imported = await import(argument_);
      await imported.register(command);
    } : argument_;
    const result = Promise.resolve(registerFunction(this));
    this._pluginRegistrations.add(result);
    return this;
  }
  async readMissingOptions(options, providedOptions) {
    for (const option of options) {
      if (!(option instanceof InteractiveOption && option.readFunction)) {
        continue;
      }
      const key = option.attributeName();
      const value = await option.readFunction(
        this.getOptionValue(key) ?? providedOptions[key],
        option,
        this
      );
      if (option.required && value === void 0) {
        this.missingMandatoryOptionValue(option);
      }
      this.setOptionValue(option.attributeName(), value);
    }
  }
  findRootCommand() {
    let currentCommand = this;
    while (currentCommand) {
      if (currentCommand._isRootCommand) {
        return currentCommand;
      }
      currentCommand = currentCommand.parent;
    }
    throw new Error("Root command not found!");
  }
  addHookIfAbsent() {
    if (this._hasHook) {
      return;
    }
    this._hasHook = true;
    this.hook(
      "preSubcommand",
      async (thisCommand, actionCommand) => {
        if (!(thisCommand instanceof _InteractiveCommand) || !(actionCommand instanceof _InteractiveCommand)) {
          return;
        }
        if (!thisCommand.optsWithGlobals()[this._interactiveOptionName]) {
          return;
        }
        const rootCommand = this.findRootCommand();
        const providedOptions = rootCommand._providedOptions;
        const missingOptions = rootCommand._missingOptions;
        const providedOptionsSources = rootCommand._providedOptionsSources;
        for (const command of [thisCommand, actionCommand]) {
          const cliOptions = new Set(
            [...providedOptionsSources?.get(command)?.entries() ?? []].filter(([_, value]) => value === "cli").map(([key]) => key)
          );
          const optionKeys = [
            ...Object.keys(providedOptions?.get(command) ?? {}),
            ...missingOptions?.get(command)?.keys() ?? /* @__PURE__ */ new Set()
          ];
          const nonCliOptions = optionKeys.filter((key) => !cliOptions.has(key)).map(
            (key) => command.options.find((option) => option.attributeName() === key)
          ).filter(Boolean);
          nonCliOptions.sort((a, b) => {
            const aIndex = command.options.findIndex(
              (option) => option.attributeName() === a.attributeName()
            );
            const bIndex = command.options.findIndex(
              (option) => option.attributeName() === b.attributeName()
            );
            return aIndex - bIndex;
          });
          await command.readMissingOptions(
            nonCliOptions,
            providedOptions?.get(command) ?? {}
          );
        }
      }
    );
  }
};

// src/index.ts
__reExport(src_exports, require("commander"), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InteractiveCommand,
  InteractiveOption,
  ...require("commander")
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9pbnRlcmFjdGl2ZS1jb21tYW5kLnRzIiwgIi4uL3NyYy9pbnRlcmFjdGl2ZS1vcHRpb24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCB7IEludGVyYWN0aXZlQ29tbWFuZCB9IGZyb20gXCIuL2ludGVyYWN0aXZlLWNvbW1hbmQudHNcIjtcbmV4cG9ydCB7IEludGVyYWN0aXZlT3B0aW9uIH0gZnJvbSBcIi4vaW50ZXJhY3RpdmUtb3B0aW9uLnRzXCI7XG5leHBvcnQgKiBmcm9tIFwiY29tbWFuZGVyXCI7XG5leHBvcnQgeyB0eXBlIFJlZ2lzdGVyRnVuY3Rpb24gfSBmcm9tIFwiLi9jb21tYW5kLXBsdWdpbi50c1wiO1xuIiwgImltcG9ydCB7XG4gIENvbW1hbmQsXG4gIENvbW1hbmRlckVycm9yLFxuICBPcHRpb24sXG4gIHR5cGUgT3B0aW9uVmFsdWVTb3VyY2UsXG4gIHR5cGUgT3B0aW9uVmFsdWVzLFxuICB0eXBlIFBhcnNlT3B0aW9ucyxcbn0gZnJvbSBcImNvbW1hbmRlclwiO1xuaW1wb3J0IHsgcGFydGlhbFBhcnNlIH0gZnJvbSBcInBhcnNlLW15LWNvbW1hbmRcIjtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbmltcG9ydCB0eXBlIHsgUmVnaXN0ZXJGdW5jdGlvbiB9IGZyb20gXCIuL2NvbW1hbmQtcGx1Z2luLnRzXCI7XG5pbXBvcnQgeyBJbnRlcmFjdGl2ZU9wdGlvbiB9IGZyb20gXCIuL2ludGVyYWN0aXZlLW9wdGlvbi50c1wiO1xuXG5leHBvcnQgY2xhc3MgSW50ZXJhY3RpdmVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHByaXZhdGUgX2ludGVyYWN0aXZlT3B0aW9uTmFtZSA9IFwiaW50ZXJhY3RpdmVcIjtcbiAgLyoqXG4gICAqIFRoZSBjb21tYW5kIHRoYXQgaXRzIHBhcnNlQXN5bmMgbWV0aG9kIGlzIGNhbGxlZFxuICAgKi9cbiAgcHJpdmF0ZSBfaXNSb290Q29tbWFuZCA9IGZhbHNlO1xuICBwcml2YXRlIF9oYXNIb29rID0gZmFsc2U7XG5cbiAgLy8gVGhlIGZvbGxvd2luZyB3aWxsIG9ubHkgYmUgc2V0IG9uIHRoZSByb290IGNvbW1hbmRcbiAgcHJpdmF0ZSBfcHJvdmlkZWRPcHRpb25zOiBNYXA8Q29tbWFuZCwgT3B0aW9uVmFsdWVzPiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfbWlzc2luZ09wdGlvbnM6IE1hcDxDb21tYW5kLCBTZXQ8c3RyaW5nPj4gfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX3Byb3ZpZGVkT3B0aW9uc1NvdXJjZXM6XG4gICAgfCBNYXA8Q29tbWFuZCwgTWFwPHN0cmluZywgT3B0aW9uVmFsdWVTb3VyY2UgfCB1bmRlZmluZWQ+PlxuICAgIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3BsdWdpblJlZ2lzdHJhdGlvbnMgPSBuZXcgU2V0PFByb21pc2U8dm9pZD4+KCk7XG5cbiAgY3JlYXRlQ29tbWFuZChuYW1lPzogc3RyaW5nKTogSW50ZXJhY3RpdmVDb21tYW5kIHtcbiAgICByZXR1cm4gbmV3IEludGVyYWN0aXZlQ29tbWFuZChuYW1lKTtcbiAgfVxuXG4gIGNyZWF0ZU9wdGlvbihmbGFnczogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IEludGVyYWN0aXZlT3B0aW9uIHtcbiAgICByZXR1cm4gbmV3IEludGVyYWN0aXZlT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbik7XG4gIH1cblxuICB2ZXJzaW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgdmVyc2lvbihzdHI6IHN0cmluZywgZmxhZ3M/OiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogdGhpcztcbiAgdmVyc2lvbiguLi5hcmdzOiBQYXJhbWV0ZXJzPENvbW1hbmRbXCJ2ZXJzaW9uXCJdPik6IHRoaXMgfCBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gc3VwZXIudmVyc2lvbiguLi5hcmdzKTtcblxuICAgIGNvbnN0IHZlcnNpb25PcHRpb25OYW1lID0gKHRoaXMgYXMgdGhpcyAmIHsgX3ZlcnNpb25PcHRpb25OYW1lPzogc3RyaW5nIH0pXG4gICAgICAuX3ZlcnNpb25PcHRpb25OYW1lO1xuXG4gICAgaWYgKCF2ZXJzaW9uT3B0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZlcnNpb25PcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZChcbiAgICAgIChvcHRpb24pID0+IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCkgPT09IHZlcnNpb25PcHRpb25OYW1lLFxuICAgICkgYXMgSW50ZXJhY3RpdmVPcHRpb247XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdXNlbGVzcy11bmRlZmluZWRcbiAgICB2ZXJzaW9uT3B0aW9uLnByb21wdCh1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBpbnRlcmFjdGl2ZSBtb2RlXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJlY3Vyc2l2ZWx5IGF1dG8tcmVnaXN0ZXJzIHRoZSBcIi1pLCAtLWludGVyYWN0aXZlXCIgZmxhZyB3aGljaFxuICAgKiBwcm9tcHRzIHRoZSB1c2VyIGZvciBtaXNzaW5nIChpbnRlcmFjdGl2ZSkgb3B0aW9ucy5cbiAgICpcbiAgICogWW91IGNhbiBvcHRpb25hbGx5IHN1cHBseSB0aGUgZmxhZ3MgYW5kIGRlc2NyaXB0aW9uIHRvIG92ZXJyaWRlIHRoZVxuICAgKiBkZWZhdWx0cy5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGFsbW9zdCBhbHdheXMgYmUgY2FsbGVkIG9uIHRoZSByb290IGNvbW1hbmQsIGFmdGVyIGFsbFxuICAgKiBzdWJjb21tYW5kcyBhcmUgaG9va3MgYXJlIGFkZGVkL2NvbmZpZ3VyZWQuXG4gICAqL1xuICBpbnRlcmFjdGl2ZShmbGFncz86IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCBuZXdPcHRpb24gPSBuZXcgT3B0aW9uKFxuICAgICAgZmxhZ3MgPz8gXCItaSwgLS1pbnRlcmFjdGl2ZVwiLFxuICAgICAgZGVzY3JpcHRpb24gPz8gXCJpbnRlcmFjdGl2ZSBtb2RlXCIsXG4gICAgKTtcblxuICAgIGNvbnN0IGV4aXN0aW5nT3B0aW9uID0gdGhpcy5vcHRpb25zLmZpbmQoXG4gICAgICAob3B0aW9uKSA9PiBvcHRpb24uYXR0cmlidXRlTmFtZSgpID09PSBuZXdPcHRpb24uYXR0cmlidXRlTmFtZSgpLFxuICAgICk7XG5cbiAgICBpZiAoIWV4aXN0aW5nT3B0aW9uKSB7XG4gICAgICB0aGlzLmFkZE9wdGlvbihuZXdPcHRpb24pO1xuICAgICAgdGhpcy5faW50ZXJhY3RpdmVPcHRpb25OYW1lID0gbmV3T3B0aW9uLmF0dHJpYnV0ZU5hbWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEhvb2tJZkFic2VudCgpO1xuXG4gICAgZm9yIChjb25zdCBjb21tYW5kIG9mIHRoaXMuY29tbWFuZHMgYXMgQXJyYXk8XG4gICAgICBJbnRlcmFjdGl2ZUNvbW1hbmQgfCBDb21tYW5kXG4gICAgPikge1xuICAgICAgaWYgKCEoY29tbWFuZCBpbnN0YW5jZW9mIEludGVyYWN0aXZlQ29tbWFuZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbW1hbmQuaW50ZXJhY3RpdmUoZmxhZ3MsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBhcnNlKGFyZ3Y/OiByZWFkb25seSBzdHJpbmdbXSwgb3B0aW9ucz86IFBhcnNlT3B0aW9ucyk6IHRoaXMge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBhcnNlIGlzIG5vdCBzdXBwb3J0ZWQhIFVzZSBwYXJzZUFzeW5jIGluc3RlYWQhXCIpO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VBc3luYyhcbiAgICBhcmd2PzogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgb3B0aW9ucz86IFBhcnNlT3B0aW9ucyxcbiAgKTogUHJvbWlzZTx0aGlzPiB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fcGx1Z2luUmVnaXN0cmF0aW9ucyk7XG5cbiAgICB0aGlzLl9pc1Jvb3RDb21tYW5kID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwcm92aWRlZE9wdGlvbnMsIG1pc3NpbmdPcHRpb25zLCBwcm92aWRlZE9wdGlvbnNTb3VyY2VzIH0gPVxuICAgICAgICBwYXJ0aWFsUGFyc2UodGhpcywgYXJndiA/PyBwcm9jZXNzLmFyZ3YsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9wcm92aWRlZE9wdGlvbnMgPSBwcm92aWRlZE9wdGlvbnM7XG4gICAgICB0aGlzLl9taXNzaW5nT3B0aW9ucyA9IG1pc3NpbmdPcHRpb25zO1xuICAgICAgdGhpcy5fcHJvdmlkZWRPcHRpb25zU291cmNlcyA9IHByb3ZpZGVkT3B0aW9uc1NvdXJjZXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbW1hbmRlckVycm9yIHx8XG4gICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIHRoZSBtaW5pZmllZCB2ZXJzaW9uXG4gICAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJDb21tYW5kZXJFcnJvclwiXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tbWFuZGVyRXJyb3IgPSBlcnJvciBhcyBDb21tYW5kZXJFcnJvcjtcblxuICAgICAgLy8gSXMgdGhpcyBlbm91Z2g/XG4gICAgICBpZiAoIVtcImNvbW1hbmRlci5oZWxwRGlzcGxheWVkXCJdLmluY2x1ZGVzKGNvbW1hbmRlckVycm9yLmNvZGUpKSB7XG4gICAgICAgIHN1cGVyLmVycm9yKGNvbW1hbmRlckVycm9yLm1lc3NhZ2UsIGNvbW1hbmRlckVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFdmVuIGlmIHdlIHByb21wdCBmb3IgdGhlIG1pc3Npbmcgb3B0aW9ucyBvZiB0aGUgcm9vdCBjb21tYW5kIGhlcmUsIHRoZXJlXG4gICAgLy8gaXMgbm8gZWFzeSB3YXkgdG8gZmVlZCB0aGVtIGludG8gc3VwZXIucGFyc2VBc3luYy4gVGhlcmVmb3JlLCBpbnRlcmFjdGl2ZVxuICAgIC8vIG9wdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhlIHJvb3QgY29tbWFuZCB3aGVuIG5vIHN1YmNvbW1hbmQgaXNcbiAgICAvLyBpbnZva2VkLiBUaGlzIGlzIGEgbGltaXRhdGlvbiBvZiBDb21tYW5kZXIuanMuIFRoZSBvbmx5IHN1cHBvcnRlZCBob29rXG4gICAgLy8gaXMgXCJwcmVTdWJjb21tYW5kXCIgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHBhcnNpbmcgYXJndiBhbmQgYmVmb3JlIGNhbGxpbmdcbiAgICAvLyB0aGUgc3ViY29tbWFuZCdzIGFjdGlvbi5cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUFzeW5jKGFyZ3YsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoT3JNb2R1bGVOYW1lIFRoZSBwYXRoIHRvIHRoZSBzY3JpcHQgb3IgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtb2R1bGVcbiAgICogdG8gaW1wb3J0LiBUaGUgcGx1Z2luIG1vZHVsZSBtdXN0IGV4cG9ydCBhIGByZWdpc3RlcmAgZnVuY3Rpb24gdGhhdFxuICAgKiB0YWtlcyBhbiBgSW50ZXJhY3RpdmVDb21tYW5kYCBpbnN0YW5jZSBhcyBpdHMgb25seSBhcmd1bWVudC5cbiAgICovXG4gIHVzZShwYXRoT3JNb2R1bGVOYW1lOiBzdHJpbmcpOiB0aGlzO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpblxuICAgKlxuICAgKiBAcGFyYW0gcmVnaXN0ZXJGdW5jdGlvbiBUaGUgZnVuY3Rpb24gdGhhdCByZWdpc3RlcnMgdGhlIHBsdWdpblxuICAgKi9cbiAgdXNlKHJlZ2lzdGVyRnVuY3Rpb246IFJlZ2lzdGVyRnVuY3Rpb24pOiB0aGlzO1xuXG4gIHVzZShhcmd1bWVudF86IHVua25vd24pOiB0aGlzIHtcbiAgICBjb25zdCByZWdpc3RlckZ1bmN0aW9uID1cbiAgICAgIHR5cGVvZiBhcmd1bWVudF8gPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBhc3luYyAoY29tbWFuZDogSW50ZXJhY3RpdmVDb21tYW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZCA9IChhd2FpdCBpbXBvcnQoYXJndW1lbnRfKSkgYXMge1xuICAgICAgICAgICAgICByZWdpc3RlcjogUmVnaXN0ZXJGdW5jdGlvbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBpbXBvcnRlZC5yZWdpc3Rlcihjb21tYW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIDogKGFyZ3VtZW50XyBhcyBSZWdpc3RlckZ1bmN0aW9uKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZWdpc3RlckZ1bmN0aW9uKHRoaXMpKTtcbiAgICB0aGlzLl9wbHVnaW5SZWdpc3RyYXRpb25zLmFkZChyZXN1bHQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlYWRNaXNzaW5nT3B0aW9ucyhcbiAgICBvcHRpb25zOiBPcHRpb25bXSxcbiAgICBwcm92aWRlZE9wdGlvbnM6IE9wdGlvblZhbHVlcyxcbiAgKSB7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9uIGluc3RhbmNlb2YgSW50ZXJhY3RpdmVPcHRpb24gJiYgb3B0aW9uLnJlYWRGdW5jdGlvbikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IG9wdGlvbi5yZWFkRnVuY3Rpb24oXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uVmFsdWUoa2V5KSA/PyBwcm92aWRlZE9wdGlvbnNba2V5XSxcbiAgICAgICAgb3B0aW9uLFxuICAgICAgICB0aGlzLFxuICAgICAgKTtcblxuICAgICAgaWYgKG9wdGlvbi5yZXF1aXJlZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIChcbiAgICAgICAgICB0aGlzIGFzIHRoaXMgJiB7XG4gICAgICAgICAgICBtaXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWU6IChPcHRpb246IEludGVyYWN0aXZlT3B0aW9uKSA9PiB2b2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgKS5taXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWUob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPcHRpb25WYWx1ZShvcHRpb24uYXR0cmlidXRlTmFtZSgpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kUm9vdENvbW1hbmQoKTogSW50ZXJhY3RpdmVDb21tYW5kIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10aGlzLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgbGV0IGN1cnJlbnRDb21tYW5kOiBJbnRlcmFjdGl2ZUNvbW1hbmQgfCB1bmRlZmluZWQgPSB0aGlzO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRDb21tYW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbW1hbmQuX2lzUm9vdENvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb21tYW5kO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Q29tbWFuZCA9IGN1cnJlbnRDb21tYW5kLnBhcmVudCBhcyBJbnRlcmFjdGl2ZUNvbW1hbmQgfCB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjb21tYW5kIG5vdCBmb3VuZCFcIik7XG4gIH1cblxuICBwcml2YXRlIGFkZEhvb2tJZkFic2VudCgpIHtcbiAgICBpZiAodGhpcy5faGFzSG9vaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc0hvb2sgPSB0cnVlO1xuXG4gICAgdGhpcy5ob29rKFxuICAgICAgXCJwcmVTdWJjb21tYW5kXCIsXG4gICAgICBhc3luYyAoXG4gICAgICAgIHRoaXNDb21tYW5kOiBJbnRlcmFjdGl2ZUNvbW1hbmQsXG4gICAgICAgIGFjdGlvbkNvbW1hbmQ6IEludGVyYWN0aXZlQ29tbWFuZCxcbiAgICAgICkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgISh0aGlzQ29tbWFuZCBpbnN0YW5jZW9mIEludGVyYWN0aXZlQ29tbWFuZCkgfHxcbiAgICAgICAgICAhKGFjdGlvbkNvbW1hbmQgaW5zdGFuY2VvZiBJbnRlcmFjdGl2ZUNvbW1hbmQpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpc0NvbW1hbmQub3B0c1dpdGhHbG9iYWxzKClbdGhpcy5faW50ZXJhY3RpdmVPcHRpb25OYW1lXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3RDb21tYW5kID0gdGhpcy5maW5kUm9vdENvbW1hbmQoKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZWRPcHRpb25zID0gcm9vdENvbW1hbmQuX3Byb3ZpZGVkT3B0aW9ucztcbiAgICAgICAgY29uc3QgbWlzc2luZ09wdGlvbnMgPSByb290Q29tbWFuZC5fbWlzc2luZ09wdGlvbnM7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVkT3B0aW9uc1NvdXJjZXMgPSByb290Q29tbWFuZC5fcHJvdmlkZWRPcHRpb25zU291cmNlcztcblxuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgW3RoaXNDb21tYW5kLCBhY3Rpb25Db21tYW5kXSkge1xuICAgICAgICAgIGNvbnN0IGNsaU9wdGlvbnMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgWy4uLihwcm92aWRlZE9wdGlvbnNTb3VyY2VzPy5nZXQoY29tbWFuZCk/LmVudHJpZXMoKSA/PyBbXSldXG4gICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlID09PSBcImNsaVwiKVxuICAgICAgICAgICAgICAubWFwKChba2V5XSkgPT4ga2V5KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG9wdGlvbktleXMgPSBbXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhwcm92aWRlZE9wdGlvbnM/LmdldChjb21tYW5kKSA/PyB7fSksXG4gICAgICAgICAgICAuLi4obWlzc2luZ09wdGlvbnM/LmdldChjb21tYW5kKT8ua2V5cygpID8/IG5ldyBTZXQoKSksXG4gICAgICAgICAgXSBhcyBzdHJpbmdbXTtcbiAgICAgICAgICBjb25zdCBub25DbGlPcHRpb25zID0gb3B0aW9uS2V5c1xuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiAhY2xpT3B0aW9ucy5oYXMoa2V5KSlcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT5cbiAgICAgICAgICAgICAgY29tbWFuZC5vcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLmF0dHJpYnV0ZU5hbWUoKSA9PT0ga2V5KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgT3B0aW9uW107XG5cbiAgICAgICAgICBub25DbGlPcHRpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFJbmRleCA9IGNvbW1hbmQub3B0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgIChvcHRpb24pID0+IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCkgPT09IGEuYXR0cmlidXRlTmFtZSgpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgYkluZGV4ID0gY29tbWFuZC5vcHRpb25zLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgKG9wdGlvbikgPT4gb3B0aW9uLmF0dHJpYnV0ZU5hbWUoKSA9PT0gYi5hdHRyaWJ1dGVOYW1lKCksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gYUluZGV4IC0gYkluZGV4O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgY29tbWFuZC5yZWFkTWlzc2luZ09wdGlvbnMoXG4gICAgICAgICAgICBub25DbGlPcHRpb25zLFxuICAgICAgICAgICAgcHJvdmlkZWRPcHRpb25zPy5nZXQoY29tbWFuZCkgPz8ge30sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgaW5xdWlyZXIgZnJvbSBcIkBpbnF1aXJlci9wcm9tcHRzXCI7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiY29tbWFuZGVyXCI7XG5pbXBvcnQgdHlwZSB7IEludGVyYWN0aXZlQ29tbWFuZCB9IGZyb20gXCIuL2ludGVyYWN0aXZlLWNvbW1hbmQudHNcIjtcblxuZXhwb3J0IHR5cGUgUmVhZEZ1bmN0aW9uID0gKFxuICBjdXJyZW50VmFsdWU6IHVua25vd24sXG4gIG9wdGlvbjogSW50ZXJhY3RpdmVPcHRpb24sXG4gIGNvbW1hbmQ6IEludGVyYWN0aXZlQ29tbWFuZCxcbikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuZXhwb3J0IHR5cGUgUHJvbXB0RnVuY3Rpb25zID0ge1xuICBjb25maXJtOiB0eXBlb2YgaW5xdWlyZXIuY29uZmlybTtcbiAgaW5wdXQ6IHR5cGVvZiBpbnF1aXJlci5pbnB1dDtcbiAgc2VsZWN0OiB0eXBlb2YgaW5xdWlyZXIuc2VsZWN0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXJzZUFyZyBmdW5jdGlvbiBvZiBhbiBPcHRpb24gdG8gYSB2YWxpZGF0ZSBmdW5jdGlvbiB0aGF0IGNhblxuICogYmUgdXNlZCBpbiBpbnF1aXJlci5cbiAqXG4gKiBAcGFyYW0gcGFyc2VBcmcgcGFyc2VBcmcgZnVuY3Rpb24gZnJvbSBhbiBvcHRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlQXJnVG9WYWxpZGF0ZSA9XG4gIChwYXJzZUFyZz86ICh2YWx1ZTogc3RyaW5nLCBwcmV2aW91czogdW5rbm93bikgPT4gdW5rbm93bikgPT5cbiAgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXBhcnNlQXJnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcGFyc2VBcmcodmFsdWUsIHVuZGVmaW5lZCBhcyB1bmtub3duKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgY2xhc3MgSW50ZXJhY3RpdmVPcHRpb24gZXh0ZW5kcyBPcHRpb24ge1xuICBwdWJsaWMgcmVhZEZ1bmN0aW9uOiBSZWFkRnVuY3Rpb24gfCB1bmRlZmluZWQgPSB0aGlzLl9kZWZhdWx0UmVhZEZ1bmN0aW9uO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcm9tcHRGdW5jdGlvbnM6IFByb21wdEZ1bmN0aW9ucztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBmbGFnczogc3RyaW5nLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICAgIHByb21wdEZ1bmN0aW9ucz86IFBhcnRpYWw8UHJvbXB0RnVuY3Rpb25zPixcbiAgKSB7XG4gICAgc3VwZXIoZmxhZ3MsIGRlc2NyaXB0aW9uKTtcblxuICAgIHRoaXMuX3Byb21wdEZ1bmN0aW9ucyA9IHByb21wdEZ1bmN0aW9uc1xuICAgICAgPyB7XG4gICAgICAgICAgY29uZmlybTogcHJvbXB0RnVuY3Rpb25zLmNvbmZpcm0gPz8gaW5xdWlyZXIuY29uZmlybSxcbiAgICAgICAgICBpbnB1dDogcHJvbXB0RnVuY3Rpb25zLmlucHV0ID8/IGlucXVpcmVyLmlucHV0LFxuICAgICAgICAgIHNlbGVjdDogcHJvbXB0RnVuY3Rpb25zLnNlbGVjdCA/PyBpbnF1aXJlci5zZWxlY3QsXG4gICAgICAgIH1cbiAgICAgIDogaW5xdWlyZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB0byByZWFkIHRoZSBvcHRpb24gdmFsdWUgaW50ZXJhY3RpdmVseS5cbiAgICogV2hlbiB1bmRlZmluZWQgaXMgcGFzc2VkLCB0aGUgcHJvbXB0IHdpbGwgYmUgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHJlYWRGdW5jdGlvblxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHJvbXB0KHJlYWRGdW5jdGlvbjogUmVhZEZ1bmN0aW9uIHwgdW5kZWZpbmVkKTogdGhpcyB7XG4gICAgdGhpcy5yZWFkRnVuY3Rpb24gPSByZWFkRnVuY3Rpb247XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2RlZmF1bHRSZWFkRnVuY3Rpb24oXG4gICAgY3VycmVudFZhbHVlOiB1bmtub3duLFxuICAgIG9wdGlvbjogSW50ZXJhY3RpdmVPcHRpb24sXG4gICAgX2NvbW1hbmQ6IEludGVyYWN0aXZlQ29tbWFuZCxcbiAgKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgaWYgKG9wdGlvbi5pc0Jvb2xlYW4oKSB8fCBvcHRpb24ubmVnYXRlKSB7XG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wcm9tcHRGdW5jdGlvbnMuY29uZmlybSh7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgZGVmYXVsdDogb3B0aW9uLm5lZ2F0ZSA/ICFjdXJyZW50VmFsdWUgOiBCb29sZWFuKGN1cnJlbnRWYWx1ZSksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9wdGlvbi5uZWdhdGUgPyAhYW5zd2VyIDogYW5zd2VyO1xuICAgIH1cblxuICAgIGlmIChvcHRpb24uYXJnQ2hvaWNlcykge1xuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcHJvbXB0RnVuY3Rpb25zLnNlbGVjdCh7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgY2hvaWNlczogWy4uLm9wdGlvbi5hcmdDaG9pY2VzXVxuICAgICAgICAgIC5zb3J0KCh2YWx1ZSkgPT5cbiAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gY3VycmVudFZhbHVlKSB8fFxuICAgICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSBvcHRpb24uZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICApXG4gICAgICAgICAgLm1hcCgoY2hvaWNlKSA9PiAoeyB2YWx1ZTogY2hvaWNlIH0pKSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb3B0aW9uLnBhcnNlQXJnXG4gICAgICAgID8gb3B0aW9uLnBhcnNlQXJnKGFuc3dlciwgdW5kZWZpbmVkIGFzIHVua25vd24pXG4gICAgICAgIDogYW5zd2VyO1xuICAgIH1cblxuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3Byb21wdEZ1bmN0aW9ucy5pbnB1dCh7XG4gICAgICBtZXNzYWdlOiBvcHRpb24uZGVzY3JpcHRpb24sXG4gICAgICBkZWZhdWx0OiBjdXJyZW50VmFsdWUgYXMgc3RyaW5nLFxuICAgICAgdmFsaWRhdGU6IHBhcnNlQXJnVG9WYWxpZGF0ZShvcHRpb24ucGFyc2VBcmcpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFhbnN3ZXIgfHwgYW5zd2VyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb24ucGFyc2VBcmdcbiAgICAgID8gb3B0aW9uLnBhcnNlQXJnKGFuc3dlciwgdW5kZWZpbmVkIGFzIHVua25vd24pXG4gICAgICA6IGFuc3dlcjtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxJQUFBQSxvQkFPTztBQUNQLDhCQUE2Qjs7O0FDUjdCLGVBQTBCO0FBQzFCLHVCQUF1QjtBQXFCaEIsSUFBTSxxQkFDWCxDQUFDLGFBQ0QsQ0FBQyxVQUFrQjtBQUNqQixNQUFJLENBQUMsVUFBVTtBQUNiLFdBQU87QUFBQSxFQUNUO0FBRUEsTUFBSTtBQUNGLGFBQVMsT0FBTyxNQUFvQjtBQUNwQyxXQUFPO0FBQUEsRUFDVCxTQUFTLE9BQU87QUFDZCxRQUFJLGlCQUFpQixPQUFPO0FBQzFCLGFBQU8sTUFBTTtBQUFBLElBQ2Y7QUFFQSxVQUFNO0FBQUEsRUFDUjtBQUNGO0FBRUssSUFBTSxvQkFBTixjQUFnQyx3QkFBTztBQUFBLEVBQ3JDLGVBQXlDLEtBQUs7QUFBQSxFQUNwQztBQUFBLEVBRWpCLFlBQ0UsT0FDQSxhQUNBLGlCQUNBO0FBQ0EsVUFBTSxPQUFPLFdBQVc7QUFFeEIsU0FBSyxtQkFBbUIsa0JBQ3BCO0FBQUEsTUFDRSxTQUFTLGdCQUFnQixXQUFvQjtBQUFBLE1BQzdDLE9BQU8sZ0JBQWdCLFNBQWtCO0FBQUEsTUFDekMsUUFBUSxnQkFBZ0IsVUFBbUI7QUFBQSxJQUM3QyxJQUNBO0FBQUEsRUFDTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFTQSxPQUFPLGNBQThDO0FBQ25ELFNBQUssZUFBZTtBQUVwQixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBYyxxQkFDWixjQUNBLFFBQ0EsVUFDa0I7QUFDbEIsUUFBSSxP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