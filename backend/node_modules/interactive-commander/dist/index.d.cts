import { Option, Command, ParseOptions } from 'commander';
export * from 'commander';
import * as inquirer from '@inquirer/prompts';

/**
 * @param command The command instance that the plugin is registered on
 */
type RegisterFunction = (command: InteractiveCommand) => Promise<void> | void;

type ReadFunction = (currentValue: unknown, option: InteractiveOption, command: InteractiveCommand) => Promise<unknown>;
type PromptFunctions = {
    confirm: typeof inquirer.confirm;
    input: typeof inquirer.input;
    select: typeof inquirer.select;
};
declare class InteractiveOption extends Option {
    readFunction: ReadFunction | undefined;
    private readonly _promptFunctions;
    constructor(flags: string, description?: string, promptFunctions?: Partial<PromptFunctions>);
    /**
     * Set a function that will be called to read the option value interactively.
     * When undefined is passed, the prompt will be skipped.
     *
     * @param readFunction
     * @returns
     */
    prompt(readFunction: ReadFunction | undefined): this;
    private _defaultReadFunction;
}

declare class InteractiveCommand extends Command {
    private _interactiveOptionName;
    /**
     * The command that its parseAsync method is called
     */
    private _isRootCommand;
    private _hasHook;
    private _providedOptions;
    private _missingOptions;
    private _providedOptionsSources;
    private readonly _pluginRegistrations;
    createCommand(name?: string): InteractiveCommand;
    createOption(flags: string, description?: string): InteractiveOption;
    version(): string | undefined;
    version(str: string, flags?: string, description?: string): this;
    /**
     * Enable interactive mode
     *
     * This method recursively auto-registers the "-i, --interactive" flag which
     * prompts the user for missing (interactive) options.
     *
     * You can optionally supply the flags and description to override the
     * defaults.
     *
     * This method should almost always be called on the root command, after all
     * subcommands are hooks are added/configured.
     */
    interactive(flags?: string, description?: string): this;
    parse(argv?: readonly string[], options?: ParseOptions): this;
    parseAsync(argv?: readonly string[], options?: ParseOptions): Promise<this>;
    /**
     * Register a plugin
     *
     * @param pathOrModuleName The path to the script or the name of the plugin module
     * to import. The plugin module must export a `register` function that
     * takes an `InteractiveCommand` instance as its only argument.
     */
    use(pathOrModuleName: string): this;
    /**
     * Register a plugin
     *
     * @param registerFunction The function that registers the plugin
     */
    use(registerFunction: RegisterFunction): this;
    private readMissingOptions;
    private findRootCommand;
    private addHookIfAbsent;
}

export { InteractiveCommand, InteractiveOption, type RegisterFunction };
