// src/cli/index.ts
import dotenv from "dotenv";
import { InteractiveCommand as InteractiveCommand2 } from "interactive-commander";
import figlet3 from "figlet";
import { vice as vice3 } from "gradient-string";

// src/cli/cmd/auth.ts
import { Command } from "interactive-commander";
import Ora from "ora";

// src/cli/utils/settings.ts
import os from "os";
import path from "path";
import Z from "zod";
import fs from "fs";
import Ini from "ini";
function getSettings(explicitApiKey) {
  const env = _loadEnv();
  const systemFile = _loadSystemFile();
  const defaults2 = _loadDefaults();
  _legacyEnvVarWarning();
  _envVarsInfo();
  return {
    auth: {
      apiKey: explicitApiKey || env.LINGODOTDEV_API_KEY || systemFile.auth?.apiKey || defaults2.auth.apiKey,
      apiUrl: env.LINGODOTDEV_API_URL || systemFile.auth?.apiUrl || defaults2.auth.apiUrl,
      webUrl: env.LINGODOTDEV_WEB_URL || systemFile.auth?.webUrl || defaults2.auth.webUrl
    },
    llm: {
      openaiApiKey: env.OPENAI_API_KEY || systemFile.llm?.openaiApiKey,
      anthropicApiKey: env.ANTHROPIC_API_KEY || systemFile.llm?.anthropicApiKey,
      groqApiKey: env.GROQ_API_KEY || systemFile.llm?.groqApiKey,
      googleApiKey: env.GOOGLE_API_KEY || systemFile.llm?.googleApiKey,
      openrouterApiKey: env.OPENROUTER_API_KEY || systemFile.llm?.openrouterApiKey,
      mistralApiKey: env.MISTRAL_API_KEY || systemFile.llm?.mistralApiKey
    }
  };
}
function saveSettings(settings) {
  _saveSystemFile(settings);
}
function loadSystemSettings() {
  return _loadSystemFile();
}
var flattenZodObject = (schema, prefix = "") => {
  return Object.entries(schema.shape).flatMap(([key, value]) => {
    const newPrefix = prefix ? `${prefix}.${key}` : key;
    if (value instanceof Z.ZodObject) {
      return flattenZodObject(value, newPrefix);
    }
    return [newPrefix];
  });
};
var SettingsSchema = Z.object({
  auth: Z.object({
    apiKey: Z.string(),
    apiUrl: Z.string(),
    webUrl: Z.string()
  }),
  llm: Z.object({
    openaiApiKey: Z.string().optional(),
    anthropicApiKey: Z.string().optional(),
    groqApiKey: Z.string().optional(),
    googleApiKey: Z.string().optional(),
    openrouterApiKey: Z.string().optional(),
    mistralApiKey: Z.string().optional()
  })
});
var SETTINGS_KEYS = flattenZodObject(
  SettingsSchema
);
function _loadDefaults() {
  return {
    auth: {
      apiKey: "",
      apiUrl: "https://engine.lingo.dev",
      webUrl: "https://lingo.dev"
    },
    llm: {}
  };
}
function _loadEnv() {
  return Z.object({
    LINGODOTDEV_API_KEY: Z.string().optional(),
    LINGODOTDEV_API_URL: Z.string().optional(),
    LINGODOTDEV_WEB_URL: Z.string().optional(),
    OPENAI_API_KEY: Z.string().optional(),
    ANTHROPIC_API_KEY: Z.string().optional(),
    GROQ_API_KEY: Z.string().optional(),
    GOOGLE_API_KEY: Z.string().optional(),
    OPENROUTER_API_KEY: Z.string().optional(),
    MISTRAL_API_KEY: Z.string().optional()
  }).passthrough().parse(process.env);
}
function _loadSystemFile() {
  const settingsFilePath = _getSettingsFilePath();
  const content = fs.existsSync(settingsFilePath) ? fs.readFileSync(settingsFilePath, "utf-8") : "";
  const data = Ini.parse(content);
  return Z.object({
    auth: Z.object({
      apiKey: Z.string().optional(),
      apiUrl: Z.string().optional(),
      webUrl: Z.string().optional()
    }).optional(),
    llm: Z.object({
      openaiApiKey: Z.string().optional(),
      anthropicApiKey: Z.string().optional(),
      groqApiKey: Z.string().optional(),
      googleApiKey: Z.string().optional(),
      openrouterApiKey: Z.string().optional(),
      mistralApiKey: Z.string().optional()
    }).optional()
  }).passthrough().parse(data);
}
function _saveSystemFile(settings) {
  const settingsFilePath = _getSettingsFilePath();
  const content = Ini.stringify(settings);
  fs.writeFileSync(settingsFilePath, content);
}
function _getSettingsFilePath() {
  const settingsFile = ".lingodotdevrc";
  const homedir = os.homedir();
  const settingsFilePath = path.join(homedir, settingsFile);
  return settingsFilePath;
}
function _legacyEnvVarWarning() {
  const env = _loadEnv();
  if (env.REPLEXICA_API_KEY && !env.LINGODOTDEV_API_KEY) {
    console.warn(
      "\x1B[33m%s\x1B[0m",
      `
\u26A0\uFE0F  WARNING: REPLEXICA_API_KEY env var is deprecated \u26A0\uFE0F
===========================================================

Please use LINGODOTDEV_API_KEY instead.
===========================================================
`
    );
  }
}
function _envVarsInfo() {
  const env = _loadEnv();
  const systemFile = _loadSystemFile();
  if (env.LINGODOTDEV_API_KEY && systemFile.auth?.apiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using LINGODOTDEV_API_KEY env var instead of credentials from user config`
    );
  }
  if (env.OPENAI_API_KEY && systemFile.llm?.openaiApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using OPENAI_API_KEY env var instead of key from user config.`
    );
  }
  if (env.ANTHROPIC_API_KEY && systemFile.llm?.anthropicApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using ANTHROPIC_API_KEY env var instead of key from user config`
    );
  }
  if (env.GROQ_API_KEY && systemFile.llm?.groqApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using GROQ_API_KEY env var instead of key from user config`
    );
  }
  if (env.GOOGLE_API_KEY && systemFile.llm?.googleApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using GOOGLE_API_KEY env var instead of key from user config`
    );
  }
  if (env.OPENROUTER_API_KEY && systemFile.llm?.openrouterApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using OPENROUTER_API_KEY env var instead of key from user config`
    );
  }
  if (env.MISTRAL_API_KEY && systemFile.llm?.mistralApiKey) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using MISTRAL_API_KEY env var instead of key from user config`
    );
  }
  if (env.LINGODOTDEV_API_URL) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using LINGODOTDEV_API_URL: ${env.LINGODOTDEV_API_URL}`
    );
  }
  if (env.LINGODOTDEV_WEB_URL) {
    console.info(
      "\x1B[36m%s\x1B[0m",
      `\u2139\uFE0F  Using LINGODOTDEV_WEB_URL: ${env.LINGODOTDEV_WEB_URL}`
    );
  }
}

// src/cli/utils/errors.ts
var docLinks = {
  i18nNotFound: "https://lingo.dev/cli",
  bucketNotFound: "https://lingo.dev/cli",
  authError: "https://lingo.dev/cli",
  localeTargetNotFound: "https://lingo.dev/cli",
  lockFiletNotFound: "https://lingo.dev/cli",
  failedReplexicaEngine: "https://lingo.dev/cli",
  placeHolderFailed: "https://lingo.dev/cli",
  translationFailed: "https://lingo.dev/cli",
  connectionFailed: "https://lingo.dev/cli",
  invalidType: "https://lingo.dev/cli",
  invalidPathPattern: "https://lingo.dev/cli",
  androidResouceError: "https://lingo.dev/cli",
  invalidBucketType: "https://lingo.dev/cli",
  invalidStringDict: "https://lingo.dev/cli"
};
var CLIError = class extends Error {
  docUrl;
  errorType = "cli_error";
  constructor({ message, docUrl }) {
    super(message);
    this.docUrl = docLinks[docUrl];
    this.message = `${this.message}
 visit: ${this.docUrl}`;
  }
};
var ConfigError = class extends CLIError {
  errorType = "config_error";
  constructor({ message, docUrl }) {
    super({ message, docUrl });
    this.name = "ConfigError";
  }
};
var AuthenticationError = class extends CLIError {
  errorType = "auth_error";
  constructor({ message, docUrl }) {
    super({ message, docUrl });
    this.name = "AuthenticationError";
  }
};
var ValidationError = class extends CLIError {
  errorType = "validation_error";
  constructor({ message, docUrl }) {
    super({ message, docUrl });
    this.name = "ValidationError";
  }
};
var LocalizationError = class extends Error {
  errorType = "locale_error";
  bucket;
  sourceLocale;
  targetLocale;
  pathPattern;
  constructor(message, context) {
    super(message);
    this.name = "LocalizationError";
    this.bucket = context?.bucket;
    this.sourceLocale = context?.sourceLocale;
    this.targetLocale = context?.targetLocale;
    this.pathPattern = context?.pathPattern;
  }
};
var BucketProcessingError = class extends Error {
  errorType = "bucket_error";
  bucket;
  constructor(message, bucket) {
    super(message);
    this.name = "BucketProcessingError";
    this.bucket = bucket;
  }
};
function isConfigError(error) {
  return error instanceof ConfigError || error.errorType === "config_error";
}
function isAuthenticationError(error) {
  return error instanceof AuthenticationError || error.errorType === "auth_error";
}
function isValidationError(error) {
  return error instanceof ValidationError || error.errorType === "validation_error";
}
function isLocalizationError(error) {
  return error instanceof LocalizationError || error.errorType === "locale_error";
}
function isBucketProcessingError(error) {
  return error instanceof BucketProcessingError || error.errorType === "bucket_error";
}
function getCLIErrorType(error) {
  if (isConfigError(error)) return "config_error";
  if (isAuthenticationError(error)) return "auth_error";
  if (isValidationError(error)) return "validation_error";
  if (isLocalizationError(error)) return "locale_error";
  if (isBucketProcessingError(error)) return "bucket_error";
  if (error instanceof CLIError) return "cli_error";
  return "unknown_error";
}
function createPreviousErrorContext(errorDetails) {
  if (errorDetails.length === 0) return void 0;
  return {
    count: errorDetails.length,
    types: [...new Set(errorDetails.map((e) => e.type))],
    buckets: [...new Set(errorDetails.map((e) => e.bucket).filter(Boolean))]
  };
}
function aggregateErrorAnalytics(errorDetails, buckets, targetLocales, i18nConfig) {
  if (errorDetails.length === 0) {
    return {
      errorCount: 0,
      errorTypes: [],
      errorsByBucket: {},
      errorsByType: {},
      firstError: void 0,
      bucketCount: buckets.length,
      localeCount: targetLocales.length,
      i18nConfig: {
        sourceLocale: i18nConfig.locale.source,
        targetLocales: i18nConfig.locale.targets,
        bucketTypes: Object.keys(i18nConfig.buckets)
      }
    };
  }
  const errorsByBucket = errorDetails.reduce(
    (acc, error) => {
      if (error.bucket) {
        acc[error.bucket] = (acc[error.bucket] || 0) + 1;
      }
      return acc;
    },
    {}
  );
  const errorsByType = errorDetails.reduce(
    (acc, error) => {
      acc[error.type] = (acc[error.type] || 0) + 1;
      return acc;
    },
    {}
  );
  return {
    errorCount: errorDetails.length,
    errorTypes: [...new Set(errorDetails.map((e) => e.type))],
    errorsByBucket,
    errorsByType,
    firstError: {
      type: errorDetails[0].type,
      bucket: errorDetails[0].bucket,
      locale: errorDetails[0].locale,
      pathPattern: errorDetails[0].pathPattern,
      message: errorDetails[0].message
    },
    bucketCount: buckets.length,
    localeCount: targetLocales.length,
    i18nConfig: {
      sourceLocale: i18nConfig.locale.source,
      targetLocales: i18nConfig.locale.targets,
      bucketTypes: Object.keys(i18nConfig.buckets)
    }
  };
}

// src/cli/utils/cloudflare-status.ts
async function checkCloudflareStatus() {
  try {
    const response = await fetch(
      "https://www.cloudflarestatus.com/api/v2/status.json",
      {
        signal: AbortSignal.timeout(5e3)
      }
    );
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
  }
  return null;
}
function formatCloudflareStatusMessage(status) {
  if (status.status.indicator === "none") {
    return "";
  }
  return `Cloudflare is experiencing ${status.status.indicator} issues: ${status.status.description}. This may be affecting the API connection.`;
}

// src/cli/utils/auth.ts
function createAuthenticator(params) {
  return {
    async whoami() {
      try {
        const res = await fetch(`${params.apiUrl}/whoami`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${params.apiKey}`,
            ContentType: "application/json"
          }
        });
        if (res.ok) {
          const payload = await res.json();
          if (!payload?.email) {
            return null;
          }
          return {
            email: payload.email,
            id: payload.id
          };
        }
        if (res.status >= 500 && res.status < 600) {
          const originalErrorMessage = `Server error (${res.status}): ${res.statusText}. Please try again later.`;
          const cloudflareStatus = await checkCloudflareStatus();
          if (!cloudflareStatus) {
            throw new CLIError({
              message: originalErrorMessage,
              docUrl: "connectionFailed"
            });
          }
          if (cloudflareStatus.status.indicator !== "none") {
            const cloudflareMessage = formatCloudflareStatusMessage(cloudflareStatus);
            throw new CLIError({
              message: cloudflareMessage,
              docUrl: "connectionFailed"
            });
          }
          throw new CLIError({
            message: originalErrorMessage,
            docUrl: "connectionFailed"
          });
        }
        return null;
      } catch (error) {
        if (error instanceof CLIError) {
          throw error;
        }
        const isNetworkError = error instanceof TypeError && error.message === "fetch failed";
        if (isNetworkError) {
          throw new CLIError({
            message: `Failed to connect to the API at ${params.apiUrl}. Please check your connection and try again.`,
            docUrl: "connectionFailed"
          });
        } else {
          throw error;
        }
      }
    }
  };
}

// src/cli/cmd/auth.ts
var auth_default = new Command().command("auth").description("Show current authentication status and user email").helpOption("-h, --help", "Show help").option(
  "--login",
  "DEPRECATED: Shows deprecation warning and exits. Use `lingo.dev login` instead"
).option(
  "--logout",
  "DEPRECATED: Shows deprecation warning and exits. Use `lingo.dev logout` instead"
).action(async (options) => {
  try {
    if (options.login) {
      Ora().warn(
        "\u26A0\uFE0F  DEPRECATED: '--login' is deprecated. Please use 'lingo.dev login' instead."
      );
      process.exit(1);
    }
    if (options.logout) {
      Ora().warn(
        "\u26A0\uFE0F  DEPRECATED: '--logout' is deprecated. Please use 'lingo.dev logout' instead."
      );
      process.exit(1);
    }
    const settings = await getSettings(void 0);
    const authenticator = createAuthenticator({
      apiUrl: settings.auth.apiUrl,
      apiKey: settings.auth.apiKey
    });
    const auth = await authenticator.whoami();
    if (!auth) {
      Ora().warn("Not authenticated");
    } else {
      Ora().succeed(`Authenticated as ${auth.email}`);
    }
  } catch (error) {
    Ora().fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/login.ts
import { Command as Command2 } from "interactive-commander";
import Ora2 from "ora";
import express from "express";
import cors from "cors";
import open from "open";
import readline2 from "readline/promises";

// src/cli/utils/ui.ts
import chalk from "chalk";
import figlet from "figlet";
import { vice } from "gradient-string";
import readline from "readline";

// src/cli/constants.ts
var colors = {
  orange: "#ff6600",
  green: "#6ae300",
  blue: "#0090ff",
  yellow: "#ffcc00",
  grey: "#808080",
  red: "#ff0000",
  white: "#ffffff"
};

// src/cli/utils/ui.ts
async function renderClear() {
  console.log("\x1Bc");
}
async function renderSpacer() {
  console.log(" ");
}
async function renderBanner() {
  console.log(
    vice(
      figlet.textSync("LINGO.DEV", {
        font: "ANSI Shadow",
        horizontalLayout: "default",
        verticalLayout: "default"
      })
    )
  );
}
async function renderHero() {
  console.log(
    `\u26A1\uFE0F ${chalk.hex(colors.green)(
      "Lingo.dev"
    )} - open-source, AI-powered i18n CLI for web & mobile localization.`
  );
  console.log("");
  const label1 = "\u{1F4DA} Docs:";
  const label2 = "\u2B50 Star the repo:";
  const label3 = "\u{1F3AE} Join Discord:";
  const maxLabelWidth = 17;
  console.log(
    `${chalk.hex(colors.blue)(label1.padEnd(maxLabelWidth + 1))} ${chalk.hex(
      colors.blue
    )("https://lingo.dev/go/docs")}`
  );
  console.log(
    `${chalk.hex(colors.blue)(label2.padEnd(maxLabelWidth))} ${chalk.hex(
      colors.blue
    )("https://lingo.dev/go/gh")}`
  );
  console.log(
    `${chalk.hex(colors.blue)(label3.padEnd(maxLabelWidth + 1))} ${chalk.hex(
      colors.blue
    )("https://lingo.dev/go/discord")}`
  );
}
async function waitForUserPrompt(message) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve) => {
    rl.question(chalk.dim(`[${message}]
`), () => {
      rl.close();
      resolve();
    });
  });
}
async function pauseIfDebug(debug) {
  if (debug) {
    await waitForUserPrompt("Press Enter to continue...");
  }
}
async function renderSummary(results) {
  console.log(chalk.hex(colors.green)("[Done]"));
  const skippedResults = Array.from(results.values()).filter(
    (r) => r.status === "skipped"
  );
  const succeededResults = Array.from(results.values()).filter(
    (r) => r.status === "success"
  );
  const failedResults = Array.from(results.values()).filter(
    (r) => r.status === "error"
  );
  console.log(
    `\u2022 ${chalk.hex(colors.yellow)(skippedResults.length)} from cache`
  );
  console.log(
    `\u2022 ${chalk.hex(colors.yellow)(succeededResults.length)} processed`
  );
  console.log(`\u2022 ${chalk.hex(colors.yellow)(failedResults.length)} failed`);
  if (succeededResults.length > 0) {
    console.log(chalk.hex(colors.green)("\n[Processed Files]"));
    for (const result of succeededResults) {
      const displayPath = result.pathPattern?.replace("[locale]", result.targetLocale) || "unknown";
      console.log(
        `  \u2713 ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} \u2192 ${result.targetLocale})`)}`
      );
    }
  }
  if (skippedResults.length > 0) {
    console.log(chalk.hex(colors.blue)("\n[Cached Files]"));
    for (const result of skippedResults) {
      const displayPath = result.pathPattern?.replace("[locale]", result.targetLocale) || "unknown";
      console.log(
        `  \u26A1 ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} \u2192 ${result.targetLocale})`)}`
      );
    }
  }
  if (failedResults.length > 0) {
    console.log(chalk.hex(colors.orange)("\n[Failed Files]"));
    for (const result of failedResults) {
      const displayPath = result.pathPattern?.replace("[locale]", result.targetLocale) || "unknown";
      console.log(
        `  \u274C ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} \u2192 ${result.targetLocale})`)}`
      );
      console.log(
        `     ${chalk.hex(colors.white)(String(result.error?.message || "Unknown error"))}`
      );
    }
  }
}

// src/cli/cmd/login.ts
var login_default = new Command2().command("login").description(
  "Open browser to authenticate with lingo.dev and save your API key"
).helpOption("-h, --help", "Show help").action(async () => {
  try {
    await renderClear();
    await renderSpacer();
    await renderBanner();
    await renderHero();
    await renderSpacer();
    const settings = await getSettings(void 0);
    const apiKey = await login(settings.auth.webUrl);
    settings.auth.apiKey = apiKey;
    await saveSettings(settings);
    Ora2().succeed("Successfully logged in");
  } catch (error) {
    Ora2().fail(error.message);
    process.exit(1);
  }
});
async function login(webAppUrl) {
  await readline2.createInterface({
    input: process.stdin,
    output: process.stdout
  }).question(
    `
Press Enter to open the browser for authentication.

---

Having issues? Put LINGODOTDEV_API_KEY in your .env file instead.
    `.trim() + "\n"
  );
  const spinner = Ora2().start("Waiting for the API key");
  const apiKey = await waitForApiKey(async (port) => {
    await open(`${webAppUrl}/app/cli?port=${port}`, { wait: false });
  });
  spinner.succeed("API key received");
  return apiKey;
}
async function waitForApiKey(cb) {
  const app = express();
  app.use(express.json());
  app.use(cors());
  return new Promise((resolve) => {
    const server = app.listen(0, async () => {
      const port = server.address().port;
      cb(port.toString());
    });
    app.post("/", (req, res) => {
      const apiKey = req.body.apiKey;
      res.end();
      server.close(() => {
        resolve(apiKey);
      });
    });
  });
}

// src/cli/cmd/logout.ts
import { Command as Command3 } from "interactive-commander";
import Ora3 from "ora";
var logout_default = new Command3().command("logout").description("Log out by removing saved authentication credentials").helpOption("-h, --help", "Show help").action(async () => {
  try {
    await renderClear();
    await renderSpacer();
    await renderBanner();
    await renderHero();
    await renderSpacer();
    const settings = await getSettings(void 0);
    settings.auth.apiKey = "";
    await saveSettings(settings);
    Ora3().succeed("Successfully logged out");
  } catch (error) {
    Ora3().fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/init.ts
import { InteractiveCommand, InteractiveOption } from "interactive-commander";
import Ora4 from "ora";

// src/cli/utils/config.ts
import _ from "lodash";
import fs2 from "fs";
import path2 from "path";
import { parseI18nConfig } from "@lingo.dev/_spec";
function getConfig(resave = true) {
  const configFilePath = _getConfigFilePath();
  const configFileExists = fs2.existsSync(configFilePath);
  if (!configFileExists) {
    return null;
  }
  const fileContents = fs2.readFileSync(configFilePath, "utf8");
  const rawConfig = JSON.parse(fileContents);
  const result = parseI18nConfig(rawConfig);
  const didConfigChange = !_.isEqual(rawConfig, result);
  if (resave && didConfigChange) {
    saveConfig(result);
  }
  return result;
}
function saveConfig(config) {
  const configFilePath = _getConfigFilePath();
  const serialized = JSON.stringify(config, null, 2);
  fs2.writeFileSync(configFilePath, serialized);
  return config;
}
function _getConfigFilePath() {
  return path2.join(process.cwd(), "i18n.json");
}

// src/cli/cmd/init.ts
import {
  defaultConfig,
  resolveLocaleCode as resolveLocaleCode2,
  bucketTypes
} from "@lingo.dev/_spec";
import fs6 from "fs";
import path7 from "path";
import _3 from "lodash";
import { checkbox as checkbox2, confirm as confirm2, input } from "@inquirer/prompts";

// src/cli/utils/find-locale-paths.ts
import path3 from "path";
import { glob } from "glob";
import _2 from "lodash";
import { resolveLocaleCode } from "@lingo.dev/_spec";
function findLocaleFiles(bucket) {
  switch (bucket) {
    case "json":
      return findLocaleFilesWithExtension(".json");
    case "yaml":
      return findLocaleFilesWithExtension(".yml");
    case "flutter":
      return findLocaleFilesWithExtension(".arb");
    case "android":
      return findLocaleFilesWithExtension(".xml");
    case "markdown":
      return findLocaleFilesWithExtension(".md");
    case "php":
      return findLocaleFilesWithExtension(".php");
    case "po":
      return findLocaleFilesWithExtension(".po");
    case "xcode-xcstrings":
      return findLocaleFilesForFilename("Localizable.xcstrings");
    case "xcode-strings":
      return findLocaleFilesForFilename("Localizable.strings");
    case "xcode-stringsdict":
      return findLocaleFilesForFilename("Localizable.stringsdict");
    default:
      return null;
  }
}
function findLocaleFilesWithExtension(ext2) {
  const files = glob.sync(`**/*${ext2}`, {
    ignore: ["node_modules/**", "package*.json", "i18n.json", "lingo.json"]
  });
  const localeFilePattern = new RegExp(`/([a-z]{2}(-[A-Z]{2})?)${ext2}$`);
  const localeDirectoryPattern = new RegExp(
    `/([a-z]{2}(-[A-Z]{2})?)/[^/]+${ext2}$`
  );
  const potentialLocaleFiles = files.filter(
    (file) => localeFilePattern.test(file) || localeDirectoryPattern.test(file)
  );
  const potantialLocaleFilesAndPatterns = potentialLocaleFiles.map((file) => {
    const matchPotentialLocales = Array.from(
      file.matchAll(
        new RegExp(`/([a-z]{2}(-[A-Z]{2})?|[^/]+)(?=/|${ext2})`, "g")
      )
    );
    const potantialLocales = matchPotentialLocales.map((match2) => match2[1]);
    return { file, potantialLocales };
  }).map(({ file, potantialLocales }) => {
    for (const locale of potantialLocales) {
      try {
        resolveLocaleCode(locale);
        return { locale, file };
      } catch (e) {
      }
    }
    return { file, locale: null };
  }).filter(({ locale }) => locale !== null);
  const localeFilesAndPatterns = potantialLocaleFilesAndPatterns.map(
    ({ file, locale }) => {
      const pattern = file.replaceAll(new RegExp(`/${locale}${ext2}`, "g"), `/[locale]${ext2}`).replaceAll(new RegExp(`/${locale}/`, "g"), `/[locale]/`).replaceAll(new RegExp(`/${locale}/`, "g"), `/[locale]/`);
      return { pattern, file };
    }
  );
  const grouppedFilesAndPatterns = _2.groupBy(localeFilesAndPatterns, "pattern");
  const patterns = Object.keys(grouppedFilesAndPatterns);
  const defaultPatterns = [`i18n/[locale]${ext2}`];
  if (patterns.length > 0) {
    return { patterns, defaultPatterns };
  }
  return { patterns: [], defaultPatterns };
}
function findLocaleFilesForFilename(fileName) {
  const pattern = fileName;
  const localeFiles = glob.sync(`**/${fileName}`, {
    ignore: ["node_modules/**", "package*.json", "i18n.json", "lingo.json"]
  });
  const localeFilesAndPatterns = localeFiles.map((file) => ({
    file,
    pattern: path3.join(path3.dirname(file), pattern)
  }));
  const grouppedFilesAndPatterns = _2.groupBy(localeFilesAndPatterns, "pattern");
  const patterns = Object.keys(grouppedFilesAndPatterns);
  const defaultPatterns = [fileName];
  if (patterns.length > 0) {
    return { patterns, defaultPatterns };
  }
  return { patterns: [], defaultPatterns };
}

// src/cli/utils/ensure-patterns.ts
import fs3 from "fs";
import path4 from "path";
function ensurePatterns(patterns, source) {
  if (patterns.length === 0) {
    throw new Error("No patterns found");
  }
  patterns.forEach((pattern) => {
    const filePath = pattern.replace("[locale]", source);
    if (!fs3.existsSync(filePath)) {
      const defaultContent = getDefaultContent(path4.extname(filePath), source);
      fs3.mkdirSync(path4.dirname(filePath), { recursive: true });
      fs3.writeFileSync(filePath, defaultContent);
    }
  });
}
function getDefaultContent(ext2, source) {
  const defaultGreeting = "Hello from Lingo.dev";
  switch (ext2) {
    case ".json":
    case ".arb":
      return `{
	"greeting": "${defaultGreeting}"
}`;
    case ".yml":
      return `${source}:
	greeting: "${defaultGreeting}"`;
    case ".xml":
      return `<resources>
	<string name="greeting">${defaultGreeting}</string>
</resources>`;
    case ".md":
      return `# ${defaultGreeting}`;
    case ".xcstrings":
      return `{
  "sourceLanguage" : "${source}",
  "strings" : {
    "${defaultGreeting}" : {
      "extractionState" : "manual",
      "localizations" : {
        "${source}" : {
          "stringUnit" : {
            "state" : "translated",
            "value" : "${defaultGreeting}"
          }
        }
      }
    }
  }
}`;
    case ".strings":
      return `"greeting" = "${defaultGreeting}";`;
    case ".stringsdict":
      return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>key</key>
  <dict>
    <key>NSStringLocalizedFormatKey</key>
    <string>%#@count@</string>
    <key>count</key>
    <dict>
      <key>NSStringFormatSpecTypeKey</key>
      <string>NSStringPluralRuleType</string>
      <key>NSStringFormatValueTypeKey</key>
      <string>d</string>
      <key>zero</key>
      <string>No items</string>
      <key>one</key>
      <string>One item</string>
      <key>other</key>
      <string>%d items</string>
    </dict>
  </dict>
</dict>
</plist>`;
    default:
      throw new Error(`Unsupported file extension: ${ext2}`);
  }
}

// src/cli/utils/update-gitignore.ts
import fs4 from "fs";
import path5 from "path";
function updateGitignore() {
  const cacheFile = "i18n.cache";
  const projectRoot = findCurrentProjectRoot();
  if (!projectRoot) {
    return;
  }
  const gitignorePath = path5.join(projectRoot, ".gitignore");
  if (!fs4.existsSync(gitignorePath)) {
    return;
  }
  const gitignore = fs4.readFileSync(gitignorePath, "utf8").split("\n");
  const cacheIsIgnored = gitignore.includes(cacheFile);
  if (!cacheIsIgnored) {
    let content = "";
    content = fs4.readFileSync(gitignorePath, "utf8");
    if (content !== "" && !content.endsWith("\n")) {
      content += "\n";
    }
    content += `${cacheFile}
`;
    fs4.writeFileSync(gitignorePath, content);
  }
}
function findCurrentProjectRoot() {
  let currentDir = process.cwd();
  while (currentDir !== path5.parse(currentDir).root) {
    const gitDirPath = path5.join(currentDir, ".git");
    if (fs4.existsSync(gitDirPath) && fs4.lstatSync(gitDirPath).isDirectory()) {
      return currentDir;
    }
    currentDir = path5.dirname(currentDir);
  }
  return null;
}

// src/cli/utils/init-ci-cd.ts
import { checkbox, confirm } from "@inquirer/prompts";
import fs5 from "fs";
import path6 from "path";
var platforms = ["github", "bitbucket", "gitlab"];
async function initCICD(spinner) {
  const initializers = getPlatformInitializers(spinner);
  const init = await confirm({
    message: "Would you like to use Lingo.dev in your CI/CD?"
  });
  if (!init) {
    spinner.warn(
      "CI/CD not initialized. To set it up later, see docs: https://lingo.dev/ci"
    );
    return;
  }
  const selectedPlatforms = await checkbox({
    message: "Please select CI/CD platform(s) you want to use:",
    choices: platforms.map((platform) => ({
      name: initializers[platform].name,
      value: platform,
      checked: initializers[platform].isEnabled()
    }))
  });
  for (const platform of selectedPlatforms) {
    await initializers[platform].init();
  }
}
function getPlatformInitializers(spinner) {
  return {
    github: makeGithubInitializer(spinner),
    bitbucket: makeBitbucketInitializer(spinner),
    gitlab: makeGitlabInitializer(spinner)
  };
}
function makePlatformInitializer(config, spinner) {
  return {
    name: config.name,
    isEnabled: () => {
      const filePath = path6.join(process.cwd(), config.checkPath);
      return fs5.existsSync(filePath);
    },
    init: async () => {
      const filePath = path6.join(process.cwd(), config.ciConfigPath);
      const dirPath = path6.dirname(filePath);
      if (!fs5.existsSync(dirPath)) {
        fs5.mkdirSync(dirPath, { recursive: true });
      }
      let canWrite = true;
      if (fs5.existsSync(filePath)) {
        canWrite = await confirm({
          message: `File ${filePath} already exists. Do you want to overwrite it?`,
          default: false
        });
      }
      if (canWrite) {
        fs5.writeFileSync(filePath, config.ciConfigContent);
        spinner.succeed(`CI/CD initialized for ${config.name}`);
      } else {
        spinner.warn(`CI/CD not initialized for ${config.name}`);
      }
    }
  };
}
function makeGithubInitializer(spinner) {
  return makePlatformInitializer(
    {
      name: "GitHub Action",
      checkPath: ".github",
      ciConfigPath: ".github/workflows/i18n.yml",
      ciConfigContent: `name: Lingo.dev i18n

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  i18n:
    name: Run i18n
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: lingodotdev/lingo.dev@main
        with:
          api-key: \${{ secrets.LINGODOTDEV_API_KEY }}
`
    },
    spinner
  );
}
function makeBitbucketInitializer(spinner) {
  return makePlatformInitializer(
    {
      name: "Bitbucket Pipeline",
      checkPath: "bitbucket-pipelines.yml",
      ciConfigPath: "bitbucket-pipelines.yml",
      ciConfigContent: `pipelines:
  branches:
    main:
      - step:
          name: Run i18n
          script:
            - pipe: lingodotdev/lingo.dev:main`
    },
    spinner
  );
}
function makeGitlabInitializer(spinner) {
  return makePlatformInitializer(
    {
      name: "Gitlab CI",
      checkPath: ".gitlab-ci.yml",
      ciConfigPath: ".gitlab-ci.yml",
      ciConfigContent: `lingodotdev:
  image: lingodotdev/ci-action:latest
  script:
    - echo "Done"
`
    },
    spinner
  );
}

// src/cli/cmd/init.ts
import open2 from "open";
var openUrl = (path19) => {
  const settings = getSettings(void 0);
  open2(`${settings.auth.webUrl}${path19}`, { wait: false });
};
var throwHelpError = (option, value) => {
  if (value === "help") {
    openUrl("/go/call");
  }
  throw new Error(
    `Invalid ${option}: ${value}

Do you need support for ${value} ${option}? Type "help" and we will.`
  );
};
var init_default = new InteractiveCommand().command("init").description("Create i18n.json configuration file for a new project").helpOption("-h, --help", "Show help").addOption(
  new InteractiveOption(
    "-f --force",
    "Overwrite existing Lingo.dev configuration instead of aborting initialization (destructive operation)"
  ).prompt(void 0).default(false)
).addOption(
  new InteractiveOption(
    "-s --source <locale>",
    "Primary language of your application that content will be translated from. Defaults to 'en'"
  ).argParser((value) => {
    try {
      resolveLocaleCode2(value);
    } catch (e) {
      throwHelpError("locale", value);
    }
    return value;
  }).default("en")
).addOption(
  new InteractiveOption(
    "-t --targets <locale...>",
    "Target languages to translate to. Accepts locale codes like 'es', 'fr', 'de-AT' separated by commas or spaces. Defaults to 'es'"
  ).argParser((value) => {
    const values = value.includes(",") ? value.split(",") : value.split(" ");
    values.forEach((value2) => {
      try {
        resolveLocaleCode2(value2);
      } catch (e) {
        throwHelpError("locale", value2);
      }
    });
    return values;
  }).default("es")
).addOption(
  new InteractiveOption(
    "-b, --bucket <type>",
    "File format for your translation files. Must match a supported type such as json, yaml, or android"
  ).argParser((value) => {
    if (!bucketTypes.includes(value)) {
      throwHelpError("bucket format", value);
    }
    return value;
  }).default("json")
).addOption(
  new InteractiveOption(
    "-p, --paths [path...]",
    "File paths containing translations when using --no-interactive mode. Specify paths with [locale] placeholder, separated by commas or spaces"
  ).argParser((value) => {
    if (!value || value.length === 0) return [];
    const values = value.includes(",") ? value.split(",") : value.split(" ");
    for (const p of values) {
      try {
        const dirPath = path7.dirname(p);
        const stats = fs6.statSync(dirPath);
        if (!stats.isDirectory()) {
          throw new Error(`${dirPath} is not a directory`);
        }
      } catch (err) {
        throw new Error(`Invalid path: ${p}`);
      }
    }
    return values;
  }).prompt(void 0).default([])
).action(async (options) => {
  const settings = getSettings(void 0);
  const isInteractive = options.interactive;
  const spinner = Ora4().start("Initializing Lingo.dev project");
  let existingConfig = await getConfig(false);
  if (existingConfig && !options.force) {
    spinner.fail("Lingo.dev project already initialized");
    return process.exit(1);
  }
  const newConfig = _3.cloneDeep(defaultConfig);
  newConfig.locale.source = options.source;
  newConfig.locale.targets = options.targets;
  if (!isInteractive) {
    newConfig.buckets = {
      [options.bucket]: {
        include: options.paths || []
      }
    };
  } else {
    let selectedPatterns = [];
    const localeFiles = findLocaleFiles(options.bucket);
    if (!localeFiles) {
      spinner.warn(
        `Bucket type "${options.bucket}" does not supported automatic initialization. Add paths to "i18n.json" manually.`
      );
      newConfig.buckets = {
        [options.bucket]: {
          include: options.paths || []
        }
      };
    } else {
      const { patterns, defaultPatterns } = localeFiles;
      if (patterns.length > 0) {
        spinner.succeed("Found existing locale files:");
        selectedPatterns = await checkbox2({
          message: "Select the paths to use",
          choices: patterns.map((value) => ({
            value
          }))
        });
      } else {
        spinner.succeed("No existing locale files found.");
      }
      if (selectedPatterns.length === 0) {
        const useDefault = await confirm2({
          message: `Use (and create) default path ${defaultPatterns.join(
            ", "
          )}?`
        });
        if (useDefault) {
          ensurePatterns(defaultPatterns, options.source);
          selectedPatterns = defaultPatterns;
        }
      }
      if (selectedPatterns.length === 0) {
        const customPaths = await input({
          message: "Enter paths to use"
        });
        selectedPatterns = customPaths.includes(",") ? customPaths.split(",") : customPaths.split(" ");
      }
      newConfig.buckets = {
        [options.bucket]: {
          include: selectedPatterns || []
        }
      };
    }
  }
  await saveConfig(newConfig);
  spinner.succeed("Lingo.dev project initialized");
  if (isInteractive) {
    await initCICD(spinner);
    const openDocs = await confirm2({
      message: "Would you like to see our docs?"
    });
    if (openDocs) {
      openUrl("/go/docs");
    }
  }
  const authenticator = createAuthenticator({
    apiKey: settings.auth.apiKey,
    apiUrl: settings.auth.apiUrl
  });
  const auth = await authenticator.whoami();
  if (!auth) {
    if (isInteractive) {
      const doAuth = await confirm2({
        message: "It looks like you are not logged into the CLI. Login now?"
      });
      if (doAuth) {
        const apiKey = await login(settings.auth.webUrl);
        settings.auth.apiKey = apiKey;
        await saveSettings(settings);
        const newAuthenticator = createAuthenticator({
          apiKey: settings.auth.apiKey,
          apiUrl: settings.auth.apiUrl
        });
        const auth2 = await newAuthenticator.whoami();
        if (auth2) {
          Ora4().succeed(`Authenticated as ${auth2?.email}`);
        } else {
          Ora4().fail("Authentication failed.");
        }
      }
    } else {
      Ora4().warn(
        "You are not logged in. Run `npx lingo.dev@latest login` to login."
      );
    }
  } else {
    Ora4().succeed(`Authenticated as ${auth.email}`);
  }
  updateGitignore();
  if (!isInteractive) {
    Ora4().info("Please see https://lingo.dev/cli");
  }
});

// src/cli/cmd/show/index.ts
import { Command as Command9 } from "interactive-commander";

// src/cli/cmd/show/config.ts
import { Command as Command4 } from "interactive-commander";
import _4 from "lodash";
import fs7 from "fs";
import path8 from "path";
import { defaultConfig as defaultConfig2 } from "@lingo.dev/_spec";
var config_default = new Command4().command("config").description("Print effective i18n.json after merging with defaults").helpOption("-h, --help", "Show help").action(async (options) => {
  const fileConfig = loadReplexicaFileConfig();
  const config = _4.merge({}, defaultConfig2, fileConfig);
  console.log(JSON.stringify(config, null, 2));
});
function loadReplexicaFileConfig() {
  const replexicaConfigPath = path8.resolve(process.cwd(), "i18n.json");
  const fileExists = fs7.existsSync(replexicaConfigPath);
  if (!fileExists) {
    return void 0;
  }
  const fileContent = fs7.readFileSync(replexicaConfigPath, "utf-8");
  const replexicaFileConfig = JSON.parse(fileContent);
  return replexicaFileConfig;
}

// src/cli/cmd/show/locale.ts
import { Command as Command5 } from "interactive-commander";
import Ora5 from "ora";
import { localeCodes } from "@lingo.dev/_spec";
var locale_default = new Command5().command("locale").description("List supported locale codes").helpOption("-h, --help", "Show help").argument(
  "<type>",
  'Type of locales to show: "sources" or "targets" - both show the full supported locale list'
).action(async (type) => {
  const ora = Ora5();
  try {
    switch (type) {
      default:
        throw new CLIError({
          message: `Invalid type: ${type}`,
          docUrl: "invalidType"
        });
      case "sources":
        localeCodes.forEach((locale) => console.log(locale));
        break;
      case "targets":
        localeCodes.forEach((locale) => console.log(locale));
        break;
    }
  } catch (error) {
    ora.fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/show/files.ts
import { Command as Command6 } from "interactive-commander";
import Ora6 from "ora";

// src/cli/utils/buckets.ts
import _5 from "lodash";
import path9 from "path";
import { glob as glob2 } from "glob";
import {
  resolveOverriddenLocale
} from "@lingo.dev/_spec";
function getBuckets(i18nConfig) {
  const result = Object.entries(i18nConfig.buckets).map(
    ([bucketType, bucketEntry]) => {
      const includeItems = bucketEntry.include.map(
        (item) => resolveBucketItem(item)
      );
      const excludeItems = bucketEntry.exclude?.map(
        (item) => resolveBucketItem(item)
      );
      const config = {
        type: bucketType,
        paths: extractPathPatterns(
          i18nConfig.locale.source,
          includeItems,
          excludeItems
        )
      };
      if (bucketEntry.injectLocale) {
        config.injectLocale = bucketEntry.injectLocale;
      }
      if (bucketEntry.lockedKeys) {
        config.lockedKeys = bucketEntry.lockedKeys;
      }
      if (bucketEntry.lockedPatterns) {
        config.lockedPatterns = bucketEntry.lockedPatterns;
      }
      if (bucketEntry.ignoredKeys) {
        config.ignoredKeys = bucketEntry.ignoredKeys;
      }
      return config;
    }
  );
  return result;
}
function extractPathPatterns(sourceLocale, include, exclude) {
  const includedPatterns = include.flatMap(
    (pattern) => expandPlaceholderedGlob(
      pattern.path,
      resolveOverriddenLocale(sourceLocale, pattern.delimiter)
    ).map((pathPattern) => ({
      pathPattern,
      delimiter: pattern.delimiter
    }))
  );
  const excludedPatterns = exclude?.flatMap(
    (pattern) => expandPlaceholderedGlob(
      pattern.path,
      resolveOverriddenLocale(sourceLocale, pattern.delimiter)
    ).map((pathPattern) => ({
      pathPattern,
      delimiter: pattern.delimiter
    }))
  );
  const result = _5.differenceBy(
    includedPatterns,
    excludedPatterns ?? [],
    (item) => item.pathPattern
  );
  return result;
}
function normalizePath(filepath) {
  const normalized = path9.normalize(filepath);
  return process.platform === "win32" ? normalized.toLowerCase() : normalized;
}
function expandPlaceholderedGlob(_pathPattern, sourceLocale) {
  const absolutePathPattern = path9.resolve(_pathPattern);
  const pathPattern = normalizePath(
    path9.relative(process.cwd(), absolutePathPattern)
  );
  if (pathPattern.startsWith("..")) {
    throw new CLIError({
      message: `Invalid path pattern: ${pathPattern}. Path pattern must be within the current working directory.`,
      docUrl: "invalidPathPattern"
    });
  }
  if (pathPattern.includes("**")) {
    throw new CLIError({
      message: `Invalid path pattern: ${pathPattern}. Recursive path patterns are not supported.`,
      docUrl: "invalidPathPattern"
    });
  }
  const pathPatternChunks = pathPattern.split(path9.sep);
  const localeSegmentIndexes = pathPatternChunks.reduce(
    (indexes, segment, index) => {
      if (segment.includes("[locale]")) {
        indexes.push(index);
      }
      return indexes;
    },
    []
  );
  const sourcePathPattern = pathPattern.replaceAll(/\[locale\]/g, sourceLocale);
  const unixStylePattern = sourcePathPattern.replace(/\\/g, "/");
  const sourcePaths = glob2.sync(unixStylePattern, {
    follow: true,
    withFileTypes: true,
    windowsPathsNoEscape: true
    // Windows path support
  }).filter((file) => file.isFile() || file.isSymbolicLink()).map((file) => file.fullpath()).map((fullpath) => normalizePath(path9.relative(process.cwd(), fullpath)));
  const placeholderedPaths = sourcePaths.map((sourcePath) => {
    const normalizedSourcePath = normalizePath(
      sourcePath.replace(/\//g, path9.sep)
    );
    const sourcePathChunks = normalizedSourcePath.split(path9.sep);
    localeSegmentIndexes.forEach((localeSegmentIndex) => {
      const pathPatternChunk = pathPatternChunks[localeSegmentIndex];
      const sourcePathChunk = sourcePathChunks[localeSegmentIndex];
      const regexp = new RegExp(
        "(" + pathPatternChunk.replaceAll(".", "\\.").replaceAll("*", ".*").replace("[locale]", `)${sourceLocale}(`) + ")"
      );
      const match2 = sourcePathChunk.match(regexp);
      if (match2) {
        const [, prefix, suffix] = match2;
        const placeholderedSegment = prefix + "[locale]" + suffix;
        sourcePathChunks[localeSegmentIndex] = placeholderedSegment;
      }
    });
    const placeholderedPath = sourcePathChunks.join(path9.sep);
    return placeholderedPath;
  });
  return placeholderedPaths;
}
function resolveBucketItem(bucketItem) {
  if (typeof bucketItem === "string") {
    return { path: bucketItem, delimiter: null };
  }
  return bucketItem;
}

// src/cli/cmd/show/files.ts
import { resolveOverriddenLocale as resolveOverriddenLocale2 } from "@lingo.dev/_spec";
var files_default = new Command6().command("files").description(
  "Expand each bucket's path pattern into concrete source and target file paths"
).option(
  "--source",
  "Only list the source locale variant for each path pattern"
).option(
  "--target",
  "Only list the target locale variants for each configured locale"
).helpOption("-h, --help", "Show help").action(async (type) => {
  const ora = Ora6();
  try {
    try {
      const i18nConfig = await getConfig();
      if (!i18nConfig) {
        throw new CLIError({
          message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
          docUrl: "i18nNotFound"
        });
      }
      const buckets = getBuckets(i18nConfig);
      for (const bucket of buckets) {
        for (const bucketConfig of bucket.paths) {
          const sourceLocale = resolveOverriddenLocale2(
            i18nConfig.locale.source,
            bucketConfig.delimiter
          );
          const sourcePath = bucketConfig.pathPattern.replace(
            /\[locale\]/g,
            sourceLocale
          );
          const targetPaths = i18nConfig.locale.targets.map(
            (_targetLocale) => {
              const targetLocale = resolveOverriddenLocale2(
                _targetLocale,
                bucketConfig.delimiter
              );
              return bucketConfig.pathPattern.replace(
                /\[locale\]/g,
                targetLocale
              );
            }
          );
          const result = [];
          if (!type.source && !type.target) {
            result.push(sourcePath, ...targetPaths);
          } else if (type.source) {
            result.push(sourcePath);
          } else if (type.target) {
            result.push(...targetPaths);
          }
          result.forEach((path19) => {
            console.log(path19);
          });
        }
      }
    } catch (error) {
      throw new CLIError({
        message: `Failed to expand placeholdered globs: ${error.message}`,
        docUrl: "placeHolderFailed"
      });
    }
  } catch (error) {
    ora.fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/show/locked-keys.ts
import { Command as Command7 } from "interactive-commander";
import Ora7 from "ora";

// src/cli/cmd/show/_shared-key-command.ts
import { resolveOverriddenLocale as resolveOverriddenLocale3 } from "@lingo.dev/_spec";

// src/cli/loaders/_utils.ts
function composeLoaders(...loaders) {
  return {
    init: async () => {
      for (const loader of loaders) {
        await loader.init?.();
      }
    },
    setDefaultLocale(locale) {
      for (const loader of loaders) {
        loader.setDefaultLocale?.(locale);
      }
      return this;
    },
    pull: async (locale, input2) => {
      let result = input2;
      for (let i = 0; i < loaders.length; i++) {
        result = await loaders[i].pull(locale, result);
      }
      return result;
    },
    push: async (locale, data) => {
      let result = data;
      for (let i = loaders.length - 1; i >= 0; i--) {
        result = await loaders[i].push(locale, result);
      }
      return result;
    },
    pullHints: async (originalInput) => {
      let result = originalInput;
      for (let i = 0; i < loaders.length; i++) {
        const subResult = await loaders[i].pullHints?.(result);
        if (subResult) {
          result = subResult;
        }
      }
      return result;
    }
  };
}
function createLoader(lDefinition) {
  const state = {
    defaultLocale: void 0,
    originalInput: void 0,
    pullInput: void 0,
    pullOutput: void 0,
    initCtx: void 0
  };
  return {
    async init() {
      if (state.initCtx) {
        return state.initCtx;
      }
      state.initCtx = await lDefinition.init?.();
      return state.initCtx;
    },
    setDefaultLocale(locale) {
      if (state.defaultLocale) {
        throw new Error("Default locale already set");
      }
      state.defaultLocale = locale;
      return this;
    },
    async pullHints() {
      return lDefinition.pullHints?.(state.originalInput);
    },
    async pull(locale, input2) {
      if (!state.defaultLocale) {
        throw new Error("Default locale not set");
      }
      if (state.originalInput === void 0 && locale !== state.defaultLocale) {
        throw new Error("The first pull must be for the default locale");
      }
      if (locale === state.defaultLocale) {
        state.originalInput = input2 || null;
      }
      state.pullInput = input2;
      const result = await lDefinition.pull(
        locale,
        input2,
        state.initCtx,
        state.defaultLocale,
        state.originalInput
      );
      state.pullOutput = result;
      return result;
    },
    async push(locale, data) {
      if (!state.defaultLocale) {
        throw new Error("Default locale not set");
      }
      if (state.originalInput === void 0) {
        throw new Error("Cannot push data without pulling first");
      }
      const pushResult = await lDefinition.push(
        locale,
        data,
        state.originalInput,
        state.defaultLocale,
        state.pullInput,
        state.pullOutput
      );
      return pushResult;
    }
  };
}

// src/cli/loaders/json.ts
import { jsonrepair } from "jsonrepair";
function createJsonLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      const jsonString = input2 || "{}";
      let result;
      try {
        result = JSON.parse(jsonString);
      } catch (error) {
        result = JSON.parse(jsonrepair(jsonString));
      }
      return result;
    },
    push: async (locale, data) => {
      const serializedData = JSON.stringify(data, null, 2);
      return serializedData;
    }
  });
}

// src/cli/loaders/json5.ts
import JSON5 from "json5";
function createJson5Loader() {
  return createLoader({
    pull: async (locale, input2) => {
      const json5String = input2 || "{}";
      return JSON5.parse(json5String);
    },
    push: async (locale, data) => {
      const serializedData = JSON5.stringify(data, null, 2);
      return serializedData;
    }
  });
}

// src/cli/loaders/jsonc.ts
import { parse } from "jsonc-parser";
function extractCommentsFromJsonc(jsoncString) {
  const lines = jsoncString.split("\n");
  const comments = {};
  const errors = [];
  const result = parse(jsoncString, errors, {
    allowTrailingComma: true,
    disallowComments: false,
    allowEmptyContent: true
  });
  if (errors.length > 0) {
    return {};
  }
  const contextStack = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    if (!trimmedLine) continue;
    const commentData = extractCommentFromLine(line, lines, i);
    if (commentData.hint) {
      let keyInfo;
      if (commentData.isInline) {
        const keyMatch = line.match(/^\s*["']?([^"':,\s]+)["']?\s*:/);
        if (keyMatch) {
          const key = keyMatch[1];
          const path19 = contextStack.map((ctx) => ctx.key).filter(Boolean);
          keyInfo = { key, path: path19 };
        }
      } else {
        keyInfo = findAssociatedKey(lines, commentData.lineIndex, contextStack);
      }
      if (keyInfo && keyInfo.key) {
        setCommentAtPath(comments, keyInfo.path, keyInfo.key, commentData.hint);
      }
      i = commentData.endIndex;
      continue;
    }
    updateContext(contextStack, line, result);
  }
  return comments;
}
function extractCommentFromLine(line, lines, lineIndex) {
  const trimmed = line.trim();
  if (trimmed.startsWith("//")) {
    const hint = trimmed.replace(/^\/\/\s*/, "").trim();
    return { hint, lineIndex, endIndex: lineIndex, isInline: false };
  }
  if (trimmed.startsWith("/*")) {
    const blockResult = extractBlockComment(lines, lineIndex);
    return { ...blockResult, isInline: false };
  }
  const singleInlineMatch = line.match(/^(.+?)\s*\/\/\s*(.+)$/);
  if (singleInlineMatch && singleInlineMatch[1].includes(":")) {
    const hint = singleInlineMatch[2].trim();
    return { hint, lineIndex, endIndex: lineIndex, isInline: true };
  }
  const blockInlineMatch = line.match(/^(.+?)\s*\/\*\s*(.*?)\s*\*\/.*$/);
  if (blockInlineMatch && blockInlineMatch[1].includes(":")) {
    const hint = blockInlineMatch[2].trim();
    return { hint, lineIndex, endIndex: lineIndex, isInline: true };
  }
  return { hint: null, lineIndex, endIndex: lineIndex, isInline: false };
}
function extractBlockComment(lines, startIndex) {
  const startLine = lines[startIndex];
  const singleMatch = startLine.match(/\/\*\s*(.*?)\s*\*\//);
  if (singleMatch) {
    return {
      hint: singleMatch[1].trim(),
      lineIndex: startIndex,
      endIndex: startIndex
    };
  }
  const commentParts = [];
  let endIndex = startIndex;
  const firstContent = startLine.replace(/.*?\/\*\s*/, "").trim();
  if (firstContent && !firstContent.includes("*/")) {
    commentParts.push(firstContent);
  }
  for (let i = startIndex + 1; i < lines.length; i++) {
    const line = lines[i];
    endIndex = i;
    if (line.includes("*/")) {
      const lastContent = line.replace(/\*\/.*$/, "").replace(/^\s*\*?\s*/, "").trim();
      if (lastContent) {
        commentParts.push(lastContent);
      }
      break;
    } else {
      const content = line.replace(/^\s*\*?\s*/, "").trim();
      if (content) {
        commentParts.push(content);
      }
    }
  }
  return {
    hint: commentParts.join(" ").trim() || null,
    lineIndex: startIndex,
    endIndex
  };
}
function findAssociatedKey(lines, commentLineIndex, contextStack) {
  for (let i = commentLineIndex + 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line || line.startsWith("//") || line.startsWith("/*") || line === "{" || line === "}") {
      continue;
    }
    const keyMatch = line.match(/^\s*["']?([^"':,\s]+)["']?\s*:/);
    if (keyMatch) {
      const key = keyMatch[1];
      const path19 = contextStack.map((ctx) => ctx.key).filter(Boolean);
      return { key, path: path19 };
    }
  }
  return { key: null, path: [] };
}
function updateContext(contextStack, line, parsedJson) {
  const openBraces = (line.match(/\{/g) || []).length;
  const closeBraces = (line.match(/\}/g) || []).length;
  if (openBraces > closeBraces) {
    const keyMatch = line.match(/^\s*["']?([^"':,\s]+)["']?\s*:\s*\{/);
    if (keyMatch) {
      contextStack.push({ key: keyMatch[1], isArray: false });
    }
  } else if (closeBraces > openBraces) {
    for (let i = 0; i < closeBraces - openBraces; i++) {
      contextStack.pop();
    }
  }
}
function setCommentAtPath(comments, path19, key, hint) {
  let current = comments;
  for (const pathKey of path19) {
    if (!current[pathKey]) {
      current[pathKey] = {};
    }
    current = current[pathKey];
  }
  if (!current[key]) {
    current[key] = {};
  }
  if (typeof current[key] === "object" && current[key] !== null) {
    current[key].hint = hint;
  } else {
    current[key] = { hint };
  }
}
function createJsoncLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      const jsoncString = input2 || "{}";
      const errors = [];
      const result = parse(jsoncString, errors, {
        allowTrailingComma: true,
        disallowComments: false,
        allowEmptyContent: true
      });
      if (errors.length > 0) {
        throw new Error(`Failed to parse JSONC: ${errors[0].error}`);
      }
      return result || {};
    },
    push: async (locale, data) => {
      const serializedData = JSON.stringify(data, null, 2);
      return serializedData;
    },
    pullHints: async (input2) => {
      if (!input2 || typeof input2 !== "string") {
        return {};
      }
      try {
        return extractCommentsFromJsonc(input2);
      } catch (error) {
        console.warn("Failed to extract comments from JSONC:", error);
        return {};
      }
    }
  });
}

// src/cli/loaders/flat.ts
import { flatten, unflatten } from "flat";
import _6 from "lodash";
var OBJECT_NUMERIC_KEY_PREFIX = "__lingodotdev__obj__";
function createFlatLoader(options) {
  const composedLoader = composeLoaders(
    createDenormalizeLoader(options),
    createNormalizeLoader()
  );
  return {
    ...composedLoader,
    pullHints: async (input2) => {
      if (!input2 || typeof input2 !== "object") {
        return {};
      }
      return flattenHints(input2);
    }
  };
}
function createDenormalizeLoader(options) {
  return createLoader({
    pull: async (locale, input2) => {
      const inputDenormalized = denormalizeObjectKeys(input2 || {});
      const preservedObjects = {};
      const nonPreservedInput = {};
      for (const [key, value] of Object.entries(inputDenormalized)) {
        if (options?.shouldPreserveObject?.(value)) {
          preservedObjects[key] = value;
        } else {
          nonPreservedInput[key] = value;
        }
      }
      const flattened = flatten(nonPreservedInput, {
        delimiter: "/",
        transformKey(key) {
          return encodeURIComponent(String(key));
        }
      });
      const denormalized = { ...flattened };
      for (const [key, value] of Object.entries(preservedObjects)) {
        const encodedKey = encodeURIComponent(String(key));
        denormalized[encodedKey] = value;
      }
      const keysMap = buildDenormalizedKeysMap(denormalized);
      return { denormalized, keysMap };
    },
    push: async (locale, { denormalized }) => {
      const normalized = normalizeObjectKeys(denormalized);
      return normalized;
    }
  });
}
function createNormalizeLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      const normalized = normalizeObjectKeys(input2.denormalized);
      return normalized;
    },
    push: async (locale, data, originalInput) => {
      const keysMap = originalInput?.keysMap ?? {};
      const input2 = mapDenormalizedKeys(data, keysMap);
      const denormalized = unflatten(input2, {
        delimiter: "/",
        transformKey(key) {
          return decodeURIComponent(String(key));
        }
      });
      return { denormalized, keysMap: keysMap || {} };
    }
  });
}
function buildDenormalizedKeysMap(obj) {
  if (!obj) return {};
  return Object.keys(obj).reduce(
    (acc, key) => {
      if (key) {
        const normalizedKey = `${key}`.replace(OBJECT_NUMERIC_KEY_PREFIX, "");
        acc[normalizedKey] = key;
      }
      return acc;
    },
    {}
  );
}
function mapDenormalizedKeys(obj, denormalizedKeysMap) {
  return Object.keys(obj).reduce(
    (acc, key) => {
      const denormalizedKey = denormalizedKeysMap[key] ?? key;
      acc[denormalizedKey] = obj[key];
      return acc;
    },
    {}
  );
}
function denormalizeObjectKeys(obj) {
  if (_6.isObject(obj) && !_6.isArray(obj)) {
    return _6.transform(
      obj,
      (result, value, key) => {
        const newKey = !isNaN(Number(key)) ? `${OBJECT_NUMERIC_KEY_PREFIX}${key}` : key;
        result[newKey] = _6.isObject(value) && !_6.isDate(value) ? denormalizeObjectKeys(value) : value;
      },
      {}
    );
  } else {
    return obj;
  }
}
function normalizeObjectKeys(obj) {
  if (_6.isObject(obj) && !_6.isArray(obj)) {
    return _6.transform(
      obj,
      (result, value, key) => {
        const newKey = `${key}`.replace(OBJECT_NUMERIC_KEY_PREFIX, "");
        result[newKey] = _6.isObject(value) && !_6.isDate(value) ? normalizeObjectKeys(value) : value;
      },
      {}
    );
  } else {
    return obj;
  }
}
function flattenHints(obj, parentHints = [], parentPath = "") {
  const result = {};
  for (const [key, _value] of Object.entries(obj)) {
    if (_6.isObject(_value) && !_6.isArray(_value)) {
      const value = _value;
      const currentHints = [...parentHints];
      const currentPath = parentPath ? `${parentPath}/${key}` : key;
      if (value.hint && typeof value.hint === "string") {
        currentHints.push(value.hint);
      }
      const nestedObj = _6.omit(value, "hint");
      if (Object.keys(nestedObj).length === 0) {
        if (currentHints.length > 0) {
          result[currentPath] = currentHints;
        }
      } else {
        const nestedComments = flattenHints(
          nestedObj,
          currentHints,
          currentPath
        );
        Object.assign(result, nestedComments);
      }
    }
  }
  return result;
}

// src/cli/loaders/text-file.ts
import fs8 from "fs/promises";
import path10 from "path";
function createTextFileLoader(pathPattern) {
  return createLoader({
    async pull(locale) {
      const result = await readFileForLocale(pathPattern, locale);
      const trimmedResult = result.trim();
      return trimmedResult;
    },
    async push(locale, data, _36, originalLocale) {
      const draftPath = pathPattern.replaceAll("[locale]", locale);
      const finalPath = path10.resolve(draftPath);
      const dirPath = path10.dirname(finalPath);
      await fs8.mkdir(dirPath, { recursive: true });
      const trimmedPayload = data.trim();
      const trailingNewLine = await getTrailingNewLine(
        pathPattern,
        locale,
        originalLocale
      );
      let finalPayload = trimmedPayload + trailingNewLine;
      await fs8.writeFile(finalPath, finalPayload, {
        encoding: "utf-8",
        flag: "w"
      });
    }
  });
}
async function readFileForLocale(pathPattern, locale) {
  const draftPath = pathPattern.replaceAll("[locale]", locale);
  const finalPath = path10.resolve(draftPath);
  const exists = await fs8.access(finalPath).then(() => true).catch(() => false);
  if (!exists) {
    return "";
  }
  return fs8.readFile(finalPath, "utf-8");
}
async function getTrailingNewLine(pathPattern, locale, originalLocale) {
  let templateData = await readFileForLocale(pathPattern, locale);
  if (!templateData) {
    templateData = await readFileForLocale(pathPattern, originalLocale);
  }
  if (templateData?.match(/[\r\n]$/)) {
    const ending = templateData?.includes("\r\n") ? "\r\n" : templateData?.includes("\r") ? "\r" : "\n";
    return ending;
  }
  return "";
}

// src/cli/loaders/yaml.ts
import YAML from "yaml";
function createYamlLoader() {
  return createLoader({
    async pull(locale, input2) {
      return YAML.parse(input2) || {};
    },
    async push(locale, payload, originalInput) {
      return YAML.stringify(payload, {
        lineWidth: -1,
        defaultKeyType: getKeyType(originalInput),
        defaultStringType: getStringType(originalInput)
      });
    }
  });
}
function getKeyType(yamlString) {
  if (yamlString) {
    const lines = yamlString.split("\n");
    const hasDoubleQuotes = lines.find((line) => {
      return line.trim().startsWith('"') && line.trim().match('":');
    });
    if (hasDoubleQuotes) {
      return "QUOTE_DOUBLE";
    }
  }
  return "PLAIN";
}
function getStringType(yamlString) {
  if (yamlString) {
    const lines = yamlString.split("\n");
    const hasDoubleQuotes = lines.find((line) => {
      const trimmedLine = line.trim();
      return (trimmedLine.startsWith('"') || trimmedLine.match(/:\s*"/)) && (trimmedLine.endsWith('"') || trimmedLine.endsWith('",'));
    });
    if (hasDoubleQuotes) {
      return "QUOTE_DOUBLE";
    }
  }
  return "PLAIN";
}

// src/cli/loaders/root-key.ts
function createRootKeyLoader(replaceAll = false) {
  return createLoader({
    async pull(locale, input2) {
      const result = input2[locale];
      return result;
    },
    async push(locale, data, originalInput) {
      const result = {
        ...replaceAll ? {} : originalInput,
        [locale]: data
      };
      return result;
    }
  });
}

// src/cli/loaders/flutter.ts
import _7 from "lodash";
function createFlutterLoader() {
  return createLoader({
    async pull(locale, input2) {
      const result = _7.pickBy(input2, (value, key) => !_isMetadataKey(key));
      return result;
    },
    async push(locale, data, originalInput) {
      const metadata = _7.pickBy(
        originalInput,
        (value, key) => _isMetadataKey(key)
      );
      const result = _7.merge({}, metadata, { "@@locale": locale }, data);
      return result;
    }
  });
}
function _isMetadataKey(key) {
  return key.startsWith("@");
}

// src/cli/loaders/android.ts
import { createRequire } from "node:module";
import { parseStringPromise } from "xml2js";
var require2 = createRequire(import.meta.url);
var sax = require2("sax");
var defaultAndroidResourcesXml = `<?xml version="1.0" encoding="utf-8"?>
<resources>
</resources>`;
function createAndroidLoader() {
  return createLoader({
    async pull(locale, input2) {
      try {
        if (!input2) {
          return {};
        }
        const document = await parseAndroidDocument(input2);
        return buildPullResult(document);
      } catch (error) {
        console.error("Error parsing Android resource file:", error);
        throw new CLIError({
          message: "Failed to parse Android resource file",
          docUrl: "androidResouceError"
        });
      }
    },
    async push(locale, payload, originalInput, originalLocale, pullInput, pullOutput) {
      try {
        const selectedBase = selectBaseXml(
          locale,
          originalLocale,
          pullInput,
          originalInput
        );
        const existingDocument = await parseAndroidDocument(selectedBase);
        const sourceDocument = await parseAndroidDocument(originalInput);
        const translatedDocument = buildTranslatedDocument(
          payload,
          existingDocument,
          sourceDocument
        );
        const referenceXml = selectedBase || originalInput || defaultAndroidResourcesXml;
        const declaration = resolveXmlDeclaration(referenceXml);
        return buildAndroidXml(translatedDocument, declaration);
      } catch (error) {
        console.error("Error generating Android resource file:", error);
        throw new CLIError({
          message: "Failed to generate Android resource file",
          docUrl: "androidResouceError"
        });
      }
    }
  });
}
function resolveXmlDeclaration(xml) {
  if (!xml) {
    const xmldec = {
      version: "1.0",
      encoding: "utf-8"
    };
    return {
      xmldec,
      headless: false
    };
  }
  const match2 = xml.match(
    /<\?xml\s+version="([^"]+)"(?:\s+encoding="([^"]+)")?\s*\?>/
  );
  if (match2) {
    const version = match2[1] && match2[1].trim().length > 0 ? match2[1] : "1.0";
    const encoding = match2[2] && match2[2].trim().length > 0 ? match2[2] : void 0;
    const xmldec = encoding ? { version, encoding } : { version };
    return {
      xmldec,
      headless: false
    };
  }
  return { headless: true };
}
async function parseAndroidDocument(input2) {
  const xmlToParse = input2 && input2.trim().length > 0 ? input2 : defaultAndroidResourcesXml;
  const parsed = await parseStringPromise(xmlToParse, {
    explicitArray: true,
    explicitChildren: true,
    preserveChildrenOrder: true,
    charsAsChildren: true,
    includeWhiteChars: true,
    mergeAttrs: false,
    normalize: false,
    normalizeTags: false,
    trim: false,
    attrkey: "$",
    charkey: "_",
    childkey: "$$"
  });
  if (!parsed || !parsed.resources) {
    return {
      resources: { $$: [] },
      resourceNodes: []
    };
  }
  const resourcesNode = parsed.resources;
  resourcesNode["#name"] = resourcesNode["#name"] ?? "resources";
  resourcesNode.$$ = resourcesNode.$$ ?? [];
  const metadata = extractResourceMetadata(xmlToParse);
  const resourceNodes = [];
  let metaIndex = 0;
  for (const child of resourcesNode.$$) {
    const elementName = child?.["#name"];
    if (!isResourceElementName(elementName)) {
      continue;
    }
    const meta = metadata[metaIndex++];
    if (!meta || meta.type !== elementName) {
      continue;
    }
    const name = child?.$?.name ?? meta.name;
    if (!name) {
      continue;
    }
    const translatable = (child?.$?.translatable ?? "").toLowerCase() !== "false";
    switch (meta.type) {
      case "string": {
        resourceNodes.push({
          type: "string",
          name,
          translatable,
          node: child,
          meta: cloneTextMeta(meta.meta)
        });
        break;
      }
      case "string-array": {
        const itemNodes = child?.item ?? [];
        const items = [];
        const templateItems = meta.items;
        for (let i = 0; i < Math.max(itemNodes.length, templateItems.length); i++) {
          const nodeItem = itemNodes[i];
          const templateItem = templateItems[i] ?? templateItems[templateItems.length - 1];
          if (!nodeItem) {
            continue;
          }
          items.push({
            node: nodeItem,
            meta: cloneTextMeta(templateItem.meta)
          });
        }
        resourceNodes.push({
          type: "string-array",
          name,
          translatable,
          node: child,
          items
        });
        break;
      }
      case "plurals": {
        const itemNodes = child?.item ?? [];
        const templateItems = meta.items;
        const items = [];
        for (const templateItem of templateItems) {
          const quantity = templateItem.quantity;
          if (!quantity) {
            continue;
          }
          const nodeItem = itemNodes.find(
            (item) => item?.$?.quantity === quantity
          );
          if (!nodeItem) {
            continue;
          }
          items.push({
            node: nodeItem,
            quantity,
            meta: cloneTextMeta(templateItem.meta)
          });
        }
        resourceNodes.push({
          type: "plurals",
          name,
          translatable,
          node: child,
          items
        });
        break;
      }
      case "bool": {
        resourceNodes.push({
          type: "bool",
          name,
          translatable,
          node: child,
          meta: cloneTextMeta(meta.meta)
        });
        break;
      }
      case "integer": {
        resourceNodes.push({
          type: "integer",
          name,
          translatable,
          node: child,
          meta: cloneTextMeta(meta.meta)
        });
        break;
      }
    }
  }
  return { resources: resourcesNode, resourceNodes };
}
function buildPullResult(document) {
  const result = {};
  for (const resource of document.resourceNodes) {
    if (!isTranslatable(resource)) {
      continue;
    }
    switch (resource.type) {
      case "string": {
        result[resource.name] = decodeAndroidText(
          segmentsToString(resource.meta.segments)
        );
        break;
      }
      case "string-array": {
        result[resource.name] = resource.items.map(
          (item) => decodeAndroidText(segmentsToString(item.meta.segments))
        );
        break;
      }
      case "plurals": {
        const pluralMap = {};
        for (const item of resource.items) {
          pluralMap[item.quantity] = decodeAndroidText(
            segmentsToString(item.meta.segments)
          );
        }
        result[resource.name] = pluralMap;
        break;
      }
      case "bool": {
        const value = segmentsToString(resource.meta.segments).trim();
        result[resource.name] = value === "true";
        break;
      }
      case "integer": {
        const value = parseInt(
          segmentsToString(resource.meta.segments).trim(),
          10
        );
        result[resource.name] = Number.isNaN(value) ? 0 : value;
        break;
      }
    }
  }
  return result;
}
function isTranslatable(resource) {
  return resource.translatable;
}
function buildTranslatedDocument(payload, existingDocument, sourceDocument) {
  const templateDocument = sourceDocument;
  const finalDocument = cloneDocumentStructure(templateDocument);
  const templateMap = createResourceMap(templateDocument);
  const existingMap = createResourceMap(existingDocument);
  const payloadEntries = payload ?? {};
  const finalMap = createResourceMap(finalDocument);
  for (const resource of finalDocument.resourceNodes) {
    if (!resource.translatable) {
      continue;
    }
    const templateResource = templateMap.get(resource.name);
    let translationValue;
    if (Object.prototype.hasOwnProperty.call(payloadEntries, resource.name) && payloadEntries[resource.name] !== void 0 && payloadEntries[resource.name] !== null) {
      translationValue = payloadEntries[resource.name];
    } else if (existingMap.has(resource.name)) {
      translationValue = extractValueFromResource(
        existingMap.get(resource.name)
      );
    } else {
      translationValue = extractValueFromResource(templateResource ?? resource);
    }
    updateResourceNode(resource, translationValue, templateResource);
  }
  for (const resource of existingDocument.resourceNodes) {
    if (finalMap.has(resource.name)) {
      continue;
    }
    if (!isTranslatable(resource)) {
      continue;
    }
    const cloned = cloneResourceNode(resource);
    appendResourceNode(finalDocument, cloned);
    finalMap.set(cloned.name, cloned);
  }
  for (const [name, value] of Object.entries(payloadEntries)) {
    if (finalMap.has(name)) {
      continue;
    }
    try {
      const inferred = createResourceNodeFromValue(name, value);
      appendResourceNode(finalDocument, inferred);
      finalMap.set(name, inferred);
    } catch (error) {
      if (error instanceof CLIError) {
        throw error;
      }
    }
  }
  return finalDocument;
}
function buildAndroidXml(document, declaration) {
  const xmlBody = serializeElement(document.resources);
  if (declaration.headless) {
    return xmlBody;
  }
  if (declaration.xmldec) {
    const { version, encoding } = declaration.xmldec;
    const encodingPart = encoding ? ` encoding="${encoding}"` : "";
    return `<?xml version="${version}"${encodingPart}?>
${xmlBody}`;
  }
  return `<?xml version="1.0" encoding="utf-8"?>
${xmlBody}`;
}
function selectBaseXml(locale, originalLocale, pullInput, originalInput) {
  if (locale === originalLocale) {
    return pullInput ?? originalInput;
  }
  return pullInput ?? originalInput;
}
function updateResourceNode(target, rawValue, template) {
  switch (target.type) {
    case "string": {
      const value = asString(rawValue, target.name);
      const templateMeta = template && template.type === "string" ? template.meta : target.meta;
      const useCdata = templateMeta.hasCdata;
      setTextualNodeContent(target.node, value, useCdata);
      target.meta = makeTextMeta([
        { kind: useCdata ? "cdata" : "text", value }
      ]);
      break;
    }
    case "string-array": {
      const values = asStringArray(rawValue, target.name);
      const templateItems = template && template.type === "string-array" ? template.items : target.items;
      const maxLength = Math.max(target.items.length, templateItems.length);
      for (let index = 0; index < maxLength; index++) {
        const targetItem = target.items[index];
        const templateItem = templateItems[index] ?? templateItems[templateItems.length - 1] ?? target.items[index];
        if (!targetItem || !templateItem) {
          continue;
        }
        const translation = index < values.length ? values[index] : segmentsToString(templateItem.meta.segments);
        const useCdata = templateItem.meta.hasCdata;
        setTextualNodeContent(targetItem.node, translation, useCdata);
        targetItem.meta = makeTextMeta([
          { kind: useCdata ? "cdata" : "text", value: translation }
        ]);
      }
      break;
    }
    case "plurals": {
      const pluralValues = asPluralMap(rawValue, target.name);
      const templateItems = template && template.type === "plurals" ? template.items : target.items;
      const templateMap = new Map(
        templateItems.map((item) => [item.quantity, item])
      );
      for (const item of target.items) {
        const templateItem = templateMap.get(item.quantity) ?? templateMap.values().next().value;
        const fallback = templateItem ? segmentsToString(templateItem.meta.segments) : segmentsToString(item.meta.segments);
        const translation = typeof pluralValues[item.quantity] === "string" ? pluralValues[item.quantity] : fallback;
        const useCdata = templateItem ? templateItem.meta.hasCdata : item.meta.hasCdata;
        setTextualNodeContent(item.node, translation, useCdata);
        item.meta = makeTextMeta([
          { kind: useCdata ? "cdata" : "text", value: translation }
        ]);
      }
      break;
    }
    case "bool": {
      const boolValue = asBoolean(rawValue, target.name);
      const strValue = boolValue ? "true" : "false";
      setTextualNodeContent(target.node, strValue, false);
      target.meta = makeTextMeta([{ kind: "text", value: strValue }]);
      break;
    }
    case "integer": {
      const intValue = asInteger(rawValue, target.name);
      const strValue = intValue.toString();
      setTextualNodeContent(target.node, strValue, false);
      target.meta = makeTextMeta([{ kind: "text", value: strValue }]);
      break;
    }
  }
}
function appendResourceNode(document, resourceNode) {
  document.resources.$$ = document.resources.$$ ?? [];
  const children = document.resources.$$;
  if (children.length === 0 || children[children.length - 1]["#name"] !== "__text__" && children[children.length - 1]["#name"] !== "__comment__") {
    children.push({ "#name": "__text__", _: "\n    " });
  }
  children.push(resourceNode.node);
  children.push({ "#name": "__text__", _: "\n" });
  document.resourceNodes.push(resourceNode);
}
function setTextualNodeContent(node, value, useCdata) {
  const escapedValue = useCdata ? escapeApostrophesOnly(value) : escapeAndroidString(value);
  node._ = escapedValue;
  node.$$ = node.$$ ?? [];
  let textNode = node.$$.find(
    (child) => child["#name"] === "__text__" || child["#name"] === "__cdata"
  );
  if (!textNode) {
    textNode = {};
    node.$$.push(textNode);
  }
  textNode["#name"] = useCdata ? "__cdata" : "__text__";
  textNode._ = escapedValue;
}
function buildResourceNameMap(document) {
  const map = /* @__PURE__ */ new Map();
  for (const node of document.resourceNodes) {
    if (!map.has(node.name)) {
      map.set(node.name, node);
    }
  }
  return map;
}
function createResourceMap(document) {
  return buildResourceNameMap(document);
}
function cloneResourceNode(resource) {
  switch (resource.type) {
    case "string": {
      const nodeClone = deepClone(resource.node);
      return {
        type: "string",
        name: resource.name,
        translatable: resource.translatable,
        node: nodeClone,
        meta: cloneTextMeta(resource.meta)
      };
    }
    case "string-array": {
      const nodeClone = deepClone(resource.node);
      const itemNodes = nodeClone.item ?? [];
      const items = itemNodes.map((itemNode, index) => {
        const templateMeta = resource.items[index]?.meta ?? resource.items[resource.items.length - 1]?.meta ?? makeTextMeta([]);
        return {
          node: itemNode,
          meta: cloneTextMeta(templateMeta)
        };
      });
      return {
        type: "string-array",
        name: resource.name,
        translatable: resource.translatable,
        node: nodeClone,
        items
      };
    }
    case "plurals": {
      const nodeClone = deepClone(resource.node);
      const itemNodes = nodeClone.item ?? [];
      const items = [];
      for (const templateItem of resource.items) {
        const cloneNode = itemNodes.find(
          (item) => item?.$?.quantity === templateItem.quantity
        );
        if (!cloneNode) {
          continue;
        }
        items.push({
          node: cloneNode,
          quantity: templateItem.quantity,
          meta: cloneTextMeta(templateItem.meta)
        });
      }
      return {
        type: "plurals",
        name: resource.name,
        translatable: resource.translatable,
        node: nodeClone,
        items
      };
    }
    case "bool": {
      const nodeClone = deepClone(resource.node);
      return {
        type: "bool",
        name: resource.name,
        translatable: resource.translatable,
        node: nodeClone,
        meta: cloneTextMeta(resource.meta)
      };
    }
    case "integer": {
      const nodeClone = deepClone(resource.node);
      return {
        type: "integer",
        name: resource.name,
        translatable: resource.translatable,
        node: nodeClone,
        meta: cloneTextMeta(resource.meta)
      };
    }
  }
}
function cloneTextMeta(meta) {
  return {
    hasCdata: meta.hasCdata,
    segments: meta.segments.map((segment) => ({ ...segment }))
  };
}
function asString(value, name) {
  if (typeof value === "string") {
    return value;
  }
  throw new CLIError({
    message: `Expected string value for resource "${name}"`,
    docUrl: "androidResouceError"
  });
}
function asStringArray(value, name) {
  if (Array.isArray(value) && value.every((item) => typeof item === "string")) {
    return value;
  }
  throw new CLIError({
    message: `Expected array of strings for resource "${name}"`,
    docUrl: "androidResouceError"
  });
}
function asPluralMap(value, name) {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    const result = {};
    for (const [quantity, pluralValue] of Object.entries(value)) {
      if (typeof pluralValue !== "string") {
        throw new CLIError({
          message: `Expected plural item "${quantity}" of "${name}" to be a string`,
          docUrl: "androidResouceError"
        });
      }
      result[quantity] = pluralValue;
    }
    return result;
  }
  throw new CLIError({
    message: `Expected object value for plurals resource "${name}"`,
    docUrl: "androidResouceError"
  });
}
function asBoolean(value, name) {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    if (value === "true" || value === "false") {
      return value === "true";
    }
  }
  throw new CLIError({
    message: `Expected boolean value for resource "${name}"`,
    docUrl: "androidResouceError"
  });
}
function asInteger(value, name) {
  if (typeof value === "number" && Number.isInteger(value)) {
    return value;
  }
  throw new CLIError({
    message: `Expected number value for resource "${name}"`,
    docUrl: "androidResouceError"
  });
}
function escapeAndroidString(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(?<!\\)'/g, "\\'");
}
function escapeApostrophesOnly(value) {
  return value.replace(/(?<!\\)'/g, "\\'");
}
function segmentsToString(segments) {
  return segments.map((segment) => segment.value).join("");
}
function makeTextMeta(segments) {
  return {
    segments,
    hasCdata: segments.some((segment) => segment.kind === "cdata")
  };
}
function createResourceNodeFromValue(name, value) {
  const inferredType = inferTypeFromValue(value);
  switch (inferredType) {
    case "string": {
      const stringValue = asString(value, name);
      const escaped = escapeAndroidString(stringValue);
      const node = {
        "#name": "string",
        $: { name },
        _: escaped,
        $$: [{ "#name": "__text__", _: escaped }]
      };
      return {
        type: "string",
        name,
        translatable: true,
        node,
        meta: makeTextMeta([{ kind: "text", value: stringValue }])
      };
    }
    case "string-array": {
      const items = asStringArray(value, name);
      const node = {
        "#name": "string-array",
        $: { name },
        $$: [],
        item: []
      };
      const itemNodes = [];
      for (const itemValue of items) {
        const escaped = escapeAndroidString(itemValue);
        const itemNode = {
          "#name": "item",
          _: escaped,
          $$: [{ "#name": "__text__", _: escaped }]
        };
        node.$$.push(itemNode);
        node.item.push(itemNode);
        itemNodes.push({
          node: itemNode,
          meta: makeTextMeta([{ kind: "text", value: itemValue }])
        });
      }
      return {
        type: "string-array",
        name,
        translatable: true,
        node,
        items: itemNodes
      };
    }
    case "plurals": {
      const pluralMap = asPluralMap(value, name);
      const node = {
        "#name": "plurals",
        $: { name },
        $$: [],
        item: []
      };
      const items = [];
      for (const [quantity, pluralValue] of Object.entries(pluralMap)) {
        const escaped = escapeAndroidString(pluralValue);
        const itemNode = {
          "#name": "item",
          $: { quantity },
          _: escaped,
          $$: [{ "#name": "__text__", _: escaped }]
        };
        node.$$.push(itemNode);
        node.item.push(itemNode);
        items.push({
          node: itemNode,
          quantity,
          meta: makeTextMeta([{ kind: "text", value: pluralValue }])
        });
      }
      return {
        type: "plurals",
        name,
        translatable: true,
        node,
        items
      };
    }
    case "bool": {
      const boolValue = asBoolean(value, name);
      const textValue = boolValue ? "true" : "false";
      const node = {
        "#name": "bool",
        $: { name },
        _: textValue,
        $$: [{ "#name": "__text__", _: textValue }]
      };
      return {
        type: "bool",
        name,
        translatable: true,
        node,
        meta: makeTextMeta([{ kind: "text", value: textValue }])
      };
    }
    case "integer": {
      const intValue = asInteger(value, name);
      const textValue = intValue.toString();
      const node = {
        "#name": "integer",
        $: { name },
        _: textValue,
        $$: [{ "#name": "__text__", _: textValue }]
      };
      return {
        type: "integer",
        name,
        translatable: true,
        node,
        meta: makeTextMeta([{ kind: "text", value: textValue }])
      };
    }
  }
}
function cloneDocumentStructure(document) {
  const translatableResources = document.resourceNodes.filter(isTranslatable);
  const resourcesClone = deepClone(document.resources);
  const lookup = buildResourceLookup(resourcesClone);
  const resourceNodes = [];
  for (const resource of translatableResources) {
    const cloned = cloneResourceNodeFromLookup(resource, lookup);
    resourceNodes.push(cloned);
  }
  if (resourcesClone.$$ && Array.isArray(resourcesClone.$$)) {
    const includedKeys = new Set(
      resourceNodes.map((r) => resourceLookupKey(r.type, r.name))
    );
    let filtered = resourcesClone.$$.filter((child) => {
      const elementName = child?.["#name"];
      const name = child?.$?.name;
      if (!isResourceElementName(elementName) || !name) {
        return true;
      }
      return includedKeys.has(resourceLookupKey(elementName, name));
    });
    const cleaned = [];
    let lastWasWhitespace = false;
    for (const child of filtered) {
      const isWhitespace = child?.["#name"] === "__text__" && (!child._ || child._.trim() === "");
      if (isWhitespace) {
        if (!lastWasWhitespace) {
          cleaned.push(child);
          lastWasWhitespace = true;
        }
      } else {
        cleaned.push(child);
        lastWasWhitespace = false;
      }
    }
    resourcesClone.$$ = cleaned;
  }
  return {
    resources: resourcesClone,
    resourceNodes
  };
}
function buildResourceLookup(resources) {
  const lookup = /* @__PURE__ */ new Map();
  const children = Array.isArray(resources.$$) ? resources.$$ : [];
  for (const child of children) {
    const type = child?.["#name"];
    const name = child?.$?.name;
    if (!type || !name || !isResourceElementName(type)) {
      continue;
    }
    const key = resourceLookupKey(type, name);
    if (!lookup.has(key)) {
      lookup.set(key, []);
    }
    lookup.get(key).push(child);
  }
  return lookup;
}
function cloneResourceNodeFromLookup(resource, lookup) {
  const node = takeResourceNode(lookup, resource.type, resource.name);
  if (!node) {
    return cloneResourceNode(resource);
  }
  switch (resource.type) {
    case "string": {
      return {
        type: "string",
        name: resource.name,
        translatable: resource.translatable,
        node,
        meta: cloneTextMeta(resource.meta)
      };
    }
    case "string-array": {
      const childItems = (Array.isArray(node.$$) ? node.$$ : []).filter(
        (child) => child?.["#name"] === "item"
      );
      node.item = childItems;
      if (childItems.length < resource.items.length) {
        return cloneResourceNode(resource);
      }
      const items = resource.items.map((item, index) => {
        const nodeItem = childItems[index];
        if (!nodeItem) {
          return {
            node: deepClone(item.node),
            meta: cloneTextMeta(item.meta)
          };
        }
        return {
          node: nodeItem,
          meta: cloneTextMeta(item.meta)
        };
      });
      return {
        type: "string-array",
        name: resource.name,
        translatable: resource.translatable,
        node,
        items
      };
    }
    case "plurals": {
      const childItems = (Array.isArray(node.$$) ? node.$$ : []).filter(
        (child) => child?.["#name"] === "item"
      );
      node.item = childItems;
      const itemMap = /* @__PURE__ */ new Map();
      for (const item of childItems) {
        if (item?.$?.quantity) {
          itemMap.set(item.$.quantity, item);
        }
      }
      const items = [];
      for (const templateItem of resource.items) {
        const nodeItem = itemMap.get(templateItem.quantity);
        if (!nodeItem) {
          return cloneResourceNode(resource);
        }
        items.push({
          node: nodeItem,
          quantity: templateItem.quantity,
          meta: cloneTextMeta(templateItem.meta)
        });
      }
      return {
        type: "plurals",
        name: resource.name,
        translatable: resource.translatable,
        node,
        items
      };
    }
    case "bool": {
      return {
        type: "bool",
        name: resource.name,
        translatable: resource.translatable,
        node,
        meta: cloneTextMeta(resource.meta)
      };
    }
    case "integer": {
      return {
        type: "integer",
        name: resource.name,
        translatable: resource.translatable,
        node,
        meta: cloneTextMeta(resource.meta)
      };
    }
  }
}
function takeResourceNode(lookup, type, name) {
  const key = resourceLookupKey(type, name);
  const list = lookup.get(key);
  if (!list || list.length === 0) {
    return void 0;
  }
  return list.shift();
}
function resourceLookupKey(type, name) {
  return `${type}:${name}`;
}
function extractValueFromResource(resource) {
  switch (resource.type) {
    case "string":
      return decodeAndroidText(segmentsToString(resource.meta.segments));
    case "string-array":
      return resource.items.map(
        (item) => decodeAndroidText(segmentsToString(item.meta.segments))
      );
    case "plurals": {
      const result = {};
      for (const item of resource.items) {
        result[item.quantity] = decodeAndroidText(
          segmentsToString(item.meta.segments)
        );
      }
      return result;
    }
    case "bool": {
      const value = segmentsToString(resource.meta.segments).trim();
      return value === "true";
    }
    case "integer": {
      const value = parseInt(
        segmentsToString(resource.meta.segments).trim(),
        10
      );
      return Number.isNaN(value) ? 0 : value;
    }
  }
}
function inferTypeFromValue(value) {
  if (typeof value === "string") {
    return "string";
  }
  if (Array.isArray(value)) {
    return "string-array";
  }
  if (value && typeof value === "object") {
    return "plurals";
  }
  if (typeof value === "boolean") {
    return "bool";
  }
  if (typeof value === "number" && Number.isInteger(value)) {
    return "integer";
  }
  throw new CLIError({
    message: "Unable to infer Android resource type from payload",
    docUrl: "androidResouceError"
  });
}
function extractResourceMetadata(xml) {
  const parser = sax.parser(true, {
    trim: false,
    normalize: false,
    lowercase: false
  });
  const stack = [];
  const result = [];
  parser.onopentag = (node) => {
    const lowerName = node.name.toLowerCase();
    const attributes = {};
    for (const [key, value] of Object.entries(node.attributes ?? {})) {
      attributes[key.toLowerCase()] = String(value);
    }
    stack.push({
      name: lowerName,
      rawName: node.name,
      attributes,
      segments: [],
      items: []
    });
    if (lowerName !== "resources" && lowerName !== "item" && !isResourceElementName(lowerName)) {
      const attrString = Object.entries(node.attributes ?? {}).map(
        ([key, value]) => ` ${key}="${escapeAttributeValue(String(value))}"`
      ).join("");
      appendSegmentToNearestResource(stack, {
        kind: "text",
        value: `<${node.name}${attrString}>`
      });
    }
  };
  parser.ontext = (text) => {
    if (!text) {
      return;
    }
    appendSegmentToNearestResource(stack, { kind: "text", value: text });
  };
  parser.oncdata = (cdata) => {
    appendSegmentToNearestResource(stack, { kind: "cdata", value: cdata });
  };
  parser.onclosetag = () => {
    const entry = stack.pop();
    if (!entry) {
      return;
    }
    const parent = stack[stack.length - 1];
    if (entry.name === "item" && parent) {
      const meta = makeTextMeta(entry.segments);
      parent.items.push({
        quantity: entry.attributes.quantity,
        meta
      });
      return;
    }
    if (entry.name !== "resources" && entry.name !== "item" && !isResourceElementName(entry.name)) {
      appendSegmentToNearestResource(stack, {
        kind: "text",
        value: `</${entry.rawName}>`
      });
      return;
    }
    if (!isResourceElementName(entry.name)) {
      return;
    }
    const name = entry.attributes.name;
    if (!name) {
      return;
    }
    const translatable = (entry.attributes.translatable ?? "").toLowerCase() !== "false";
    switch (entry.name) {
      case "string": {
        result.push({
          type: "string",
          name,
          translatable,
          meta: makeTextMeta(entry.segments)
        });
        break;
      }
      case "string-array": {
        result.push({
          type: "string-array",
          name,
          translatable,
          items: entry.items.map((item) => ({
            meta: cloneTextMeta(item.meta)
          }))
        });
        break;
      }
      case "plurals": {
        const items = [];
        for (const item of entry.items) {
          if (!item.quantity) {
            continue;
          }
          items.push({
            quantity: item.quantity,
            meta: cloneTextMeta(item.meta)
          });
        }
        result.push({
          type: "plurals",
          name,
          translatable,
          items
        });
        break;
      }
      case "bool": {
        result.push({
          type: "bool",
          name,
          translatable,
          meta: makeTextMeta(entry.segments)
        });
        break;
      }
      case "integer": {
        result.push({
          type: "integer",
          name,
          translatable,
          meta: makeTextMeta(entry.segments)
        });
        break;
      }
    }
  };
  parser.write(xml).close();
  return result;
}
function appendSegmentToNearestResource(stack, segment) {
  for (let index = stack.length - 1; index >= 0; index--) {
    const entry = stack[index];
    if (entry.name === "string" || entry.name === "item" || entry.name === "bool" || entry.name === "integer") {
      entry.segments.push(segment);
      return;
    }
  }
}
function isResourceElementName(value) {
  return value === "string" || value === "string-array" || value === "plurals" || value === "bool" || value === "integer";
}
function deepClone(value) {
  return value === void 0 ? value : JSON.parse(JSON.stringify(value));
}
function serializeElement(node) {
  if (!node) {
    return "";
  }
  const name = node["#name"] ?? "resources";
  if (name === "__text__") {
    return node._ ?? "";
  }
  if (name === "__cdata") {
    return `<![CDATA[${node._ ?? ""}]]>`;
  }
  if (name === "__comment__") {
    return `<!--${node._ ?? ""}-->`;
  }
  const attributes = node.$ ?? {};
  const attrString = Object.entries(attributes).map(([key, value]) => ` ${key}="${escapeAttributeValue(String(value))}"`).join("");
  const children = Array.isArray(node.$$) ? node.$$ : [];
  if (children.length === 0) {
    const textContent = node._ ?? "";
    return `<${name}${attrString}>${textContent}</${name}>`;
  }
  const childContent = children.map(serializeElement).join("");
  return `<${name}${attrString}>${childContent}</${name}>`;
}
function escapeAttributeValue(value) {
  return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;");
}
function decodeAndroidText(value) {
  return value.replace(/\\'/g, "'");
}

// src/cli/loaders/csv.ts
import { parse as parse2 } from "csv-parse/sync";
import { stringify } from "csv-stringify/sync";
import _8 from "lodash";
function detectKeyColumnName(csvString) {
  const row = parse2(csvString)[0];
  const firstColumn = row?.[0]?.trim();
  return firstColumn || "KEY";
}
function createCsvLoader() {
  return composeLoaders(_createCsvLoader(), createPullOutputCleaner());
}
function _createCsvLoader() {
  return createLoader({
    async pull(locale, input2) {
      const keyColumnName = detectKeyColumnName(
        input2.split("\n").find((l) => l.length)
      );
      const inputParsed = parse2(input2, {
        columns: true,
        skip_empty_lines: true,
        relax_column_count_less: true
      });
      const items = {};
      _8.forEach(inputParsed, (row) => {
        const key = row[keyColumnName];
        if (key && row[locale] && row[locale].trim() !== "") {
          items[key] = row[locale];
        }
      });
      return {
        inputParsed,
        keyColumnName,
        items
      };
    },
    async push(locale, { inputParsed, keyColumnName, items }) {
      const columns = inputParsed.length > 0 ? Object.keys(inputParsed[0]) : [keyColumnName, locale];
      if (!columns.includes(locale)) {
        columns.push(locale);
      }
      const updatedRows = inputParsed.map((row) => ({
        ...row,
        [locale]: items[row[keyColumnName]] || row[locale] || ""
      }));
      const existingKeys = new Set(
        inputParsed.map((row) => row[keyColumnName])
      );
      Object.entries(items).forEach(([key, value]) => {
        if (!existingKeys.has(key)) {
          const newRow = {
            [keyColumnName]: key,
            ...Object.fromEntries(columns.map((column) => [column, ""]))
          };
          newRow[locale] = value;
          updatedRows.push(newRow);
        }
      });
      return stringify(updatedRows, {
        header: true,
        columns
      });
    }
  });
}
function createPullOutputCleaner() {
  return createLoader({
    async pull(_locale, input2) {
      return input2.items;
    },
    async push(_locale, data, _oI, _oL, pullInput) {
      return { ...pullInput, items: data };
    }
  });
}

// src/cli/loaders/html.ts
import { JSDOM } from "jsdom";
function normalizeTextContent(text, isStandalone) {
  const trimmed = text.trim();
  if (!trimmed) return "";
  return trimmed;
}
function createHtmlLoader() {
  const LOCALIZABLE_ATTRIBUTES = {
    meta: ["content"],
    img: ["alt"],
    input: ["placeholder"],
    a: ["title"]
  };
  const UNLOCALIZABLE_TAGS = ["script", "style"];
  return createLoader({
    async pull(locale, input2) {
      const result = {};
      const dom = new JSDOM(input2);
      const document = dom.window.document;
      const getPath = (node, attribute) => {
        const indices = [];
        let current = node;
        let rootParent = "";
        while (current) {
          const parent = current.parentElement;
          if (!parent) break;
          if (parent === document.documentElement) {
            rootParent = current.nodeName.toLowerCase();
            break;
          }
          const siblings = Array.from(parent.childNodes).filter(
            (n) => n.nodeType === 1 || n.nodeType === 3 && n.textContent?.trim()
          );
          const index = siblings.indexOf(current);
          if (index !== -1) {
            indices.unshift(index);
          }
          current = parent;
        }
        const basePath = rootParent ? `${rootParent}/${indices.join("/")}` : indices.join("/");
        return attribute ? `${basePath}#${attribute}` : basePath;
      };
      const processNode = (node) => {
        let parent = node.parentElement;
        while (parent) {
          if (UNLOCALIZABLE_TAGS.includes(parent.tagName.toLowerCase())) {
            return;
          }
          parent = parent.parentElement;
        }
        if (node.nodeType === 3) {
          const text = node.textContent || "";
          const normalizedText = normalizeTextContent(text, true);
          if (normalizedText) {
            result[getPath(node)] = normalizedText;
          }
        } else if (node.nodeType === 1) {
          const element = node;
          const tagName = element.tagName.toLowerCase();
          const attributes = LOCALIZABLE_ATTRIBUTES[tagName] || [];
          attributes.forEach((attr) => {
            const value = element.getAttribute(attr);
            if (value) {
              result[getPath(element, attr)] = value;
            }
          });
          Array.from(element.childNodes).filter(
            (n) => n.nodeType === 1 || n.nodeType === 3 && n.textContent?.trim()
          ).forEach(processNode);
        }
      };
      Array.from(document.head.childNodes).filter(
        (n) => n.nodeType === 1 || n.nodeType === 3 && n.textContent?.trim()
      ).forEach(processNode);
      Array.from(document.body.childNodes).filter(
        (n) => n.nodeType === 1 || n.nodeType === 3 && n.textContent?.trim()
      ).forEach(processNode);
      return result;
    },
    async push(locale, data, originalInput) {
      const dom = new JSDOM(
        originalInput ?? "<!DOCTYPE html><html><head></head><body></body></html>"
      );
      const document = dom.window.document;
      const htmlElement = document.documentElement;
      htmlElement.setAttribute("lang", locale);
      const paths = Object.keys(data).sort((a, b) => {
        const aDepth = a.split("/").length;
        const bDepth = b.split("/").length;
        return aDepth - bDepth;
      });
      paths.forEach((path19) => {
        const value = data[path19];
        const [nodePath, attribute] = path19.split("#");
        const [rootTag, ...indices] = nodePath.split("/");
        let parent = rootTag === "head" ? document.head : document.body;
        let current = parent;
        for (let i = 0; i < indices.length; i++) {
          const index = parseInt(indices[i]);
          const siblings = Array.from(parent.childNodes).filter(
            (n) => n.nodeType === 1 || n.nodeType === 3 && n.textContent?.trim()
          );
          if (index >= siblings.length) {
            if (i === indices.length - 1) {
              const textNode = document.createTextNode("");
              parent.appendChild(textNode);
              current = textNode;
            } else {
              const element = document.createElement("div");
              parent.appendChild(element);
              current = element;
              parent = element;
            }
          } else {
            current = siblings[index];
            if (current.nodeType === 1) {
              parent = current;
            }
          }
        }
        if (current) {
          if (attribute) {
            current.setAttribute(attribute, value);
          } else {
            current.textContent = value;
          }
        }
      });
      return dom.serialize();
    }
  });
}

// src/cli/loaders/markdown.ts
import matter from "gray-matter";
import YAML2 from "yaml";
var SECTION_REGEX = /^(#{1,6}\s.*$|[-=*]{3,}$|!\[.*\]\(.*\)$|\[.*\]\(.*\)$)/gm;
var MD_SECTION_PREFIX = "md-section-";
var FM_ATTR_PREFIX = "fm-attr-";
var yamlEngine = {
  parse: (str) => YAML2.parse(str),
  stringify: (obj) => YAML2.stringify(obj, { defaultStringType: "PLAIN" })
};
function createMarkdownLoader() {
  return createLoader({
    async pull(locale, input2) {
      const { data: frontmatter, content } = matter(input2, {
        engines: {
          yaml: yamlEngine
        }
      });
      const sections = content.split(SECTION_REGEX).map((section) => section?.trim() ?? "").filter(Boolean);
      return {
        ...Object.fromEntries(
          sections.map((section, index) => [`${MD_SECTION_PREFIX}${index}`, section]).filter(([, section]) => Boolean(section))
        ),
        ...Object.fromEntries(
          Object.entries(frontmatter).map(([key, value]) => [
            `${FM_ATTR_PREFIX}${key}`,
            value
          ])
        )
      };
    },
    async push(locale, data) {
      const frontmatter = Object.fromEntries(
        Object.entries(data).filter(([key]) => key.startsWith(FM_ATTR_PREFIX)).map(([key, value]) => [key.replace(FM_ATTR_PREFIX, ""), value])
      );
      let content = Object.entries(data).filter(([key]) => key.startsWith(MD_SECTION_PREFIX)).sort(
        ([a], [b]) => Number(a.split("-").pop()) - Number(b.split("-").pop())
      ).map(([, value]) => value?.trim() ?? "").filter(Boolean).join("\n\n");
      if (Object.keys(frontmatter).length > 0) {
        content = `
${content}`;
      }
      return matter.stringify(content, frontmatter, {
        engines: {
          yaml: yamlEngine
        }
      });
    }
  });
}

// src/cli/loaders/markdoc.ts
import Markdoc from "@markdoc/markdoc";
import YAML3 from "yaml";
var FM_ATTR_PREFIX2 = "fm-attr-";
function createMarkdocLoader() {
  return createLoader({
    async pull(locale, input2) {
      const ast = Markdoc.parse(input2);
      const result = {};
      const counters = {};
      traverseAndExtract(ast, "", result, counters);
      if (ast.attributes?.frontmatter) {
        const frontmatter = YAML3.parse(ast.attributes.frontmatter);
        Object.entries(frontmatter).forEach(([key, value]) => {
          if (typeof value === "string") {
            result[`${FM_ATTR_PREFIX2}${key}`] = value;
          }
        });
      }
      return result;
    },
    async push(locale, data, originalInput) {
      if (!originalInput) {
        throw new Error("Original input is required for push");
      }
      const ast = Markdoc.parse(originalInput);
      const counters = {};
      const pathMap = {};
      buildPathMap(ast, "", counters, pathMap);
      const frontmatterEntries = Object.entries(data).filter(([key]) => key.startsWith(FM_ATTR_PREFIX2)).map(([key, value]) => [key.replace(FM_ATTR_PREFIX2, ""), value]);
      if (frontmatterEntries.length > 0 && ast.attributes) {
        const frontmatter = Object.fromEntries(frontmatterEntries);
        ast.attributes.frontmatter = YAML3.stringify(frontmatter, {
          defaultStringType: "PLAIN"
        }).trim();
      }
      const contentData = Object.fromEntries(
        Object.entries(data).filter(([key]) => !key.startsWith(FM_ATTR_PREFIX2))
      );
      applyTranslations(ast, "", contentData, pathMap);
      return Markdoc.format(ast);
    }
  });
}
function getSemanticNodeType(node) {
  if (node.type === "tag") return node.tag || "tag";
  return node.type;
}
function traverseAndExtract(node, path19, result, counters, parentType) {
  if (!node || typeof node !== "object") {
    return;
  }
  let semanticType = parentType;
  const nodeSemanticType = getSemanticNodeType(node);
  if (nodeSemanticType && !["text", "strong", "em", "inline", "link"].includes(nodeSemanticType)) {
    semanticType = nodeSemanticType;
  }
  if (node.type === "text" && node.attributes?.content) {
    const content = node.attributes.content;
    if (typeof content === "string" && content.trim()) {
      if (semanticType) {
        const index = counters[semanticType] || 0;
        counters[semanticType] = index + 1;
        const semanticKey = `${semanticType}-${index}`;
        result[semanticKey] = content;
      }
    }
  }
  if (Array.isArray(node.children)) {
    node.children.forEach((child, index) => {
      const childPath = path19 ? `${path19}/children/${index}` : `children/${index}`;
      traverseAndExtract(child, childPath, result, counters, semanticType);
    });
  }
}
function buildPathMap(node, path19, counters, pathMap, parentType) {
  if (!node || typeof node !== "object") {
    return;
  }
  let semanticType = parentType;
  const nodeSemanticType = getSemanticNodeType(node);
  if (nodeSemanticType && !["text", "strong", "em", "inline", "link"].includes(nodeSemanticType)) {
    semanticType = nodeSemanticType;
  }
  if (node.type === "text" && node.attributes?.content) {
    const content = node.attributes.content;
    if (typeof content === "string" && content.trim()) {
      if (semanticType) {
        const index = counters[semanticType] || 0;
        counters[semanticType] = index + 1;
        const semanticKey = `${semanticType}-${index}`;
        const contentPath = path19 ? `${path19}/attributes/content` : "attributes/content";
        pathMap[semanticKey] = contentPath;
      }
    }
  }
  if (Array.isArray(node.children)) {
    node.children.forEach((child, index) => {
      const childPath = path19 ? `${path19}/children/${index}` : `children/${index}`;
      buildPathMap(child, childPath, counters, pathMap, semanticType);
    });
  }
}
function applyTranslations(node, path19, data, pathMap) {
  if (!node || typeof node !== "object") {
    return;
  }
  if (node.type === "text" && node.attributes?.content) {
    const content = node.attributes.content;
    if (typeof content === "string") {
      const contentPath = path19 ? `${path19}/attributes/content` : "attributes/content";
      const semanticKey = Object.keys(pathMap).find(
        (key) => pathMap[key] === contentPath
      );
      if (semanticKey && data[semanticKey] !== void 0) {
        node.attributes.content = data[semanticKey];
      }
    }
  }
  if (Array.isArray(node.children)) {
    node.children.forEach((child, index) => {
      const childPath = path19 ? `${path19}/children/${index}` : `children/${index}`;
      applyTranslations(child, childPath, data, pathMap);
    });
  }
}

// src/cli/loaders/properties.ts
function createPropertiesLoader() {
  return createLoader({
    async pull(locale, text) {
      const result = {};
      const lines = text.split("\n");
      for (const line of lines) {
        const trimmed = line.trim();
        if (isSkippableLine(trimmed)) {
          continue;
        }
        const { key, value } = parsePropertyLine(trimmed);
        if (key) {
          result[key] = value;
        }
      }
      return result;
    },
    async push(locale, payload) {
      const result = Object.entries(payload).filter(([_36, value]) => value != null).map(([key, value]) => `${key}=${value}`).join("\n");
      return result;
    }
  });
}
function isSkippableLine(line) {
  return !line || line.startsWith("#");
}
function parsePropertyLine(line) {
  const [key, ...valueParts] = line.split("=");
  return {
    key: key?.trim() || "",
    value: valueParts.join("=").trim()
  };
}

// src/cli/loaders/xcode-strings/tokenizer.ts
var Tokenizer = class {
  input;
  pos;
  line;
  column;
  constructor(input2) {
    this.input = input2;
    this.pos = 0;
    this.line = 1;
    this.column = 1;
  }
  tokenize() {
    const tokens = [];
    while (this.pos < this.input.length) {
      const char = this.current();
      if (this.isWhitespace(char)) {
        this.advance();
        continue;
      }
      if (char === "/" && this.peek() === "/") {
        tokens.push(this.scanSingleLineComment());
        continue;
      }
      if (char === "/" && this.peek() === "*") {
        tokens.push(this.scanMultiLineComment());
        continue;
      }
      if (char === '"') {
        tokens.push(this.scanString());
        continue;
      }
      if (char === "=") {
        tokens.push(this.makeToken("EQUALS" /* EQUALS */, "="));
        this.advance();
        continue;
      }
      if (char === ";") {
        tokens.push(this.makeToken("SEMICOLON" /* SEMICOLON */, ";"));
        this.advance();
        continue;
      }
      this.advance();
    }
    tokens.push(this.makeToken("EOF" /* EOF */, ""));
    return tokens;
  }
  scanString() {
    const start = this.getPosition();
    let value = "";
    this.advance();
    while (this.pos < this.input.length) {
      const char = this.current();
      if (char === "\\") {
        this.advance();
        if (this.pos < this.input.length) {
          const nextChar = this.current();
          value += "\\" + nextChar;
          this.advance();
        }
        continue;
      }
      if (char === '"') {
        this.advance();
        return {
          type: "STRING" /* STRING */,
          value,
          ...start
        };
      }
      value += char;
      this.advance();
    }
    return {
      type: "STRING" /* STRING */,
      value,
      ...start
    };
  }
  scanSingleLineComment() {
    const start = this.getPosition();
    let value = "";
    this.advance();
    this.advance();
    while (this.pos < this.input.length && this.current() !== "\n") {
      value += this.current();
      this.advance();
    }
    return {
      type: "COMMENT_SINGLE" /* COMMENT_SINGLE */,
      value,
      ...start
    };
  }
  scanMultiLineComment() {
    const start = this.getPosition();
    let value = "";
    this.advance();
    this.advance();
    while (this.pos < this.input.length) {
      if (this.current() === "*" && this.peek() === "/") {
        this.advance();
        this.advance();
        return {
          type: "COMMENT_MULTI" /* COMMENT_MULTI */,
          value,
          ...start
        };
      }
      value += this.current();
      this.advance();
    }
    return {
      type: "COMMENT_MULTI" /* COMMENT_MULTI */,
      value,
      ...start
    };
  }
  current() {
    return this.input[this.pos];
  }
  peek() {
    if (this.pos + 1 < this.input.length) {
      return this.input[this.pos + 1];
    }
    return null;
  }
  advance() {
    if (this.pos < this.input.length) {
      if (this.current() === "\n") {
        this.line++;
        this.column = 1;
      } else {
        this.column++;
      }
      this.pos++;
    }
  }
  isWhitespace(char) {
    return char === " " || char === "	" || char === "\n" || char === "\r";
  }
  getPosition() {
    return {
      line: this.line,
      column: this.column
    };
  }
  makeToken(type, value) {
    return {
      type,
      value,
      ...this.getPosition()
    };
  }
};

// src/cli/loaders/xcode-strings/escape.ts
function unescapeString(raw) {
  let result = "";
  let i = 0;
  while (i < raw.length) {
    if (raw[i] === "\\" && i + 1 < raw.length) {
      const nextChar = raw[i + 1];
      switch (nextChar) {
        case '"':
          result += '"';
          i += 2;
          break;
        case "\\":
          result += "\\";
          i += 2;
          break;
        case "n":
          result += "\n";
          i += 2;
          break;
        case "t":
          result += "	";
          i += 2;
          break;
        case "r":
          result += "\r";
          i += 2;
          break;
        default:
          result += raw[i];
          i++;
          break;
      }
    } else {
      result += raw[i];
      i++;
    }
  }
  return result;
}
function escapeString(str) {
  if (str == null) {
    return "";
  }
  let result = "";
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    switch (char) {
      case "\\":
        result += "\\\\";
        break;
      case '"':
        result += '\\"';
        break;
      case "\n":
        result += "\\n";
        break;
      case "\r":
        result += "\\r";
        break;
      case "	":
        result += "\\t";
        break;
      default:
        result += char;
        break;
    }
  }
  return result;
}

// src/cli/loaders/xcode-strings/parser.ts
var Parser = class {
  tokens;
  pos;
  constructor(tokens) {
    this.tokens = tokens;
    this.pos = 0;
  }
  parse() {
    const result = {};
    while (this.pos < this.tokens.length) {
      const token = this.current();
      if (token.type === "COMMENT_SINGLE" /* COMMENT_SINGLE */ || token.type === "COMMENT_MULTI" /* COMMENT_MULTI */) {
        this.advance();
        continue;
      }
      if (token.type === "EOF" /* EOF */) {
        break;
      }
      if (token.type === "STRING" /* STRING */) {
        const entry = this.parseEntry();
        if (entry) {
          result[entry.key] = entry.value;
        }
        continue;
      }
      this.advance();
    }
    return result;
  }
  parseEntry() {
    const keyToken = this.current();
    if (keyToken.type !== "STRING" /* STRING */) {
      return null;
    }
    const key = keyToken.value;
    this.advance();
    if (!this.expect("EQUALS" /* EQUALS */)) {
      return null;
    }
    const valueToken = this.current();
    if (valueToken.type !== "STRING" /* STRING */) {
      return null;
    }
    const rawValue = valueToken.value;
    this.advance();
    if (!this.expect("SEMICOLON" /* SEMICOLON */)) {
    }
    const value = unescapeString(rawValue);
    return { key, value };
  }
  current() {
    return this.tokens[this.pos];
  }
  advance() {
    if (this.pos < this.tokens.length) {
      this.pos++;
    }
  }
  expect(type) {
    if (this.current()?.type === type) {
      this.advance();
      return true;
    }
    return false;
  }
};

// src/cli/loaders/xcode-strings.ts
function createXcodeStringsLoader() {
  return createLoader({
    async pull(locale, input2) {
      const tokenizer = new Tokenizer(input2);
      const tokens = tokenizer.tokenize();
      const parser = new Parser(tokens);
      const result = parser.parse();
      return result;
    },
    async push(locale, payload) {
      const lines = Object.entries(payload).filter(([_36, value]) => value != null).map(([key, value]) => {
        const escapedValue = escapeString(value);
        return `"${key}" = "${escapedValue}";`;
      });
      return lines.join("\n");
    }
  });
}

// src/cli/loaders/xcode-stringsdict.ts
import plist from "plist";
var emptyData = [
  '<?xml version="1.0" encoding="UTF-8"?>',
  '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
  '<plist version="1.0">',
  "<dict/>",
  "</plist>"
].join("\n");
function createXcodeStringsdictLoader() {
  return createLoader({
    async pull(locale, input2) {
      try {
        const parsed = plist.parse(input2 || emptyData);
        if (typeof parsed !== "object" || parsed === null) {
          throw new CLIError({
            message: "Invalid .stringsdict format",
            docUrl: "invalidStringDict"
          });
        }
        return parsed;
      } catch (error) {
        throw new CLIError({
          message: `Invalid .stringsdict format: ${error.message}`,
          docUrl: "invalidStringDict"
        });
      }
    },
    async push(locale, payload) {
      const plistContent = plist.build(payload);
      return plistContent;
    }
  });
}

// src/cli/loaders/xcode-xcstrings.ts
import _9 from "lodash";
function createXcodeXcstringsLoader(defaultLocale) {
  return createLoader({
    async pull(locale, input2, initCtx) {
      const resultData = {};
      const isSourceLanguage = locale === defaultLocale;
      for (const [translationKey, _translationEntity] of Object.entries(
        input2.strings
      )) {
        const rootTranslationEntity = _translationEntity;
        if (rootTranslationEntity.shouldTranslate === false) {
          continue;
        }
        const langTranslationEntity = rootTranslationEntity?.localizations?.[locale];
        if (langTranslationEntity) {
          if ("stringUnit" in langTranslationEntity) {
            resultData[translationKey] = langTranslationEntity.stringUnit.value;
          } else if ("variations" in langTranslationEntity) {
            if ("plural" in langTranslationEntity.variations) {
              resultData[translationKey] = {};
              const pluralForms = langTranslationEntity.variations.plural;
              for (const form in pluralForms) {
                if (pluralForms[form]?.stringUnit?.value) {
                  resultData[translationKey][form] = pluralForms[form].stringUnit.value;
                }
              }
            }
          }
        } else if (isSourceLanguage) {
          resultData[translationKey] = translationKey;
        }
      }
      return resultData;
    },
    async push(locale, payload, originalInput) {
      const langDataToMerge = {};
      langDataToMerge.strings = {};
      const input2 = _9.cloneDeep(originalInput) || {
        sourceLanguage: locale,
        strings: {}
      };
      for (const [key, value] of Object.entries(payload)) {
        if (value === null || value === void 0) {
          continue;
        }
        const hasDoNotTranslateFlag = originalInput && originalInput.strings && originalInput.strings[key] && originalInput.strings[key].shouldTranslate === false;
        if (typeof value === "string") {
          langDataToMerge.strings[key] = {
            extractionState: originalInput?.strings?.[key]?.extractionState,
            localizations: {
              [locale]: {
                stringUnit: {
                  state: "translated",
                  value
                }
              }
            }
          };
          if (hasDoNotTranslateFlag) {
            langDataToMerge.strings[key].shouldTranslate = false;
          }
        } else {
          const updatedVariations = {};
          for (const form in value) {
            updatedVariations[form] = {
              stringUnit: {
                state: "translated",
                value: value[form]
              }
            };
          }
          langDataToMerge.strings[key] = {
            extractionState: "manual",
            localizations: {
              [locale]: {
                variations: {
                  plural: updatedVariations
                }
              }
            }
          };
          if (hasDoNotTranslateFlag) {
            langDataToMerge.strings[key].shouldTranslate = false;
          }
        }
      }
      const originalInputWithoutLocale = originalInput ? _removeLocale(originalInput, locale) : {};
      const result = _9.merge({}, originalInputWithoutLocale, langDataToMerge);
      return result;
    },
    async pullHints(originalInput) {
      if (!originalInput || !originalInput.strings) {
        return {};
      }
      const hints = {};
      for (const [translationKey, translationEntity] of Object.entries(
        originalInput.strings
      )) {
        const entity = translationEntity;
        if (entity.comment && typeof entity.comment === "string") {
          hints[translationKey] = { hint: entity.comment };
        }
        if (entity.localizations) {
          for (const [locale, localization] of Object.entries(
            entity.localizations
          )) {
            if (localization.variations?.plural) {
              const pluralForms = localization.variations.plural;
              for (const form in pluralForms) {
                const pluralKey = `${translationKey}/${form}`;
                if (entity.comment && typeof entity.comment === "string") {
                  hints[pluralKey] = { hint: entity.comment };
                }
              }
            }
          }
        }
      }
      return hints;
    }
  });
}
function _removeLocale(input2, locale) {
  const { strings } = input2;
  const newStrings = _9.cloneDeep(strings);
  for (const [key, value] of Object.entries(newStrings)) {
    if (value.localizations?.[locale]) {
      delete value.localizations[locale];
    }
  }
  return { ...input2, strings: newStrings };
}

// src/cli/loaders/xcode-xcstrings-icu.ts
var ICU_TYPE_MARKER = Symbol.for("@lingo.dev/icu-plural-object");
var CLDR_PLURAL_CATEGORIES = /* @__PURE__ */ new Set([
  "zero",
  "one",
  "two",
  "few",
  "many",
  "other"
]);
function isICUPluralObject(value) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  if (ICU_TYPE_MARKER in value) {
    return true;
  }
  if (!("icu" in value) || typeof value.icu !== "string") {
    return false;
  }
  const icuPluralPattern = /^\{[\w]+,\s*plural,\s*.+\}$/;
  if (!icuPluralPattern.test(value.icu)) {
    return false;
  }
  if (value._meta !== void 0) {
    if (typeof value._meta !== "object" || !value._meta.variables || typeof value._meta.variables !== "object") {
      return false;
    }
    for (const [varName, varMeta] of Object.entries(value._meta.variables)) {
      if (!varMeta || typeof varMeta !== "object" || typeof varMeta.format !== "string" || varMeta.role !== "plural" && varMeta.role !== "other") {
        return false;
      }
    }
  }
  return true;
}
function isPluralFormsObject(value) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  const keys = Object.keys(value);
  if (keys.length === 0) {
    return false;
  }
  const allKeysAreCldr = keys.every((key) => CLDR_PLURAL_CATEGORIES.has(key));
  if (!allKeysAreCldr) {
    return false;
  }
  const allValuesAreStrings = keys.every(
    (key) => typeof value[key] === "string"
  );
  if (!allValuesAreStrings) {
    return false;
  }
  if (!("other" in value)) {
    return false;
  }
  return true;
}
function getRequiredPluralCategories(locale) {
  try {
    const pluralRules = new Intl.PluralRules(locale);
    const categories = pluralRules.resolvedOptions().pluralCategories;
    if (!categories || categories.length === 0) {
      throw new Error(`No plural categories found for locale: ${locale}`);
    }
    return categories;
  } catch (error) {
    console.warn(
      `[xcode-xcstrings-icu] Failed to resolve plural categories for locale "${locale}". Using fallback ["one", "other"]. Error: ${error instanceof Error ? error.message : String(error)}`
    );
    return ["one", "other"];
  }
}
var CLDR_CATEGORY_TO_NUMBER = {
  zero: 0,
  one: 1,
  two: 2
};
var NUMBER_TO_CLDR_CATEGORY = {
  0: "zero",
  1: "one",
  2: "two"
};
function xcstringsToPluralWithMeta(pluralForms, sourceLocale = "en") {
  if (!pluralForms || Object.keys(pluralForms).length === 0) {
    throw new Error("pluralForms cannot be empty");
  }
  const requiredCategories = getRequiredPluralCategories(sourceLocale);
  const variables = {};
  const formatRegex = /(%(?:(\d+)\$)?(?:[+-])?(?:\d+)?(?:\.(\d+))?([lhqLzjt]*)([diuoxXfFeEgGaAcspn@]))/g;
  let maxMatches = [];
  let maxMatchText = "";
  for (const [form, text] of Object.entries(pluralForms)) {
    if (typeof text !== "string") {
      console.warn(
        `Warning: Plural form "${form}" has non-string value:`,
        text
      );
      continue;
    }
    const matches = [...text.matchAll(formatRegex)];
    if (matches.length > maxMatches.length) {
      maxMatches = matches;
      maxMatchText = text;
    }
  }
  let lastNumericIndex = -1;
  maxMatches.forEach((match2, idx) => {
    const specifier = match2[5];
    if (/[diuoxXfFeE]/.test(specifier)) {
      lastNumericIndex = idx;
    }
  });
  let nonPluralCounter = 0;
  maxMatches.forEach((match2, idx) => {
    const fullFormat = match2[1];
    const position = match2[2];
    const precision = match2[3];
    const lengthMod = match2[4];
    const specifier = match2[5];
    const isPluralVar = idx === lastNumericIndex;
    const varName = isPluralVar ? "count" : `var${nonPluralCounter++}`;
    variables[varName] = {
      format: fullFormat,
      role: isPluralVar ? "plural" : "other"
    };
  });
  const variableKeys = Object.keys(variables);
  const icuForms = Object.entries(pluralForms).filter(([form, text]) => {
    if (typeof text !== "string") {
      return false;
    }
    return true;
  }).map(([form, text]) => {
    let processed = text;
    let vIdx = 0;
    processed = processed.replace(formatRegex, () => {
      if (vIdx >= variableKeys.length) {
        vIdx++;
        return "#";
      }
      const varName = variableKeys[vIdx];
      const varMeta = variables[varName];
      vIdx++;
      if (varMeta.role === "plural") {
        return "#";
      } else {
        return `{${varName}}`;
      }
    });
    const isRequired = requiredCategories.includes(form);
    const formKey = !isRequired && form in CLDR_CATEGORY_TO_NUMBER ? `=${CLDR_CATEGORY_TO_NUMBER[form]}` : form;
    return `${formKey} {${processed}}`;
  }).join(" ");
  const pluralVarName = Object.keys(variables).find((name) => variables[name].role === "plural") || "count";
  const icu = `{${pluralVarName}, plural, ${icuForms}}`;
  const result = {
    icu,
    _meta: Object.keys(variables).length > 0 ? { variables } : void 0,
    [ICU_TYPE_MARKER]: true
    // Add type marker for robust detection
  };
  return result;
}
function pluralWithMetaToXcstrings(data) {
  if (!data.icu) {
    throw new Error("ICU string is required");
  }
  const ast = parseICU(data.icu);
  if (!ast || ast.length === 0) {
    throw new Error("Invalid ICU format");
  }
  const pluralNode = ast.find((node) => node.type === "plural");
  if (!pluralNode) {
    throw new Error("No plural found in ICU format");
  }
  const forms = {};
  for (const [form, option] of Object.entries(pluralNode.options)) {
    let text = "";
    const optionValue = option.value;
    for (const element of optionValue) {
      if (element.type === "literal") {
        text += element.value;
      } else if (element.type === "pound") {
        const pluralVar = Object.entries(data._meta?.variables || {}).find(
          ([_36, meta]) => meta.role === "plural"
        );
        text += pluralVar?.[1].format || "%lld";
      } else if (element.type === "argument") {
        const varName = element.value;
        const varMeta = data._meta?.variables?.[varName];
        text += varMeta?.format || "%@";
      }
    }
    let xcstringsFormName = form;
    if (form.startsWith("=")) {
      const numValue = parseInt(form.substring(1), 10);
      xcstringsFormName = NUMBER_TO_CLDR_CATEGORY[numValue] || form;
    }
    forms[xcstringsFormName] = text;
  }
  return forms;
}
function parseICU(icu) {
  const match2 = icu.match(/\{(\w+),\s*plural,\s*(.+)\}$/);
  if (!match2) {
    throw new Error("Invalid ICU plural format");
  }
  const varName = match2[1];
  const formsText = match2[2];
  const options = {};
  let i = 0;
  while (i < formsText.length) {
    while (i < formsText.length && /\s/.test(formsText[i])) {
      i++;
    }
    if (i >= formsText.length) break;
    let formName = "";
    if (formsText[i] === "=") {
      formName += formsText[i];
      i++;
      while (i < formsText.length && /\d/.test(formsText[i])) {
        formName += formsText[i];
        i++;
      }
    } else {
      while (i < formsText.length && /\w/.test(formsText[i])) {
        formName += formsText[i];
        i++;
      }
    }
    if (!formName) break;
    while (i < formsText.length && /\s/.test(formsText[i])) {
      i++;
    }
    if (i >= formsText.length || formsText[i] !== "{") {
      throw new Error(`Expected '{' after form name '${formName}'`);
    }
    i++;
    let braceCount = 1;
    let formText = "";
    while (i < formsText.length && braceCount > 0) {
      if (formsText[i] === "{") {
        braceCount++;
        formText += formsText[i];
      } else if (formsText[i] === "}") {
        braceCount--;
        if (braceCount > 0) {
          formText += formsText[i];
        }
      } else {
        formText += formsText[i];
      }
      i++;
    }
    if (braceCount !== 0) {
      const preview = formsText.substring(
        Math.max(0, i - 50),
        Math.min(formsText.length, i + 50)
      );
      throw new Error(
        `Unclosed brace for form '${formName}' in ICU MessageFormat.
Expected ${braceCount} more closing brace(s).
Context: ...${preview}...
Full ICU: {${varName}, plural, ${formsText}}`
      );
    }
    const elements = parseFormText(formText);
    options[formName] = {
      value: elements
    };
  }
  return [
    {
      type: "plural",
      value: varName,
      options
    }
  ];
}
function parseFormText(text) {
  const elements = [];
  let currentText = "";
  let i = 0;
  while (i < text.length) {
    if (text[i] === "#") {
      if (currentText) {
        elements.push({ type: "literal", value: currentText });
        currentText = "";
      }
      elements.push({ type: "pound" });
      i++;
    } else if (text[i] === "{") {
      if (currentText) {
        elements.push({ type: "literal", value: currentText });
        currentText = "";
      }
      let braceCount = 1;
      let j = i + 1;
      while (j < text.length && braceCount > 0) {
        if (text[j] === "{") {
          braceCount++;
        } else if (text[j] === "}") {
          braceCount--;
        }
        j++;
      }
      if (braceCount !== 0) {
        throw new Error("Unclosed variable reference");
      }
      const varName = text.slice(i + 1, j - 1);
      elements.push({ type: "argument", value: varName });
      i = j;
    } else {
      currentText += text[i];
      i++;
    }
  }
  if (currentText) {
    elements.push({ type: "literal", value: currentText });
  }
  return elements;
}

// src/cli/loaders/xcode-xcstrings-v2-loader.ts
function createXcodeXcstringsV2Loader(defaultLocale = "en") {
  return createLoader({
    async pull(locale, input2) {
      const result = {};
      for (const [key, value] of Object.entries(input2)) {
        if (isPluralFormsObject(value)) {
          try {
            result[key] = xcstringsToPluralWithMeta(value, locale);
          } catch (error) {
            console.error(
              `
[xcode-xcstrings-icu] Failed to convert plural forms for key "${key}":`,
              `
Error: ${error instanceof Error ? error.message : String(error)}`,
              `
Locale: ${locale}
`
            );
            result[key] = value;
          }
        } else {
          result[key] = value;
        }
      }
      return result;
    },
    async push(locale, payload) {
      const result = {};
      for (const [key, value] of Object.entries(payload)) {
        if (isICUPluralObject(value)) {
          try {
            const pluralForms = pluralWithMetaToXcstrings(value);
            result[key] = pluralForms;
          } catch (error) {
            throw new Error(
              `Failed to write plural translation for key "${key}" (locale: ${locale}).
${error instanceof Error ? error.message : String(error)}`
            );
          }
        } else {
          result[key] = value;
        }
      }
      return result;
    }
  });
}

// src/cli/loaders/unlocalizable.ts
import _10 from "lodash";
import _isUrl from "is-url";
import { isValid, parseISO } from "date-fns";
function createUnlocalizableLoader(returnUnlocalizedKeys = false) {
  return createLoader({
    async pull(locale, input2) {
      const unlocalizableKeys = _getUnlocalizableKeys(input2);
      const result = _10.omitBy(
        input2,
        (_36, key) => unlocalizableKeys.includes(key)
      );
      if (returnUnlocalizedKeys) {
        result.unlocalizable = _10.omitBy(
          input2,
          (_36, key) => !unlocalizableKeys.includes(key)
        );
      }
      return result;
    },
    async push(locale, data, originalInput) {
      const unlocalizableKeys = _getUnlocalizableKeys(originalInput);
      const result = _10.merge(
        {},
        data,
        _10.omitBy(originalInput, (_36, key) => !unlocalizableKeys.includes(key))
      );
      return result;
    }
  });
}
function _isSystemId(v) {
  return /^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)[A-Za-z0-9]{22}$/.test(v);
}
function _isIsoDate(v) {
  return isValid(parseISO(v));
}
function _getUnlocalizableKeys(input2) {
  const rules = {
    isEmpty: (v) => _10.isEmpty(v),
    isNumber: (v) => typeof v === "number" || /^[0-9]+$/.test(v),
    isBoolean: (v) => _10.isBoolean(v),
    isIsoDate: (v) => _10.isString(v) && _isIsoDate(v),
    isSystemId: (v) => _10.isString(v) && _isSystemId(v),
    isUrl: (v) => _10.isString(v) && _isUrl(v)
  };
  if (!input2) {
    return [];
  }
  return Object.entries(input2).filter(([key, value]) => {
    for (const [ruleName, rule] of Object.entries(rules)) {
      if (rule(value)) {
        return true;
      }
    }
    return false;
  }).map(([key, _36]) => key);
}

// src/cli/loaders/formatters/prettier.ts
import prettier from "prettier";

// src/cli/loaders/formatters/_base.ts
import path11 from "path";
function createBaseFormatterLoader(options, formatFn) {
  const stage = options.stage || "both";
  const formatData = async (locale, data) => {
    const draftPath = options.bucketPathPattern.replaceAll("[locale]", locale);
    const finalPath = path11.resolve(draftPath);
    return await formatFn(data, finalPath);
  };
  return createLoader({
    async pull(locale, data) {
      if (!["pull", "both"].includes(stage)) {
        return data;
      }
      return await formatData(locale, data);
    },
    async push(locale, data) {
      if (!["push", "both"].includes(stage)) {
        return data;
      }
      return await formatData(locale, data);
    }
  });
}

// src/cli/loaders/formatters/prettier.ts
function createPrettierLoader(options) {
  return createBaseFormatterLoader(options, async (data, filePath) => {
    return await formatDataWithPrettier(data, filePath, options);
  });
}
async function loadPrettierConfig(filePath) {
  try {
    const config = await prettier.resolveConfig(filePath);
    return config;
  } catch (error) {
    return {};
  }
}
async function formatDataWithPrettier(data, filePath, options) {
  const prettierConfig = await loadPrettierConfig(filePath);
  if (!prettierConfig && !options.alwaysFormat) {
    return data;
  }
  const config = {
    ...prettierConfig || { printWidth: 2500, bracketSameLine: false },
    parser: options.parser,
    // For HTML parser, preserve comments and quotes
    ...options.parser === "html" ? {
      htmlWhitespaceSensitivity: "ignore",
      singleQuote: false,
      embeddedLanguageFormatting: "off"
    } : {}
  };
  try {
    return await prettier.format(data, config);
  } catch (error) {
    if (error instanceof Error && error.message.startsWith("Cannot find package")) {
      console.log();
      console.log(
        "\u26A0\uFE0F  Prettier plugins are not installed. Formatting without plugins."
      );
      console.log(
        "\u26A0\uFE0F  To use prettier plugins install project dependencies before running Lingo.dev."
      );
      config.plugins = [];
      await prettier.clearConfigCache();
      return await prettier.format(data, config);
    }
    throw error;
  }
}

// src/cli/loaders/formatters/biome.ts
import path12 from "path";
import fs9 from "fs/promises";
import { Biome, Distribution } from "@biomejs/js-api";
import { parse as parseJsonc } from "jsonc-parser";
function createBiomeLoader(options) {
  return createBaseFormatterLoader(options, async (data, filePath) => {
    return await formatDataWithBiome(data, filePath, options);
  });
}
async function findBiomeConfig(startPath) {
  let currentDir = path12.dirname(startPath);
  const root = path12.parse(currentDir).root;
  while (currentDir !== root) {
    for (const configName of ["biome.json", "biome.jsonc"]) {
      const configPath = path12.join(currentDir, configName);
      try {
        await fs9.access(configPath);
        return configPath;
      } catch {
      }
    }
    const parentDir = path12.dirname(currentDir);
    if (parentDir === currentDir) break;
    currentDir = parentDir;
  }
  return null;
}
async function formatDataWithBiome(data, filePath, options) {
  let configPath = null;
  try {
    const biome = await Biome.create({
      distribution: Distribution.NODE
    });
    const openResult = biome.openProject(".");
    const projectKey = openResult.projectKey;
    configPath = await findBiomeConfig(filePath);
    if (!configPath && !options.alwaysFormat) {
      console.log();
      console.log(
        `\u26A0\uFE0F  Biome config not found for ${path12.basename(filePath)} - skipping formatting`
      );
      return data;
    }
    if (configPath) {
      const configContent = await fs9.readFile(configPath, "utf-8");
      try {
        const config = parseJsonc(configContent);
        const { $schema, vcs, files, ...relevantConfig } = config;
        biome.applyConfiguration(projectKey, relevantConfig);
      } catch (parseError) {
        throw new Error(
          `Invalid Biome configuration in ${configPath}: ${parseError instanceof Error ? parseError.message : "JSON parse error"}`
        );
      }
    }
    const formatted = biome.formatContent(projectKey, data, {
      filePath
    });
    return formatted.content;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message || error.stackTrace?.toString().split("\n")[0] : "";
    if (errorMessage?.includes("does not exist in the workspace")) {
    } else {
      console.log(`\u26A0\uFE0F  Biome skipped ${path12.basename(filePath)}`);
      if (errorMessage) {
        console.log(`   ${errorMessage}`);
      }
    }
    return data;
  }
}

// src/cli/loaders/formatters/index.ts
function createFormatterLoader(formatterType, parser, bucketPathPattern) {
  if (formatterType === void 0) {
    return createPrettierLoader({ parser, bucketPathPattern });
  }
  if (formatterType === "prettier") {
    return createPrettierLoader({ parser, bucketPathPattern });
  }
  if (formatterType === "biome") {
    return createBiomeLoader({ bucketPathPattern });
  }
  throw new Error(`Unknown formatter: ${formatterType}`);
}

// src/cli/loaders/po/index.ts
import _11 from "lodash";
import gettextParser from "gettext-parser";
function createPoLoader(params = { multiline: false }) {
  return composeLoaders(createPoDataLoader(params), createPoContentLoader());
}
function createPoDataLoader(params) {
  return createLoader({
    async pull(locale, input2) {
      const parsedPo = gettextParser.po.parse(input2);
      const result = {};
      const sections = input2.split("\n\n").filter(Boolean);
      for (const section of sections) {
        const sectionPo = gettextParser.po.parse(section);
        if (Object.keys(sectionPo.translations).length === 0) {
          continue;
        }
        const contextKey = _11.keys(sectionPo.translations)[0];
        const entries = sectionPo.translations[contextKey];
        Object.entries(entries).forEach(([msgid, entry]) => {
          if (msgid && entry.msgid) {
            const context = entry.msgctxt || "";
            const fullEntry = parsedPo.translations[context]?.[msgid];
            if (fullEntry) {
              result[msgid] = fullEntry;
            }
          }
        });
      }
      return result;
    },
    async push(locale, data, originalInput, originalLocale, pullInput) {
      const currentSections = pullInput?.split("\n\n").filter(Boolean) || [];
      const originalSections = originalInput?.split("\n\n").filter(Boolean) || [];
      const result = originalSections.map((section) => {
        const sectionPo = gettextParser.po.parse(section);
        if (Object.keys(sectionPo.translations).length === 0) {
          return null;
        }
        const contextKey = _11.keys(sectionPo.translations)[0];
        const entries = sectionPo.translations[contextKey];
        const msgid = Object.keys(entries).find((key) => entries[key].msgid);
        if (!msgid) {
          const currentSection = currentSections.find((cs) => {
            const csPo = gettextParser.po.parse(cs);
            const csContextKey = _11.keys(csPo.translations)[0];
            const csEntries = csPo.translations[csContextKey];
            const csMsgid = Object.keys(csEntries).find(
              (key) => csEntries[key].msgid
            );
            return csMsgid === msgid;
          });
          if (currentSection) {
            return currentSection;
          }
          return section;
        }
        if (data[msgid]) {
          const updatedPo = _11.merge({}, sectionPo, {
            translations: {
              [contextKey]: {
                [msgid]: {
                  msgstr: data[msgid].msgstr
                }
              }
            }
          });
          const updatedSection = gettextParser.po.compile(updatedPo, { foldLength: params.multiline ? 76 : false }).toString().replace(
            [`msgid ""`, `msgstr "Content-Type: text/plain\\n"`].join("\n"),
            ""
          ).trim();
          return preserveCommentOrder(updatedSection, section);
        }
        return section.trim();
      }).filter(Boolean).join("\n\n");
      return result;
    }
  });
}
function createPoContentLoader() {
  return createLoader({
    async pull(locale, input2, initCtx, originalLocale) {
      const result = _11.chain(input2).entries().filter(([, entry]) => !!entry.msgid).map(([, entry]) => {
        const singularFallback = locale === originalLocale ? entry.msgid : null;
        const pluralFallback = locale === originalLocale ? entry.msgid_plural || entry.msgid : null;
        const hasPlural = entry.msgstr.length > 1;
        return [
          entry.msgid,
          {
            singular: entry.msgstr[0] || singularFallback,
            plural: hasPlural ? entry.msgstr[1] || pluralFallback : null
          }
        ];
      }).fromPairs().value();
      return result;
    },
    async push(locale, data, originalInput) {
      const result = _11.chain(originalInput).entries().map(([, entry]) => [
        entry.msgid,
        {
          ...entry,
          msgstr: [
            data[entry.msgid]?.singular,
            data[entry.msgid]?.plural || null
          ].filter(Boolean)
        }
      ]).fromPairs().value();
      return result;
    }
  });
}
function preserveCommentOrder(section, originalSection) {
  const sectionLines = section.split(/\r?\n/);
  const originalLines = originalSection.split(/\r?\n/);
  const isComment = (line) => line.trim().startsWith("#");
  const sectionComments = sectionLines.filter(isComment);
  const nonCommentLines = sectionLines.filter((line) => !isComment(line));
  if (sectionComments.length <= 1) {
    return section;
  }
  const originalCommentOrder = originalLines.filter(isComment);
  const commentMap = /* @__PURE__ */ new Map();
  for (const line of sectionComments) {
    commentMap.set(line.trim(), line);
  }
  const reorderedComments = [];
  for (const orig of originalCommentOrder) {
    const trimmed = orig.trim();
    if (commentMap.has(trimmed)) {
      reorderedComments.push(commentMap.get(trimmed));
      commentMap.delete(trimmed);
    }
  }
  for (const line of sectionComments) {
    if (!originalCommentOrder.some((orig) => orig.trim() === line.trim())) {
      reorderedComments.push(line);
    }
  }
  return [...reorderedComments, ...nonCommentLines].join("\n").replace(/\n{3,}/g, "\n\n").trim();
}

// src/cli/loaders/xliff.ts
import { JSDOM as JSDOM2 } from "jsdom";
function createXliffLoader() {
  return createLoader({
    async pull(locale, input2, _ctx, originalLocale) {
      const trimmedInput = (input2 ?? "").trim();
      if (!trimmedInput) {
        return createEmptyResult(originalLocale, locale);
      }
      try {
        const dom = new JSDOM2(trimmedInput, { contentType: "text/xml" });
        const document = dom.window.document;
        const parserError = document.querySelector("parsererror");
        if (parserError) {
          throw new Error(`XML parsing failed: ${parserError.textContent}`);
        }
        const xliffElement = document.documentElement;
        if (!xliffElement || xliffElement.tagName !== "xliff") {
          throw new Error("Invalid XLIFF: missing root <xliff> element");
        }
        const version = xliffElement.getAttribute("version") || "1.2";
        const isV2 = version === "2.0";
        if (isV2) {
          return pullV2(xliffElement, locale, originalLocale);
        } else {
          return pullV1(xliffElement, locale, originalLocale);
        }
      } catch (error) {
        throw new Error(`Failed to parse XLIFF file: ${error.message}`);
      }
    },
    async push(locale, translations, originalInput, originalLocale, pullInput) {
      if (!originalInput) {
        return pushNewFile(locale, translations, originalLocale);
      }
      try {
        const dom = new JSDOM2(originalInput, { contentType: "text/xml" });
        const document = dom.window.document;
        const xliffElement = document.documentElement;
        const version = xliffElement.getAttribute("version") || "1.2";
        const isV2 = version === "2.0";
        if (isV2) {
          return pushV2(
            dom,
            xliffElement,
            locale,
            translations,
            originalLocale,
            originalInput
          );
        } else {
          return pushV1(
            dom,
            xliffElement,
            locale,
            translations,
            originalLocale,
            originalInput
          );
        }
      } catch (error) {
        throw new Error(`Failed to update XLIFF file: ${error.message}`);
      }
    }
  });
}
function pullV1(xliffElement, locale, originalLocale) {
  const result = {};
  const fileElement = xliffElement.querySelector("file");
  if (!fileElement) {
    return result;
  }
  const sourceLanguage = fileElement.getAttribute("source-language") || originalLocale;
  const isSourceLocale = sourceLanguage === locale;
  const bodyElement = fileElement.querySelector("body");
  if (!bodyElement) {
    return result;
  }
  const transUnits = bodyElement.querySelectorAll("trans-unit");
  const seenKeys = /* @__PURE__ */ new Set();
  transUnits.forEach((unit) => {
    let key = getTransUnitKey(unit);
    if (!key) return;
    if (seenKeys.has(key)) {
      const id = unit.getAttribute("id")?.trim();
      if (id) {
        key = `${key}#${id}`;
      } else {
        let counter = 1;
        let newKey = `${key}__${counter}`;
        while (seenKeys.has(newKey)) {
          counter++;
          newKey = `${key}__${counter}`;
        }
        key = newKey;
      }
    }
    seenKeys.add(key);
    const elementName = isSourceLocale ? "source" : "target";
    const textElement = unit.querySelector(elementName);
    if (textElement) {
      result[key] = extractTextContent(textElement);
    } else if (isSourceLocale) {
      result[key] = key;
    } else {
      result[key] = "";
    }
  });
  return result;
}
function pushV1(dom, xliffElement, locale, translations, originalLocale, originalInput) {
  const document = dom.window.document;
  const fileElement = xliffElement.querySelector("file");
  if (!fileElement) {
    throw new Error("Invalid XLIFF 1.2: missing <file> element");
  }
  const sourceLanguage = fileElement.getAttribute("source-language") || originalLocale;
  const isSourceLocale = sourceLanguage === locale;
  if (!isSourceLocale) {
    fileElement.setAttribute("target-language", locale);
  }
  let bodyElement = fileElement.querySelector("body");
  if (!bodyElement) {
    bodyElement = document.createElement("body");
    fileElement.appendChild(bodyElement);
  }
  const existingUnits = /* @__PURE__ */ new Map();
  const seenKeys = /* @__PURE__ */ new Set();
  bodyElement.querySelectorAll("trans-unit").forEach((unit) => {
    let key = getTransUnitKey(unit);
    if (!key) return;
    if (seenKeys.has(key)) {
      const id = unit.getAttribute("id")?.trim();
      if (id) {
        key = `${key}#${id}`;
      } else {
        let counter = 1;
        let newKey = `${key}__${counter}`;
        while (seenKeys.has(newKey)) {
          counter++;
          newKey = `${key}__${counter}`;
        }
        key = newKey;
      }
    }
    seenKeys.add(key);
    existingUnits.set(key, unit);
  });
  Object.entries(translations).forEach(([key, value]) => {
    let unit = existingUnits.get(key);
    if (!unit) {
      unit = document.createElement("trans-unit");
      unit.setAttribute("id", key);
      unit.setAttribute("resname", key);
      unit.setAttribute("restype", "string");
      unit.setAttribute("datatype", "plaintext");
      const sourceElement = document.createElement("source");
      setTextContent(sourceElement, isSourceLocale ? value : key);
      unit.appendChild(sourceElement);
      if (!isSourceLocale) {
        const targetElement = document.createElement("target");
        targetElement.setAttribute("state", value ? "translated" : "new");
        setTextContent(targetElement, value);
        unit.appendChild(targetElement);
      }
      bodyElement.appendChild(unit);
      existingUnits.set(key, unit);
    } else {
      updateTransUnitV1(unit, key, value, isSourceLocale);
    }
  });
  const translationKeys = new Set(Object.keys(translations));
  existingUnits.forEach((unit, key) => {
    if (!translationKeys.has(key)) {
      unit.parentNode?.removeChild(unit);
    }
  });
  return serializeWithDeclaration(
    dom,
    extractXmlDeclaration(originalInput || "")
  );
}
function updateTransUnitV1(unit, key, value, isSourceLocale) {
  const document = unit.ownerDocument;
  if (isSourceLocale) {
    let sourceElement = unit.querySelector("source");
    if (!sourceElement) {
      sourceElement = document.createElement("source");
      unit.appendChild(sourceElement);
    }
    setTextContent(sourceElement, value);
  } else {
    let targetElement = unit.querySelector("target");
    if (!targetElement) {
      targetElement = document.createElement("target");
      unit.appendChild(targetElement);
    }
    setTextContent(targetElement, value);
    targetElement.setAttribute("state", value.trim() ? "translated" : "new");
  }
}
function pullV2(xliffElement, locale, originalLocale) {
  const result = {};
  const srcLang = xliffElement.getAttribute("srcLang") || originalLocale;
  result.sourceLanguage = srcLang;
  const fileElements = xliffElement.querySelectorAll("file");
  fileElements.forEach((fileElement) => {
    const fileId = fileElement.getAttribute("id");
    if (!fileId) return;
    traverseUnitsV2(fileElement, fileId, "", result);
  });
  return result;
}
function traverseUnitsV2(container, fileId, currentPath, result) {
  Array.from(container.children).forEach((child) => {
    const tagName = child.tagName;
    if (tagName === "unit") {
      const unitId = child.getAttribute("id")?.trim();
      if (!unitId) return;
      const key = `resources/${fileId}/${currentPath}${unitId}/source`;
      const segment = child.querySelector("segment");
      const source = segment?.querySelector("source");
      if (source) {
        result[key] = extractTextContent(source);
      } else {
        result[key] = unitId;
      }
    } else if (tagName === "group") {
      const groupId = child.getAttribute("id")?.trim();
      const newPath = groupId ? `${currentPath}${groupId}/groupUnits/` : currentPath;
      traverseUnitsV2(child, fileId, newPath, result);
    }
  });
}
function pushV2(dom, xliffElement, locale, translations, originalLocale, originalInput) {
  const document = dom.window.document;
  if (translations.sourceLanguage) {
    xliffElement.setAttribute("srcLang", translations.sourceLanguage);
    delete translations.sourceLanguage;
  }
  const existingUnits = /* @__PURE__ */ new Map();
  const fileElements = xliffElement.querySelectorAll("file");
  fileElements.forEach((fileElement) => {
    const fileId = fileElement.getAttribute("id");
    if (!fileId) return;
    indexUnitsV2(fileElement, fileId, "", existingUnits);
  });
  Object.entries(translations).forEach(([key, value]) => {
    const unit = existingUnits.get(key);
    if (unit) {
      updateUnitV2(unit, value);
    } else {
      console.warn(`Cannot create new unit for key: ${key} in XLIFF 2.0`);
    }
  });
  return serializeWithDeclaration(
    dom,
    extractXmlDeclaration(originalInput || "")
  );
}
function indexUnitsV2(container, fileId, currentPath, index) {
  Array.from(container.children).forEach((child) => {
    const tagName = child.tagName;
    if (tagName === "unit") {
      const unitId = child.getAttribute("id")?.trim();
      if (!unitId) return;
      const key = `resources/${fileId}/${currentPath}${unitId}/source`;
      index.set(key, child);
    } else if (tagName === "group") {
      const groupId = child.getAttribute("id")?.trim();
      const newPath = groupId ? `${currentPath}${groupId}/groupUnits/` : currentPath;
      indexUnitsV2(child, fileId, newPath, index);
    }
  });
}
function updateUnitV2(unit, value) {
  const document = unit.ownerDocument;
  let segment = unit.querySelector("segment");
  if (!segment) {
    segment = document.createElement("segment");
    unit.appendChild(segment);
  }
  let source = segment.querySelector("source");
  if (!source) {
    source = document.createElement("source");
    segment.appendChild(source);
  }
  setTextContent(source, value);
}
function getTransUnitKey(transUnit) {
  const resname = transUnit.getAttribute("resname")?.trim();
  if (resname) return resname;
  const id = transUnit.getAttribute("id")?.trim();
  if (id) return id;
  const sourceElement = transUnit.querySelector("source");
  if (sourceElement) {
    const sourceText = extractTextContent(sourceElement).trim();
    if (sourceText) return sourceText;
  }
  return "";
}
function extractTextContent(element) {
  const cdataNode = Array.from(element.childNodes).find(
    (node) => node.nodeType === element.CDATA_SECTION_NODE
  );
  if (cdataNode) {
    return cdataNode.nodeValue || "";
  }
  return element.textContent || "";
}
function setTextContent(element, content) {
  const document = element.ownerDocument;
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
  if (/[<>&"']/.test(content)) {
    const cdataSection = document.createCDATASection(content);
    element.appendChild(cdataSection);
  } else {
    element.textContent = content;
  }
}
function extractXmlDeclaration(xmlContent) {
  const match2 = xmlContent.match(/^<\?xml[^>]*\?>/);
  return match2 ? match2[0] : "";
}
function serializeWithDeclaration(dom, declaration) {
  let serialized = dom.serialize();
  serialized = formatXml(serialized);
  if (declaration) {
    serialized = `${declaration}
${serialized}`;
  }
  return serialized;
}
function formatXml(xml) {
  const dom = new JSDOM2(xml, { contentType: "text/xml" });
  const doc = dom.window.document;
  function formatElement(element, depth = 0) {
    const indent2 = "  ".repeat(depth);
    const tagName = element.tagName;
    const attributes = Array.from(element.attributes).map((attr) => `${attr.name}="${attr.value}"`).join(" ");
    const openTag = attributes ? `<${tagName} ${attributes}>` : `<${tagName}>`;
    const cdataNode = Array.from(element.childNodes).find(
      (node) => node.nodeType === element.CDATA_SECTION_NODE
    );
    if (cdataNode) {
      return `${indent2}${openTag}<![CDATA[${cdataNode.nodeValue}]]></${tagName}>`;
    }
    const textContent = element.textContent?.trim() || "";
    const hasOnlyText = element.childNodes.length === 1 && element.childNodes[0].nodeType === 3;
    if (hasOnlyText && textContent) {
      return `${indent2}${openTag}${textContent}</${tagName}>`;
    }
    const children = Array.from(element.children);
    if (children.length === 0) {
      return `${indent2}${openTag}</${tagName}>`;
    }
    let result = `${indent2}${openTag}
`;
    for (const child of children) {
      result += formatElement(child, depth + 1) + "\n";
    }
    result += `${indent2}</${tagName}>`;
    return result;
  }
  return formatElement(doc.documentElement);
}
function createEmptyResult(originalLocale, locale) {
  return {};
}
function pushNewFile(locale, translations, originalLocale) {
  const skeleton = `<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file original="" source-language="${originalLocale}" target-language="${locale}" datatype="plaintext">
    <header></header>
    <body></body>
  </file>
</xliff>`;
  const dom = new JSDOM2(skeleton, { contentType: "text/xml" });
  const document = dom.window.document;
  const bodyElement = document.querySelector("body");
  Object.entries(translations).forEach(([key, value]) => {
    const unit = document.createElement("trans-unit");
    unit.setAttribute("id", key);
    unit.setAttribute("resname", key);
    unit.setAttribute("restype", "string");
    unit.setAttribute("datatype", "plaintext");
    const sourceElement = document.createElement("source");
    setTextContent(sourceElement, key);
    unit.appendChild(sourceElement);
    const targetElement = document.createElement("target");
    targetElement.setAttribute("state", value ? "translated" : "new");
    setTextContent(targetElement, value);
    unit.appendChild(targetElement);
    bodyElement.appendChild(unit);
  });
  return serializeWithDeclaration(
    dom,
    '<?xml version="1.0" encoding="utf-8"?>'
  );
}

// src/cli/loaders/xml.ts
import { parseStringPromise as parseStringPromise2, Builder } from "xml2js";
function normalizeXMLString(xmlString) {
  return xmlString.replace(/\s+/g, " ").replace(/>\s+</g, "><").replace("\n", "").trim();
}
function createXmlLoader() {
  return createLoader({
    async pull(locale, input2) {
      let result = {};
      try {
        const parsed = await parseStringPromise2(input2, {
          explicitArray: false,
          mergeAttrs: false,
          normalize: true,
          preserveChildrenOrder: true,
          normalizeTags: true,
          includeWhiteChars: true,
          trim: true
        });
        result = parsed;
      } catch (error) {
        console.error("Failed to parse XML:", error);
        result = {};
      }
      return result;
    },
    async push(locale, data) {
      try {
        const builder = new Builder({ headless: true });
        const xmlOutput = builder.buildObject(data);
        const expectedOutput = normalizeXMLString(xmlOutput);
        return expectedOutput;
      } catch (error) {
        console.error("Failed to build XML:", error);
        return "";
      }
    }
  });
}

// src/cli/loaders/srt.ts
import srtParser from "srt-parser-2";
function createSrtLoader() {
  const parser = new srtParser();
  return createLoader({
    async pull(locale, input2) {
      const parsed = parser.fromSrt(input2) || [];
      const result = {};
      parsed.forEach((entry) => {
        const key = `${entry.id}#${entry.startTime}-${entry.endTime}`;
        result[key] = entry.text;
      });
      return result;
    },
    async push(locale, payload) {
      const output = Object.entries(payload).map(([key, text]) => {
        const [id, timeRange] = key.split("#");
        const [startTime, endTime] = timeRange.split("-");
        return {
          id,
          startTime,
          startSeconds: 0,
          endTime,
          endSeconds: 0,
          text
        };
      });
      const srtContent = parser.toSrt(output).trim().replace(/\r?\n/g, "\n");
      return srtContent;
    }
  });
}

// src/cli/loaders/dato/index.ts
import fs10 from "fs";
import JSON52 from "json5";

// src/cli/loaders/dato/_base.ts
import Z2 from "zod";
var datoConfigSchema = Z2.object({
  project: Z2.string(),
  models: Z2.record(
    Z2.string(),
    Z2.object({
      records: Z2.array(Z2.string()).optional(),
      fields: Z2.array(Z2.string()).optional()
    })
  )
});
var datoSettingsSchema = Z2.object({
  auth: Z2.object({
    apiKey: Z2.string()
  })
});

// src/cli/loaders/dato/filter.ts
import _12 from "lodash";
function createDatoFilterLoader() {
  return createLoader({
    async pull(locale, input2) {
      const result = {};
      for (const [modelId, modelInfo] of _12.entries(input2)) {
        result[modelId] = {};
        for (const record of modelInfo.records) {
          result[modelId][record.id] = _12.chain(modelInfo.fields).mapKeys((field) => field.api_key).mapValues((field) => _12.get(record, [field.api_key, locale])).value();
        }
      }
      return result;
    },
    async push(locale, data, originalInput, originalLocale) {
      const result = _12.cloneDeep(originalInput || {});
      for (const [modelId, modelInfo] of _12.entries(result)) {
        for (const record of modelInfo.records) {
          for (const [fieldId, fieldValue] of _12.entries(record)) {
            const fieldInfo = modelInfo.fields.find(
              (field) => field.api_key === fieldId
            );
            if (fieldInfo) {
              const sourceFieldValue = _12.get(fieldValue, [originalLocale]);
              const targetFieldValue = _12.get(data, [
                modelId,
                record.id,
                fieldId
              ]);
              if (targetFieldValue) {
                _12.set(record, [fieldId, locale], targetFieldValue);
              } else {
                _12.set(record, [fieldId, locale], sourceFieldValue);
              }
              _12.chain(fieldValue).keys().reject((loc) => loc === locale || loc === originalLocale).filter((loc) => _12.isEmpty(_12.get(fieldValue, [loc]))).forEach(
                (loc) => _12.set(record, [fieldId, loc], sourceFieldValue)
              ).value();
            }
          }
        }
      }
      return result;
    }
  });
}

// src/cli/loaders/dato/api.ts
import _14 from "lodash";

// src/cli/loaders/dato/_utils.ts
import _13 from "lodash";
import { buildClient } from "@datocms/cma-client-node";
function createDatoClient(params) {
  if (!params.apiKey) {
    throw new Error(
      "Missing required environment variable: DATO_API_TOKEN. Please set this variable and try again."
    );
  }
  const dato = buildClient({
    apiToken: params.apiKey,
    extraHeaders: {
      "X-Exclude-Invalid": "true"
    }
  });
  return {
    findProject: async () => {
      const project = await dato.site.find();
      return project;
    },
    updateField: async (fieldId, payload) => {
      try {
        await dato.fields.update(fieldId, payload);
      } catch (_error) {
        throw new Error(
          [
            `Failed to update field in DatoCMS.`,
            `Field ID: ${fieldId}`,
            `Payload: ${JSON.stringify(payload, null, 2)}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    findField: async (fieldId) => {
      try {
        const field = await dato.fields.find(fieldId);
        if (!field) {
          throw new Error(`Field ${fieldId} not found`);
        }
        return field;
      } catch (_error) {
        throw new Error(
          [
            `Failed to find field in DatoCMS.`,
            `Field ID: ${fieldId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    findModels: async () => {
      try {
        const models = await dato.itemTypes.list();
        const modelsWithoutBlocks = models.filter(
          (model) => !model.modular_block
        );
        return modelsWithoutBlocks;
      } catch (_error) {
        throw new Error(
          [
            `Failed to find models in DatoCMS.`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    findModel: async (modelId) => {
      try {
        const model = await dato.itemTypes.find(modelId);
        if (!model) {
          throw new Error(`Model ${modelId} not found`);
        }
        return model;
      } catch (_error) {
        throw new Error(
          [
            `Failed to find model in DatoCMS.`,
            `Model ID: ${modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    findRecords: async (records, limit = 100) => {
      return dato.items.list({
        nested: true,
        version: "current",
        limit,
        filter: {
          projectId: params.projectId,
          only_valid: "true",
          ids: !records.length ? void 0 : records.join(",")
        }
      }).catch(
        (error) => Promise.reject(error?.response?.body?.data?.[0] || error)
      );
    },
    findRecordsForModel: async (modelId, records) => {
      try {
        const result = await dato.items.list({
          nested: true,
          version: "current",
          filter: {
            type: modelId,
            only_valid: "true",
            ids: !records?.length ? void 0 : records.join(",")
          }
        }).catch(
          (error) => Promise.reject(error?.response?.body?.data?.[0] || error)
        );
        return result;
      } catch (_error) {
        throw new Error(
          [
            `Failed to find records for model in DatoCMS.`,
            `Model ID: ${modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    updateRecord: async (id, payload) => {
      try {
        await dato.items.update(id, payload).catch(
          (error) => Promise.reject(error?.response?.body?.data?.[0] || error)
        );
      } catch (_error) {
        if (_error?.attributes?.details?.message) {
          throw new Error(
            [
              `${_error.attributes.details.message}`,
              `Payload: ${JSON.stringify(payload, null, 2)}`,
              `Error: ${JSON.stringify(_error, null, 2)}`
            ].join("\n\n")
          );
        }
        throw new Error(
          [
            `Failed to update record in DatoCMS.`,
            `Record ID: ${id}`,
            `Payload: ${JSON.stringify(payload, null, 2)}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    },
    enableFieldLocalization: async (args) => {
      try {
        await dato.fields.update(`${args.modelId}::${args.fieldId}`, { localized: true }).catch(
          (error) => Promise.reject(error?.response?.body?.data?.[0] || error)
        );
      } catch (_error) {
        if (_error?.attributes?.code === "NOT_FOUND") {
          throw new Error(
            [
              `Field "${args.fieldId}" not found in model "${args.modelId}".`,
              `Error: ${JSON.stringify(_error, null, 2)}`
            ].join("\n\n")
          );
        }
        if (_error?.attributes?.details?.message) {
          throw new Error(
            [
              `${_error.attributes.details.message}`,
              `Error: ${JSON.stringify(_error, null, 2)}`
            ].join("\n\n")
          );
        }
        throw new Error(
          [
            `Failed to enable field localization in DatoCMS.`,
            `Field ID: ${args.fieldId}`,
            `Model ID: ${args.modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`
          ].join("\n\n")
        );
      }
    }
  };
}

// src/cli/loaders/dato/api.ts
import inquirer from "inquirer";
function createDatoApiLoader(config, onConfigUpdate) {
  const dato = createDatoClient({
    apiKey: process.env.DATO_API_TOKEN || "",
    projectId: config.project
  });
  return createLoader({
    init: async () => {
      const result = {
        models: {}
      };
      const updatedConfig = _14.cloneDeep(config);
      console.log(`Initializing DatoCMS loader...`);
      const project = await dato.findProject();
      const modelChoices = await getModelChoices(dato, config);
      const selectedModels = await promptModelSelection(modelChoices);
      for (const modelId of selectedModels) {
        if (!updatedConfig.models[modelId]) {
          updatedConfig.models[modelId] = {
            fields: [],
            records: []
          };
        }
      }
      for (const modelId of Object.keys(updatedConfig.models)) {
        if (!selectedModels.includes(modelId)) {
          delete updatedConfig.models[modelId];
        }
      }
      for (const modelId of _14.keys(updatedConfig.models)) {
        const { modelName, fields } = await getModelFields(dato, modelId);
        if (fields.length > 0) {
          result.models[modelId] = { fields: [], records: [] };
          const fieldInfos = await getFieldDetails(dato, fields);
          const fieldChoices = createFieldChoices(fieldInfos);
          const selectedFields = await promptFieldSelection(
            modelName,
            fieldChoices
          );
          for (const fieldInfo of fieldInfos) {
            const isLocalized = await updateFieldLocalization(
              dato,
              fieldInfo,
              selectedFields.includes(fieldInfo.id)
            );
            if (isLocalized) {
              result.models[modelId].fields.push(fieldInfo);
              updatedConfig.models[modelId].fields = _14.uniq([
                ...updatedConfig.models[modelId].fields || [],
                fieldInfo.api_key
              ]);
            }
          }
          const records = await dato.findRecordsForModel(modelId);
          const recordChoices = createRecordChoices(
            records,
            config.models[modelId]?.records || [],
            project
          );
          const selectedRecords = await promptRecordSelection(
            modelName,
            recordChoices
          );
          result.models[modelId].records = records.filter(
            (record) => selectedRecords.includes(record.id)
          );
          updatedConfig.models[modelId].records = selectedRecords;
        }
      }
      console.log(`DatoCMS loader initialized.`);
      onConfigUpdate(updatedConfig);
      return result;
    },
    async pull(locale, input2, initCtx) {
      const result = {};
      for (const modelId of _14.keys(initCtx?.models || {})) {
        let records = initCtx?.models[modelId].records || [];
        const recordIds = records.map((record) => record.id);
        records = await dato.findRecords(recordIds);
        console.log(`Fetched ${records.length} records for model ${modelId}`);
        if (records.length > 0) {
          result[modelId] = {
            fields: initCtx?.models?.[modelId]?.fields || [],
            records
          };
        }
      }
      return result;
    },
    async push(locale, data, originalInput) {
      for (const modelId of _14.keys(data)) {
        for (let i = 0; i < data[modelId].records.length; i++) {
          const record = data[modelId].records[i];
          console.log(
            `Updating record ${i + 1}/${data[modelId].records.length} for model ${modelId}...`
          );
          await dato.updateRecord(record.id, record);
        }
      }
    }
  });
}
async function getModelFields(dato, modelId) {
  const modelInfo = await dato.findModel(modelId);
  return {
    modelName: modelInfo.name,
    fields: _14.filter(modelInfo.fields, (field) => field.type === "field")
  };
}
async function getFieldDetails(dato, fields) {
  return Promise.all(fields.map((field) => dato.findField(field.id)));
}
function createFieldChoices(fieldInfos) {
  return fieldInfos.map((field) => ({
    name: field.label,
    value: field.id,
    checked: field.localized
  }));
}
async function promptFieldSelection(modelName, choices) {
  const { selectedFields } = await inquirer.prompt([
    {
      type: "checkbox",
      name: "selectedFields",
      message: `Select fields to enable localization for model "${modelName}":`,
      choices,
      pageSize: process.stdout.rows - 4
      // Subtract some rows for prompt text and margins
    }
  ]);
  return selectedFields;
}
async function updateFieldLocalization(dato, fieldInfo, shouldBeLocalized) {
  if (shouldBeLocalized !== fieldInfo.localized) {
    console.log(
      `${shouldBeLocalized ? "Enabling" : "Disabling"} localization for ${fieldInfo.label}...`
    );
    await dato.updateField(fieldInfo.id, { localized: shouldBeLocalized });
  }
  return shouldBeLocalized;
}
function createRecordChoices(records, selectedIds = [], project) {
  return records.map((record) => ({
    name: `${record.id} - https://${project.internal_domain}/editor/item_types/${record.item_type.id}/items/${record.id}`,
    value: record.id,
    checked: selectedIds?.includes(record.id)
  }));
}
async function promptRecordSelection(modelName, choices) {
  const { selectedRecords } = await inquirer.prompt([
    {
      type: "checkbox",
      name: "selectedRecords",
      message: `Select records to include for model "${modelName}":`,
      choices,
      pageSize: process.stdout.rows - 4
      // Subtract some rows for prompt text and margins
    }
  ]);
  return selectedRecords;
}
async function getModelChoices(dato, config) {
  const models = await dato.findModels();
  return models.map((model) => ({
    name: `${model.name} (${model.api_key})`,
    value: model.id,
    checked: config.models[model.id] !== void 0,
    pageSize: process.stdout.rows - 4
    // Subtract some rows for prompt text and margins
  }));
}
async function promptModelSelection(choices) {
  const { selectedModels } = await inquirer.prompt([
    {
      type: "checkbox",
      name: "selectedModels",
      message: "Select models to include:",
      choices,
      pageSize: process.stdout.rows - 4
      // Subtract some rows for prompt text and margins
    }
  ]);
  return selectedModels;
}

// src/cli/loaders/dato/extract.ts
import _15 from "lodash";
function createDatoExtractLoader() {
  return createLoader({
    async pull(locale, input2) {
      const result = {};
      for (const [modelId, modelInfo] of _15.entries(input2)) {
        for (const [recordId, record] of _15.entries(modelInfo)) {
          for (const [fieldName, fieldValue] of _15.entries(record)) {
            const parsedValue = createParsedDatoValue(fieldValue);
            if (parsedValue) {
              _15.set(result, [modelId, `_${recordId}`, fieldName], parsedValue);
            }
          }
        }
      }
      return result;
    },
    async push(locale, data, originalInput) {
      const result = _15.cloneDeep(originalInput || {});
      for (const [modelId, modelInfo] of _15.entries(data)) {
        for (const [virtualRecordId, record] of _15.entries(modelInfo)) {
          for (const [fieldName, fieldValue] of _15.entries(record)) {
            const [, recordId] = virtualRecordId.split("_");
            const originalFieldValue = _15.get(originalInput, [
              modelId,
              recordId,
              fieldName
            ]);
            const rawValue = createRawDatoValue(
              fieldValue,
              originalFieldValue,
              true
            );
            _15.set(
              result,
              [modelId, recordId, fieldName],
              rawValue || originalFieldValue
            );
          }
        }
      }
      return result;
    }
  });
}
function detectDatoFieldType(rawDatoValue) {
  if (_15.has(rawDatoValue, "document") && _15.get(rawDatoValue, "schema") === "dast") {
    return "structured_text";
  } else if (_15.has(rawDatoValue, "no_index") || _15.has(rawDatoValue, "twitter_card")) {
    return "seo";
  } else if (_15.get(rawDatoValue, "type") === "item") {
    return "single_block";
  } else if (_15.isArray(rawDatoValue) && _15.every(rawDatoValue, (item) => _15.get(item, "type") === "item")) {
    return "rich_text";
  } else if (_isFile(rawDatoValue)) {
    return "file";
  } else if (_15.isArray(rawDatoValue) && _15.every(rawDatoValue, (item) => _isFile(item))) {
    return "gallery";
  } else if (_isJson(rawDatoValue)) {
    return "json";
  } else if (_15.isString(rawDatoValue)) {
    return "string";
  } else if (_isVideo(rawDatoValue)) {
    return "video";
  } else if (_15.isArray(rawDatoValue) && _15.every(rawDatoValue, (item) => _15.isString(item))) {
    return "ref_list";
  } else {
    return null;
  }
}
function createParsedDatoValue(rawDatoValue) {
  const fieldType = detectDatoFieldType(rawDatoValue);
  switch (fieldType) {
    default:
      return rawDatoValue;
    case "structured_text":
      return serializeStructuredText(rawDatoValue);
    case "seo":
      return serializeSeo(rawDatoValue);
    case "single_block":
      return serializeBlock(rawDatoValue);
    case "rich_text":
      return serializeBlockList(rawDatoValue);
    case "json":
      return JSON.parse(rawDatoValue);
    case "video":
      return serializeVideo(rawDatoValue);
    case "file":
      return serializeFile(rawDatoValue);
    case "gallery":
      return serializeGallery(rawDatoValue);
    case "ref_list":
      return null;
  }
}
function createRawDatoValue(parsedDatoValue, originalRawDatoValue, isClean = false) {
  const fieldType = detectDatoFieldType(originalRawDatoValue);
  switch (fieldType) {
    default:
      return parsedDatoValue;
    case "structured_text":
      return deserializeStructuredText(parsedDatoValue, originalRawDatoValue);
    case "seo":
      return deserializeSeo(parsedDatoValue, originalRawDatoValue);
    case "single_block":
      return deserializeBlock(parsedDatoValue, originalRawDatoValue, isClean);
    case "rich_text":
      return deserializeBlockList(
        parsedDatoValue,
        originalRawDatoValue,
        isClean
      );
    case "json":
      return JSON.stringify(parsedDatoValue, null, 2);
    case "video":
      return deserializeVideo(parsedDatoValue, originalRawDatoValue);
    case "file":
      return deserializeFile(parsedDatoValue, originalRawDatoValue);
    case "gallery":
      return deserializeGallery(parsedDatoValue, originalRawDatoValue);
    case "ref_list":
      return originalRawDatoValue;
  }
}
function serializeStructuredText(rawStructuredText) {
  return serializeStructuredTextNode(rawStructuredText);
  function serializeStructuredTextNode(node, path19 = [], acc = {}) {
    if ("document" in node) {
      return serializeStructuredTextNode(
        node.document,
        [...path19, "document"],
        acc
      );
    }
    if (!_15.isNil(node.value)) {
      acc[[...path19, "value"].join(".")] = node.value;
    } else if (_15.get(node, "type") === "block") {
      acc[[...path19, "item"].join(".")] = serializeBlock(node.item);
    }
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        serializeStructuredTextNode(
          node.children[i],
          [...path19, i.toString()],
          acc
        );
      }
    }
    return acc;
  }
}
function serializeSeo(rawSeo) {
  return _15.chain(rawSeo).pick(["title", "description"]).value();
}
function serializeBlock(rawBlock) {
  if (_15.get(rawBlock, "type") === "item" && _15.has(rawBlock, "id")) {
    return serializeBlock(rawBlock.attributes);
  }
  const result = {};
  for (const [attributeName, attributeValue] of _15.entries(rawBlock)) {
    result[attributeName] = createParsedDatoValue(attributeValue);
  }
  return result;
}
function serializeBlockList(rawBlockList) {
  return _15.chain(rawBlockList).map((block) => serializeBlock(block)).value();
}
function serializeVideo(rawVideo) {
  return _15.chain(rawVideo).pick(["title"]).value();
}
function serializeFile(rawFile) {
  return _15.chain(rawFile).pick(["alt", "title"]).value();
}
function serializeGallery(rawGallery) {
  return _15.chain(rawGallery).map((item) => serializeFile(item)).value();
}
function deserializeFile(parsedFile, originalRawFile) {
  return _15.chain(parsedFile).defaults(originalRawFile).value();
}
function deserializeGallery(parsedGallery, originalRawGallery) {
  return _15.chain(parsedGallery).map((item, i) => deserializeFile(item, originalRawGallery[i])).value();
}
function deserializeVideo(parsedVideo, originalRawVideo) {
  return _15.chain(parsedVideo).defaults(originalRawVideo).value();
}
function deserializeBlock(payload, rawNode, isClean = false) {
  const result = _15.cloneDeep(rawNode);
  for (const [attributeName, attributeValue] of _15.entries(rawNode.attributes)) {
    const rawValue = createRawDatoValue(
      payload[attributeName],
      attributeValue,
      isClean
    );
    _15.set(result, ["attributes", attributeName], rawValue);
  }
  if (isClean) {
    delete result["id"];
  }
  return result;
}
function deserializeSeo(parsedSeo, originalRawSeo) {
  return _15.chain(parsedSeo).pick(["title", "description"]).defaults(originalRawSeo).value();
}
function deserializeBlockList(parsedBlockList, originalRawBlockList, isClean = false) {
  return _15.chain(parsedBlockList).map(
    (block, i) => deserializeBlock(block, originalRawBlockList[i], isClean)
  ).value();
}
function deserializeStructuredText(parsedStructuredText, originalRawStructuredText) {
  const result = _15.cloneDeep(originalRawStructuredText);
  for (const [path19, value] of _15.entries(parsedStructuredText)) {
    const realPath = _15.chain(path19.split(".")).flatMap((s) => !_15.isNaN(_15.toNumber(s)) ? ["children", s] : s).value();
    const deserializedValue = createRawDatoValue(
      value,
      _15.get(originalRawStructuredText, realPath),
      true
    );
    _15.set(result, realPath, deserializedValue);
  }
  return result;
}
function _isJson(rawDatoValue) {
  try {
    return _15.isString(rawDatoValue) && rawDatoValue.startsWith("{") && rawDatoValue.endsWith("}") && !!JSON.parse(rawDatoValue);
  } catch (e) {
    return false;
  }
}
function _isFile(rawDatoValue) {
  return _15.isObject(rawDatoValue) && ["alt", "title", "custom_data", "focal_point", "upload_id"].every(
    (key) => _15.has(rawDatoValue, key)
  );
}
function _isVideo(rawDatoValue) {
  return _15.isObject(rawDatoValue) && [
    "url",
    "title",
    "width",
    "height",
    "provider",
    "provider_uid",
    "thumbnail_url"
  ].every((key) => _15.has(rawDatoValue, key));
}

// src/cli/loaders/dato/index.ts
function createDatoLoader(configFilePath) {
  try {
    const configContent = fs10.readFileSync(configFilePath, "utf-8");
    const datoConfig = datoConfigSchema.parse(JSON52.parse(configContent));
    return composeLoaders(
      createDatoApiLoader(
        datoConfig,
        (updatedConfig) => fs10.writeFileSync(
          configFilePath,
          JSON52.stringify(updatedConfig, null, 2)
        )
      ),
      createDatoFilterLoader(),
      createDatoExtractLoader()
    );
  } catch (error) {
    throw new Error(
      [`Failed to parse DatoCMS config file.`, `Error: ${error.message}`].join(
        "\n\n"
      )
    );
  }
}

// src/cli/loaders/vtt.ts
import webvtt from "node-webvtt";
function createVttLoader() {
  return createLoader({
    async pull(locale, input2) {
      if (!input2) {
        return "";
      }
      const vtt = webvtt.parse(input2)?.cues;
      if (Object.keys(vtt).length === 0) {
        return {};
      } else {
        return vtt.reduce((result, cue, index) => {
          const key = `${index}#${cue.start}-${cue.end}#${cue.identifier}`;
          result[key] = cue.text;
          return result;
        }, {});
      }
    },
    async push(locale, payload) {
      const output = Object.entries(payload).map(([key, text]) => {
        const [id, timeRange, identifier] = key.split("#");
        const [startTime, endTime] = timeRange.split("-");
        return {
          end: Number(endTime),
          identifier,
          start: Number(startTime),
          styles: "",
          text
        };
      });
      const input2 = {
        valid: true,
        strict: true,
        cues: output
      };
      return webvtt.compile(input2);
    }
  });
}

// src/cli/loaders/variable/index.ts
import _16 from "lodash";
function createVariableLoader(params) {
  return composeLoaders(variableExtractLoader(params), variableContentLoader());
}
function variableExtractLoader(params) {
  const specifierPattern = getFormatSpecifierPattern(params.type);
  return createLoader({
    pull: async (locale, input2, initXtx, originalLocale, originalInput) => {
      const result = {};
      const inputValues = _16.omitBy(input2, _16.isEmpty);
      for (const [key, value] of Object.entries(inputValues)) {
        const originalValue = originalInput[key];
        if (isICUPluralObject(originalValue)) {
          const icuValue = isICUPluralObject(value) ? { icu: value.icu } : value;
          result[key] = {
            value: icuValue,
            variables: []
            // Metadata stored separately, not in variables
          };
          continue;
        }
        const matches = originalValue.match(specifierPattern) || [];
        result[key] = result[key] || {
          value,
          variables: []
        };
        for (let i = 0; i < matches.length; i++) {
          const match2 = matches[i];
          const currentValue = result[key].value;
          const newValue = currentValue?.replace(match2, `{variable:${i}}`);
          result[key].value = newValue;
          result[key].variables[i] = match2;
        }
      }
      return result;
    },
    push: async (locale, data, originalInput, originalDefaultLocale, pullInput, pullOutput) => {
      const result = {};
      for (const [key, valueObj] of Object.entries(data)) {
        result[key] = valueObj.value;
        const resultValue = result[key];
        if (isICUPluralObject(resultValue)) {
          const originalValue = originalInput?.[key];
          if (isICUPluralObject(originalValue) && originalValue._meta) {
            resultValue._meta = originalValue._meta;
            resultValue[Symbol.for("@lingo.dev/icu-plural-object")] = true;
          }
        }
        for (let i = 0; i < valueObj.variables.length; i++) {
          const variable = valueObj.variables[i];
          const currentValue = result[key];
          if (typeof currentValue === "string") {
            const newValue = currentValue?.replace(`{variable:${i}}`, variable);
            result[key] = newValue;
          }
        }
      }
      return result;
    }
  });
}
function variableContentLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      const result = _16.mapValues(input2, (payload) => payload.value);
      return result;
    },
    push: async (locale, data, originalInput, defaultLocale, pullInput) => {
      const result = _16.cloneDeep(
        originalInput || {}
      );
      for (const [key, originalValueObj] of Object.entries(result)) {
        result[key] = {
          ...originalValueObj,
          value: data[key]
        };
      }
      return result;
    }
  });
}
function getFormatSpecifierPattern(type) {
  switch (type) {
    case "ieee":
      return /%(?:\d+\$)?[+-]?(?:[ 0]|'.)?-?\d*(?:\.\d+)?(?:[hljztL]|ll|hh)?[@diuoxXfFeEgGaAcspn%]/g;
    case "python":
      return /%\([^)]+\)[diouxXeEfFgGcrs%]/g;
    default:
      throw new Error(`Unsupported variable format type: ${type}`);
  }
}

// src/cli/loaders/sync.ts
import _17 from "lodash";
function createSyncLoader() {
  return createLoader({
    async pull(locale, input2, initCtx, originalLocale, originalInput) {
      if (!originalInput) {
        return input2;
      }
      return _17.chain(originalInput).mapValues((value, key) => input2[key]).value();
    },
    async push(locale, data, originalInput) {
      if (!originalInput) {
        return data;
      }
      return _17.chain(originalInput || {}).mapValues((value, key) => data[key]).value();
    }
  });
}

// src/cli/utils/plutil-formatter.ts
function formatPlutilStyle(jsonData, existingJson) {
  const indent2 = existingJson ? detectIndentation(existingJson) : "  ";
  function format(data, level = 0) {
    const currentIndent = indent2.repeat(level);
    const nextIndent = indent2.repeat(level + 1);
    if (typeof data !== "object" || data === null) {
      return JSON.stringify(data);
    }
    if (Array.isArray(data)) {
      if (data.length === 0) return "[]";
      const items2 = data.map(
        (item) => `${nextIndent}${format(item, level + 1)}`
      );
      return `[
${items2.join(",\n")}
${currentIndent}]`;
    }
    const keys = Object.keys(data);
    if (keys.length === 0) {
      return `{

${currentIndent}}`;
    }
    const sortedKeys = keys.sort((a, b) => {
      const aIsWhitespace = /^\s*$/.test(a);
      const bIsWhitespace = /^\s*$/.test(b);
      if (aIsWhitespace && !bIsWhitespace) return -1;
      if (!aIsWhitespace && bIsWhitespace) return 1;
      return a.localeCompare(b, void 0, { numeric: true });
    });
    const items = sortedKeys.map((key) => {
      const value = data[key];
      return `${nextIndent}${JSON.stringify(key)} : ${format(
        value,
        level + 1
      )}`;
    });
    return `{
${items.join(",\n")}
${currentIndent}}`;
  }
  const result = format(jsonData);
  return result;
}
function detectIndentation(jsonStr) {
  const match2 = jsonStr.match(/\n(\s+)/);
  return match2 ? match2[1] : "    ";
}

// src/cli/loaders/plutil-json-loader.ts
function createPlutilJsonTextLoader() {
  return createLoader({
    async pull(locale, data) {
      return data;
    },
    async push(locale, data, originalInput) {
      const jsonData = JSON.parse(data);
      const result = formatPlutilStyle(jsonData, originalInput || "");
      return result;
    }
  });
}

// src/cli/loaders/php.ts
import { fromString } from "php-array-reader";
function createPhpLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      try {
        const output = fromString(input2);
        return output;
      } catch (error) {
        throw new Error(`Error parsing PHP file for locale ${locale}`);
      }
    },
    push: async (locale, data, originalInput) => {
      const output = toPhpString(data, originalInput);
      return output;
    }
  });
}
function toPhpString(data, originalPhpString) {
  const defaultFilePrefix = "<?php\n\n";
  if (originalPhpString) {
    const [filePrefix = defaultFilePrefix] = originalPhpString.split("return ");
    const shortArraySyntax = !originalPhpString.includes("array(");
    const output = `${filePrefix}return ${toPhpArray(data, shortArraySyntax)};`;
    return output;
  }
  return `${defaultFilePrefix}return ${toPhpArray(data)};`;
}
function toPhpArray(data, shortSyntax = true, indentLevel = 1) {
  if (data === null || data === void 0) {
    return "null";
  }
  if (typeof data === "string") {
    return `'${escapePhpString(data)}'`;
  }
  if (typeof data === "number") {
    return data.toString();
  }
  if (typeof data === "boolean") {
    return data ? "true" : "false";
  }
  const arrayStart = shortSyntax ? "[" : "array(";
  const arrayEnd = shortSyntax ? "]" : ")";
  if (Array.isArray(data)) {
    return `${arrayStart}
${data.map(
      (value) => `${indent(indentLevel)}${toPhpArray(
        value,
        shortSyntax,
        indentLevel + 1
      )}`
    ).join(",\n")}
${indent(indentLevel - 1)}${arrayEnd}`;
  }
  const output = `${arrayStart}
${Object.entries(data).map(
    ([key, value]) => `${indent(indentLevel)}'${key}' => ${toPhpArray(
      value,
      shortSyntax,
      indentLevel + 1
    )}`
  ).join(",\n")}
${indent(indentLevel - 1)}${arrayEnd}`;
  return output;
}
function indent(level) {
  return "  ".repeat(level);
}
function escapePhpString(str) {
  return str.replaceAll("\\", "\\\\").replaceAll("'", "\\'").replaceAll("\r", "\\r").replaceAll("\n", "\\n").replaceAll("	", "\\t");
}

// src/cli/loaders/vue-json.ts
import { jsonrepair as jsonrepair2 } from "jsonrepair";
function createVueJsonLoader() {
  return createLoader({
    pull: async (locale, input2, ctx) => {
      const parsed = parseVueFile(input2);
      return parsed?.i18n?.[locale] ?? {};
    },
    push: async (locale, data, originalInput) => {
      const parsed = parseVueFile(originalInput ?? "");
      if (!parsed) {
        return originalInput ?? "";
      }
      parsed.i18n[locale] = data;
      return `${parsed.before}<i18n>
${JSON.stringify(
        parsed.i18n,
        null,
        2
      )}
</i18n>${parsed.after}`;
    }
  });
}
function parseVueFile(input2) {
  const match2 = input2.match(/^([\s\S]*)<i18n>([\s\S]*)<\/i18n>([\s\S]*)$/);
  if (!match2) {
    return null;
  }
  const [, before, jsonString = "{}", after] = match2;
  let i18n;
  try {
    i18n = JSON.parse(jsonString);
  } catch (error) {
    i18n = JSON.parse(jsonrepair2(jsonString));
  }
  return { before, after, i18n };
}

// src/cli/loaders/typescript/index.ts
import { parse as parse3 } from "@babel/parser";
import _18 from "lodash";
import babelTraverseModule from "@babel/traverse";
import * as t from "@babel/types";
import babelGenerateModule from "@babel/generator";

// src/cli/loaders/typescript/cjs-interop.ts
function resolveCjsExport(mod, name = "module") {
  if (typeof mod === "function" || typeof mod !== "object" || mod === null) {
    return mod;
  }
  if ("default" in mod && typeof mod.default !== "undefined") {
    return mod.default;
  }
  console.error(
    `[resolveCjsExport] Unable to determine default export for ${name}.`,
    "Received value:",
    mod
  );
  throw new Error(`Failed to resolve default export for ${name}.`);
}

// src/cli/loaders/typescript/index.ts
var traverse = resolveCjsExport(babelTraverseModule, "@babel/traverse");
var generate = resolveCjsExport(babelGenerateModule, "@babel/generator");
function createTypescriptLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      if (!input2) {
        return {};
      }
      const ast = parseTypeScript(input2);
      const extractedStrings = extractStringsFromDefaultExport(ast);
      return extractedStrings;
    },
    push: async (locale, data, originalInput, defaultLocale, pullInput, pullOutput) => {
      const ast = parseTypeScript(originalInput || "");
      const finalData = _18.merge({}, pullOutput, data);
      updateStringsInDefaultExport(ast, finalData);
      const { code } = generate(ast, {
        jsescOption: {
          minimal: true
        }
      });
      return code;
    }
  });
}
function parseTypeScript(input2) {
  return parse3(input2, {
    sourceType: "module",
    plugins: ["typescript"]
  });
}
function extractStringsFromDefaultExport(ast) {
  let extracted = {};
  traverse(ast, {
    ExportDefaultDeclaration(path19) {
      const { declaration } = path19.node;
      const decl = unwrapTSAsExpression(declaration);
      if (t.isObjectExpression(decl)) {
        extracted = objectExpressionToObject(decl);
      } else if (t.isArrayExpression(decl)) {
        extracted = arrayExpressionToArray(decl);
      } else if (t.isIdentifier(decl)) {
        const binding = path19.scope.bindings[decl.name];
        if (binding && t.isVariableDeclarator(binding.path.node) && binding.path.node.init) {
          const initRaw = binding.path.node.init;
          const init = initRaw ? unwrapTSAsExpression(initRaw) : initRaw;
          if (t.isObjectExpression(init)) {
            extracted = objectExpressionToObject(init);
          } else if (t.isArrayExpression(init)) {
            extracted = arrayExpressionToArray(init);
          }
        }
      }
    }
  });
  return extracted;
}
function unwrapTSAsExpression(node) {
  let current = node;
  while (t.isTSAsExpression(current)) {
    current = current.expression;
  }
  return current;
}
function objectExpressionToObject(objectExpression) {
  const obj = {};
  objectExpression.properties.forEach((prop) => {
    if (!t.isObjectProperty(prop)) return;
    const key = getPropertyKey(prop);
    if (t.isStringLiteral(prop.value)) {
      obj[key] = prop.value.value;
    } else if (t.isTemplateLiteral(prop.value) && prop.value.expressions.length === 0) {
      obj[key] = prop.value.quasis[0].value.cooked ?? "";
    } else if (t.isObjectExpression(prop.value)) {
      const nested = objectExpressionToObject(prop.value);
      if (Object.keys(nested).length > 0) {
        obj[key] = nested;
      }
    } else if (t.isArrayExpression(prop.value)) {
      const arr = arrayExpressionToArray(prop.value);
      if (arr.length > 0) {
        obj[key] = arr;
      }
    }
  });
  return obj;
}
function arrayExpressionToArray(arrayExpression) {
  const arr = [];
  arrayExpression.elements.forEach((element) => {
    if (!element) return;
    if (t.isStringLiteral(element)) {
      arr.push(element.value);
    } else if (t.isTemplateLiteral(element) && element.expressions.length === 0) {
      arr.push(element.quasis[0].value.cooked ?? "");
    } else if (t.isObjectExpression(element)) {
      const nestedObj = objectExpressionToObject(element);
      arr.push(nestedObj);
    } else if (t.isArrayExpression(element)) {
      arr.push(arrayExpressionToArray(element));
    }
  });
  return arr;
}
function updateStringsInDefaultExport(ast, data) {
  let modified = false;
  traverse(ast, {
    ExportDefaultDeclaration(path19) {
      const { declaration } = path19.node;
      const decl = unwrapTSAsExpression(declaration);
      if (t.isObjectExpression(decl)) {
        modified = updateStringsInObjectExpression(decl, data) || modified;
      } else if (t.isArrayExpression(decl)) {
        if (Array.isArray(data)) {
          modified = updateStringsInArrayExpression(decl, data) || modified;
        }
      } else if (t.isIdentifier(decl)) {
        modified = updateStringsInExportedIdentifier(path19, data) || modified;
      }
    }
  });
  return modified;
}
function updateStringsInObjectExpression(objectExpression, data) {
  let modified = false;
  objectExpression.properties.forEach((prop) => {
    if (!t.isObjectProperty(prop)) return;
    const key = getPropertyKey(prop);
    const incomingVal = data?.[key];
    if (incomingVal === void 0) {
      return;
    }
    if (t.isStringLiteral(prop.value) && typeof incomingVal === "string") {
      if (prop.value.value !== incomingVal) {
        prop.value.value = incomingVal;
        modified = true;
      }
    } else if (t.isTemplateLiteral(prop.value) && prop.value.expressions.length === 0 && typeof incomingVal === "string") {
      const currentVal = prop.value.quasis[0].value.cooked ?? "";
      if (currentVal !== incomingVal) {
        prop.value.quasis[0].value.raw = incomingVal;
        prop.value.quasis[0].value.cooked = incomingVal;
        modified = true;
      }
    } else if (t.isObjectExpression(prop.value) && typeof incomingVal === "object" && !Array.isArray(incomingVal)) {
      const subModified = updateStringsInObjectExpression(
        prop.value,
        incomingVal
      );
      modified = subModified || modified;
    } else if (t.isArrayExpression(prop.value) && Array.isArray(incomingVal)) {
      const subModified = updateStringsInArrayExpression(
        prop.value,
        incomingVal
      );
      modified = subModified || modified;
    }
  });
  return modified;
}
function updateStringsInArrayExpression(arrayExpression, incoming) {
  let modified = false;
  arrayExpression.elements.forEach((element, index) => {
    if (!element) return;
    const incomingVal = incoming?.[index];
    if (incomingVal === void 0) return;
    if (t.isStringLiteral(element) && typeof incomingVal === "string") {
      if (element.value !== incomingVal) {
        element.value = incomingVal;
        modified = true;
      }
    } else if (t.isTemplateLiteral(element) && element.expressions.length === 0 && typeof incomingVal === "string") {
      const currentVal = element.quasis[0].value.cooked ?? "";
      if (currentVal !== incomingVal) {
        element.quasis[0].value.raw = incomingVal;
        element.quasis[0].value.cooked = incomingVal;
        modified = true;
      }
    } else if (t.isObjectExpression(element) && typeof incomingVal === "object" && !Array.isArray(incomingVal)) {
      const subModified = updateStringsInObjectExpression(element, incomingVal);
      modified = subModified || modified;
    } else if (t.isArrayExpression(element) && Array.isArray(incomingVal)) {
      const subModified = updateStringsInArrayExpression(element, incomingVal);
      modified = subModified || modified;
    }
  });
  return modified;
}
function updateStringsInExportedIdentifier(path19, data) {
  const exportName = path19.node.declaration.name;
  const binding = path19.scope.bindings[exportName];
  if (!binding || !binding.path.node) return false;
  if (t.isVariableDeclarator(binding.path.node) && binding.path.node.init) {
    const initRaw = binding.path.node.init;
    const init = initRaw ? unwrapTSAsExpression(initRaw) : initRaw;
    if (t.isObjectExpression(init)) {
      return updateStringsInObjectExpression(init, data);
    } else if (t.isArrayExpression(init)) {
      return updateStringsInArrayExpression(init, data);
    }
  }
  return false;
}
function getPropertyKey(prop) {
  if (t.isIdentifier(prop.key)) {
    return prop.key.name;
  } else if (t.isStringLiteral(prop.key)) {
    return prop.key.value;
  } else if (t.isNumericLiteral(prop.key)) {
    return String(prop.key.value);
  }
  return String(prop.key);
}

// src/cli/loaders/inject-locale.ts
import _19 from "lodash";

// ../../node_modules/.pnpm/@isaacs+balanced-match@4.0.1/node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a, b, str) => {
  const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
  const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
  const r = ma !== null && mb != null && range(ma, mb, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + ma.length, r[1]),
    post: str.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
var range = (a, b, str) => {
  let begs, beg, left, right = void 0, result;
  let ai = str.indexOf(a);
  let bi = str.indexOf(b, ai + 1);
  let i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i === ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== void 0)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// ../../node_modules/.pnpm/@isaacs+brace-expansion@5.0.0/node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand_(str, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str);
      }
      return [str];
    }
    let n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1 && n[0] !== void 0) {
        n = expand_(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map((p) => m.pre + n[0] + p);
        }
      }
    }
    let N;
    if (isSequence && n[0] !== void 0 && n[1] !== void 0) {
      const x = numeric(n[0]);
      const y = numeric(n[1]);
      const width = Math.max(n[0].length, n[1].length);
      let incr = n.length === 3 && n[2] !== void 0 ? Math.abs(numeric(n[2])) : 1;
      let test = lte;
      const reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n.some(isPadded);
      N = [];
      for (let i = x; test(i, y); i += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z3 = new Array(need + 1).join("0");
              if (i < 0) {
                c = "-" + z3 + c.slice(1);
              } else {
                c = z3 + c;
              }
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (let j = 0; j < n.length; j++) {
        N.push.apply(N, expand_(n[j], false));
      }
    }
    for (let j = 0; j < N.length; j++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob3, position) => {
  const pos = position;
  if (glob3.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i < glob3.length) {
    const c = glob3.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate = true;
      i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob3.startsWith(cls, i)) {
          if (rangeStart) {
            return ["$.", false, glob3.length - pos, true];
          }
          i += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i++;
      continue;
    }
    if (glob3.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-"));
      i += 2;
      continue;
    }
    if (glob3.startsWith("-", i + 1)) {
      rangeStart = c;
      i += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i++;
  }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob3.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob3 = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob3.toUpperCase() !== glob3.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob3
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _36, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _36, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob3, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob3.length; i++) {
      const c = glob3.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob3.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob3, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob3 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob3), !!hasMagic, uflag];
  }
};

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path13 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path13.win32.sep : path13.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._36) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _36, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open3, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open3 + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// src/cli/loaders/inject-locale.ts
function createInjectLocaleLoader(injectLocaleKeys) {
  return createLoader({
    async pull(locale, data) {
      if (!injectLocaleKeys) {
        return data;
      }
      const omitKeys = _getKeysWithLocales(data, injectLocaleKeys, locale);
      const result = _19.omit(data, omitKeys);
      return result;
    },
    async push(locale, data, originalInput, originalLocale) {
      if (!injectLocaleKeys || !originalInput) {
        return data;
      }
      const localeKeys = _getKeysWithLocales(
        originalInput,
        injectLocaleKeys,
        originalLocale
      );
      localeKeys.forEach((key) => {
        _19.set(data, key, locale);
      });
      return data;
    }
  });
}
function _getKeysWithLocales(data, injectLocaleKeys, locale) {
  const allKeys = _getAllKeys(data);
  return allKeys.filter((key) => {
    return injectLocaleKeys.some((pattern) => minimatch(key, pattern)) && _19.get(data, key) === locale;
  });
}
function _getAllKeys(obj, prefix = "") {
  let keys = [];
  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
    const path19 = prefix ? `${prefix}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
      keys = keys.concat(_getAllKeys(obj[key], path19));
    } else {
      keys.push(path19);
    }
  }
  return keys;
}

// src/cli/loaders/locked-keys.ts
import _20 from "lodash";

// src/cli/utils/key-matching.ts
function matchesKeyPattern(key, patterns) {
  return patterns.some(
    (pattern) => key.startsWith(pattern) || minimatch(key, pattern)
  );
}
function formatDisplayValue(value, maxLength = 50) {
  if (typeof value === "string") {
    return value.length > maxLength ? `${value.substring(0, maxLength)}...` : value;
  }
  return JSON.stringify(value);
}

// src/cli/loaders/locked-keys.ts
function createLockedKeysLoader(lockedKeys) {
  return createLoader({
    pull: async (locale, data) => {
      return _20.pickBy(
        data,
        (value, key) => !matchesKeyPattern(key, lockedKeys)
      );
    },
    push: async (locale, data, originalInput) => {
      const lockedSubObject = _20.chain(originalInput).pickBy((value, key) => matchesKeyPattern(key, lockedKeys)).value();
      return _20.merge({}, data, lockedSubObject);
    }
  });
}

// src/cli/loaders/mdx2/frontmatter-split.ts
import matter2 from "gray-matter";
import YAML4 from "yaml";
function createMdxFrontmatterSplitLoader() {
  const fmEngine = createFmEngine();
  return createLoader({
    async pull(locale, input2) {
      const source = input2 || "";
      const { data: frontmatter, content } = fmEngine.parse(source);
      return {
        frontmatter,
        content
      };
    },
    async push(locale, data) {
      const { frontmatter = {}, content = "" } = data || {};
      const result = fmEngine.stringify(content, frontmatter).trim();
      return result;
    }
  });
}
function createFmEngine() {
  const yamlEngine2 = {
    parse: (str) => YAML4.parse(str),
    stringify: (obj) => YAML4.stringify(obj, { defaultStringType: "PLAIN" })
  };
  return {
    parse: (input2) => matter2(input2, {
      engines: {
        yaml: yamlEngine2
      }
    }),
    stringify: (content, frontmatter) => matter2.stringify(content, frontmatter, {
      engines: {
        yaml: yamlEngine2
      }
    })
  };
}

// src/cli/utils/md5.ts
import { MD5 } from "object-hash";
function md5(input2) {
  return MD5(input2);
}

// src/cli/loaders/mdx2/code-placeholder.ts
import _21 from "lodash";
var fenceRegex = /([ \t]*)(^>\s*)?```([\s\S]*?)```/gm;
var inlineCodeRegex = /(?<!`)`([^`\r\n]+?)`(?!`)/g;
var imageRegex = /([ \t]*)(^>\s*)?!\[[^\]]*?\]\(([^()]*(\([^()]*\)[^()]*)*)\)/gm;
function ensureSurroundingImageNewlines(_content) {
  let found = false;
  let content = _content;
  let workingContent = content;
  do {
    found = false;
    const matches = workingContent.match(imageRegex);
    if (matches) {
      const match2 = matches[0];
      const replacement = match2.trim().startsWith(">") ? match2 : `

${match2}

`;
      content = content.replaceAll(match2, () => replacement);
      workingContent = workingContent.replaceAll(match2, "");
      found = true;
    }
  } while (found);
  content = _21.chain(content).split("\n\n").map((section) => _21.trim(section, "\n")).filter(Boolean).join("\n\n").value();
  return content;
}
function ensureTrailingFenceNewline(_content) {
  let found = false;
  let content = _content;
  let workingContent = content;
  do {
    found = false;
    const matches = workingContent.match(fenceRegex);
    if (matches) {
      const match2 = matches[0];
      const replacement = match2.trim().startsWith(">") ? match2 : `

${match2}

`;
      content = content.replaceAll(match2, () => replacement);
      workingContent = workingContent.replaceAll(match2, "");
      found = true;
    }
  } while (found);
  content = _21.chain(content).split("\n\n").map((section) => _21.trim(section, "\n")).filter(Boolean).join("\n\n").value();
  return content;
}
function extractCodePlaceholders(content) {
  let finalContent = content;
  finalContent = ensureTrailingFenceNewline(finalContent);
  finalContent = ensureSurroundingImageNewlines(finalContent);
  const codePlaceholders = {};
  const codeBlockMatches = finalContent.matchAll(fenceRegex);
  for (const match2 of codeBlockMatches) {
    const codeBlock = match2[0];
    const codeBlockHash = md5(codeBlock);
    const placeholder = `---CODE-PLACEHOLDER-${codeBlockHash}---`;
    codePlaceholders[placeholder] = codeBlock;
    const replacement = codeBlock.trim().startsWith(">") ? `> ${placeholder}` : `${placeholder}`;
    finalContent = finalContent.replace(codeBlock, () => replacement);
  }
  const inlineCodeMatches = finalContent.matchAll(inlineCodeRegex);
  for (const match2 of inlineCodeMatches) {
    const inlineCode = match2[0];
    const inlineCodeHash = md5(inlineCode);
    const placeholder = `---INLINE-CODE-PLACEHOLDER-${inlineCodeHash}---`;
    codePlaceholders[placeholder] = inlineCode;
    const replacement = placeholder;
    finalContent = finalContent.replace(inlineCode, () => replacement);
  }
  return {
    content: finalContent,
    codePlaceholders
  };
}
function createMdxCodePlaceholderLoader() {
  const globalPlaceholderRegistry = {};
  return createLoader({
    async pull(locale, input2) {
      const response = extractCodePlaceholders(input2);
      Object.assign(globalPlaceholderRegistry, response.codePlaceholders);
      return response.content;
    },
    async push(locale, data, originalInput, originalLocale, pullInput) {
      const sourceInfo = extractCodePlaceholders(originalInput ?? "");
      const currentInfo = extractCodePlaceholders(pullInput ?? "");
      const codePlaceholders = _21.merge(
        sourceInfo.codePlaceholders,
        currentInfo.codePlaceholders,
        globalPlaceholderRegistry
        // Include ALL placeholders ever created
      );
      let result = data;
      for (const [placeholder, original] of Object.entries(codePlaceholders)) {
        const replacement = original.startsWith(">") ? _21.trimStart(original, "> ") : original;
        result = result.replaceAll(placeholder, () => replacement);
      }
      return result;
    }
  });
}

// src/cli/loaders/mdx2/localizable-document.ts
function createLocalizableMdxDocumentLoader() {
  return createLoader({
    async pull(_locale, input2) {
      return {
        meta: input2.frontmatter,
        content: input2.sections
      };
    },
    async push(_locale, data, originalInput, _originalLocale, pullInput) {
      const result = {
        frontmatter: data.meta || {},
        sections: data.content || {}
      };
      return result;
    }
  });
}

// src/cli/loaders/mdx2/sections-split-2.ts
import _22 from "lodash";
function createMdxSectionsSplit2Loader() {
  return createLoader({
    async pull(locale, input2) {
      const sections = _22.chain(input2.content).split("\n\n").filter(Boolean).map((section, index) => [index, section]).fromPairs().value();
      const result = {
        frontmatter: input2.frontmatter,
        sections
      };
      return result;
    },
    async push(locale, data, originalInput, _originalLocale, pullInput) {
      const content = _22.chain(data.sections).values().join("\n\n").value();
      const result = {
        frontmatter: data.frontmatter,
        codePlaceholders: pullInput?.codePlaceholders || {},
        content
      };
      return result;
    }
  });
}

// src/cli/loaders/locked-patterns.ts
function extractLockedPatterns(content, patterns = []) {
  let finalContent = content;
  const lockedPlaceholders = {};
  if (!patterns || patterns.length === 0) {
    return { content: finalContent, lockedPlaceholders };
  }
  for (const patternStr of patterns) {
    try {
      const pattern = new RegExp(patternStr, "gm");
      const matches = Array.from(finalContent.matchAll(pattern));
      for (const match2 of matches) {
        const matchedText = match2[0];
        const matchHash = md5(matchedText);
        const placeholder = `---LOCKED-PATTERN-${matchHash}---`;
        lockedPlaceholders[placeholder] = matchedText;
        finalContent = finalContent.replace(matchedText, placeholder);
      }
    } catch (error) {
      console.warn(`Invalid regex pattern: ${patternStr}`);
    }
  }
  return {
    content: finalContent,
    lockedPlaceholders
  };
}
function createLockedPatternsLoader(defaultPatterns) {
  return createLoader({
    async pull(locale, input2, initCtx, originalLocale) {
      const patterns = defaultPatterns || [];
      const { content } = extractLockedPatterns(input2 || "", patterns);
      return content;
    },
    async push(locale, data, originalInput, originalLocale, pullInput, pullOutput) {
      const patterns = defaultPatterns || [];
      if (!pullInput) {
        return data;
      }
      const { lockedPlaceholders } = extractLockedPatterns(
        pullInput,
        patterns
      );
      let result = data;
      for (const [placeholder, original] of Object.entries(
        lockedPlaceholders
      )) {
        result = result.replaceAll(placeholder, original);
      }
      return result;
    }
  });
}

// src/cli/loaders/ignored-keys.ts
import _23 from "lodash";
function createIgnoredKeysLoader(ignoredKeys) {
  return createLoader({
    pull: async (locale, data) => {
      const result = _23.omitBy(
        data,
        (value, key) => matchesKeyPattern(key, ignoredKeys)
      );
      return result;
    },
    push: async (locale, data, originalInput, originalLocale, pullInput) => {
      const result = _23.omitBy(
        data,
        (value, key) => matchesKeyPattern(key, ignoredKeys)
      );
      return result;
    }
  });
}

// src/cli/loaders/ejs.ts
function parseEjsForTranslation(input2) {
  const translatable = {};
  let counter = 0;
  const ejsTagRegex = /<%[\s\S]*?%>/g;
  const parts = [];
  let lastIndex = 0;
  let match2;
  while ((match2 = ejsTagRegex.exec(input2)) !== null) {
    if (match2.index > lastIndex) {
      parts.push({
        type: "text",
        content: input2.slice(lastIndex, match2.index)
      });
    }
    parts.push({
      type: "ejs",
      content: match2[0]
    });
    lastIndex = match2.index + match2[0].length;
  }
  if (lastIndex < input2.length) {
    parts.push({
      type: "text",
      content: input2.slice(lastIndex)
    });
  }
  let template = "";
  for (const part of parts) {
    if (part.type === "ejs") {
      template += part.content;
    } else {
      const textContent = part.content;
      const htmlTagRegex = /<[^>]+>/g;
      const textParts = [];
      let lastTextIndex = 0;
      let htmlMatch;
      while ((htmlMatch = htmlTagRegex.exec(textContent)) !== null) {
        if (htmlMatch.index > lastTextIndex) {
          const textBefore = textContent.slice(lastTextIndex, htmlMatch.index);
          if (textBefore.trim()) {
            textParts.push({ type: "text", content: textBefore });
          } else {
            textParts.push({ type: "html", content: textBefore });
          }
        }
        textParts.push({ type: "html", content: htmlMatch[0] });
        lastTextIndex = htmlMatch.index + htmlMatch[0].length;
      }
      if (lastTextIndex < textContent.length) {
        const remainingText = textContent.slice(lastTextIndex);
        if (remainingText.trim()) {
          textParts.push({ type: "text", content: remainingText });
        } else {
          textParts.push({ type: "html", content: remainingText });
        }
      }
      if (textParts.length === 0) {
        const trimmedContent = textContent.trim();
        if (trimmedContent) {
          textParts.push({ type: "text", content: textContent });
        } else {
          textParts.push({ type: "html", content: textContent });
        }
      }
      for (const textPart of textParts) {
        if (textPart.type === "text") {
          const trimmedContent = textPart.content.trim();
          if (trimmedContent) {
            const key = `text_${counter++}`;
            translatable[key] = trimmedContent;
            template += textPart.content.replace(
              trimmedContent,
              `__LINGO_PLACEHOLDER_${key}__`
            );
          } else {
            template += textPart.content;
          }
        } else {
          template += textPart.content;
        }
      }
    }
  }
  return { content: template, translatable };
}
function reconstructEjsWithTranslation(template, translatable) {
  let result = template;
  for (const [key, value] of Object.entries(translatable)) {
    const placeholder = `__LINGO_PLACEHOLDER_${key}__`;
    result = result.replace(new RegExp(placeholder, "g"), value);
  }
  return result;
}
function createEjsLoader() {
  return createLoader({
    async pull(locale, input2) {
      if (!input2 || input2.trim() === "") {
        return {};
      }
      try {
        const parseResult = parseEjsForTranslation(input2);
        return parseResult.translatable;
      } catch (error) {
        console.warn(
          "Warning: Could not parse EJS template, treating as plain text"
        );
        return { content: input2.trim() };
      }
    },
    async push(locale, data, originalInput) {
      if (!originalInput) {
        return Object.values(data).join("\n");
      }
      try {
        const parseResult = parseEjsForTranslation(originalInput);
        const mergedTranslatable = { ...parseResult.translatable, ...data };
        return reconstructEjsWithTranslation(
          parseResult.content,
          mergedTranslatable
        );
      } catch (error) {
        console.warn(
          "Warning: Could not reconstruct EJS template, returning translated data"
        );
        return Object.values(data).join("\n");
      }
    }
  });
}

// src/cli/loaders/ensure-key-order.ts
import _24 from "lodash";
function createEnsureKeyOrderLoader() {
  return createLoader({
    pull: async (_locale, input2) => {
      return input2;
    },
    push: async (_locale, data, originalInput) => {
      if (!originalInput || !data) {
        return data;
      }
      return reorderKeys(data, originalInput);
    }
  });
}
function reorderKeys(data, originalInput) {
  if (_24.isArray(originalInput) && _24.isArray(data)) {
    return data.map((item, idx) => reorderKeys(item, originalInput[idx] ?? {}));
  }
  if (!_24.isObject(data) || _24.isArray(data) || _24.isDate(data)) {
    return data;
  }
  const orderedData = {};
  const originalKeys = Object.keys(originalInput);
  const dataKeys = new Set(Object.keys(data));
  for (const key of originalKeys) {
    if (dataKeys.has(key)) {
      orderedData[key] = reorderKeys(data[key], originalInput[key]);
      dataKeys.delete(key);
    }
  }
  return orderedData;
}

// src/cli/loaders/txt.ts
function createTxtLoader() {
  return createLoader({
    async pull(locale, input2) {
      const result = {};
      if (input2 !== void 0 && input2 !== null && input2 !== "") {
        const lines = input2.split("\n");
        lines.forEach((line, index) => {
          result[String(index + 1)] = line;
        });
      }
      return result;
    },
    async push(locale, payload) {
      const sortedEntries = Object.entries(payload).sort(
        ([a], [b]) => parseInt(a) - parseInt(b)
      );
      return sortedEntries.map(([_36, value]) => value).join("\n");
    }
  });
}

// src/cli/loaders/json-dictionary.ts
import _25 from "lodash";
var TOP_LEVEL_KEY = "--content--";
function createJsonDictionaryLoader() {
  return createLoader({
    pull: async (locale, input2) => {
      const result = extractTranslatables(input2, locale);
      if (typeof result === "string") {
        return { [TOP_LEVEL_KEY]: result };
      }
      return result;
    },
    push: async (locale, data, originalInput, originalLocale) => {
      if (!originalInput) {
        throw new Error("Error while parsing json-dictionary bucket");
      }
      const input2 = _25.cloneDeep(originalInput);
      if (Object.keys(data).length === 1 && Object.keys(data)[0] === TOP_LEVEL_KEY) {
        setNestedLocale(
          { [TOP_LEVEL_KEY]: input2 },
          [TOP_LEVEL_KEY],
          locale,
          data[TOP_LEVEL_KEY],
          originalLocale
        );
        return input2;
      }
      function walk(obj, dataNode, path19 = []) {
        if (Array.isArray(obj) && Array.isArray(dataNode)) {
          obj.forEach(
            (item, idx) => walk(item, dataNode[idx], [...path19, String(idx)])
          );
        } else if (obj && typeof obj === "object" && dataNode && typeof dataNode === "object" && !Array.isArray(dataNode)) {
          for (const key of Object.keys(obj)) {
            if (dataNode.hasOwnProperty(key)) {
              walk(obj[key], dataNode[key], [...path19, key]);
            }
          }
        } else if (obj && typeof obj === "object" && !Array.isArray(obj) && typeof dataNode === "string") {
          setNestedLocale(input2, path19, locale, dataNode, originalLocale);
        }
      }
      walk(input2, data);
      return input2;
    }
  });
}
function extractTranslatables(obj, locale) {
  if (Array.isArray(obj)) {
    return obj.map((item) => extractTranslatables(item, locale));
  } else if (isTranslatableObject(obj, locale)) {
    return obj[locale];
  } else if (obj && typeof obj === "object") {
    const result = {};
    for (const key of Object.keys(obj)) {
      const value = extractTranslatables(obj[key], locale);
      if (typeof value === "object" && value !== null && Object.keys(value).length > 0 || Array.isArray(value) && value.length > 0 || typeof value === "string" && value.length > 0) {
        result[key] = value;
      }
    }
    return result;
  }
  return void 0;
}
function isTranslatableObject(obj, locale) {
  return obj && typeof obj === "object" && !Array.isArray(obj) && Object.prototype.hasOwnProperty.call(obj, locale);
}
function setNestedLocale(obj, path19, locale, value, originalLocale) {
  let curr = obj;
  for (let i = 0; i < path19.length - 1; i++) {
    const key = path19[i];
    if (!(key in curr)) curr[key] = {};
    curr = curr[key];
  }
  const last = path19[path19.length - 1];
  if (curr[last] && typeof curr[last] === "object") {
    curr[last][locale] = value;
    if (originalLocale && curr[last][originalLocale]) {
      const entries = Object.entries(curr[last]);
      const first = entries.filter(([k]) => k === originalLocale);
      const rest = entries.filter(([k]) => k !== originalLocale).sort(([a], [b]) => a.localeCompare(b));
      const ordered = [...first, ...rest];
      const reordered = {};
      for (const [k, v] of ordered) {
        reordered[k] = v;
      }
      curr[last] = reordered;
    }
  }
}

// src/cli/loaders/index.ts
function createBucketLoader(bucketType, bucketPathPattern, options, lockedKeys, lockedPatterns, ignoredKeys) {
  switch (bucketType) {
    default:
      throw new Error(`Unsupported bucket type: ${bucketType}`);
    case "android":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createAndroidLoader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "csv":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createCsvLoader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "html":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "html", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createHtmlLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "ejs":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createEjsLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "json":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "json", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createJsonLoader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createInjectLocaleLoader(options.injectLocale),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "json5":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createJson5Loader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createInjectLocaleLoader(options.injectLocale),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "jsonc":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createJsoncLoader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createInjectLocaleLoader(options.injectLocale),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "markdown":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "markdown", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createMarkdownLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "markdoc":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createMarkdocLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "mdx":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "mdx", bucketPathPattern),
        createMdxCodePlaceholderLoader(),
        createLockedPatternsLoader(lockedPatterns),
        createMdxFrontmatterSplitLoader(),
        createMdxSectionsSplit2Loader(),
        createLocalizableMdxDocumentLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "po":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createPoLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createVariableLoader({ type: "python" }),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "properties":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createPropertiesLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xcode-strings":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createXcodeStringsLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xcode-stringsdict":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createXcodeStringsdictLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xcode-xcstrings":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createPlutilJsonTextLoader(),
        createLockedPatternsLoader(lockedPatterns),
        createJsonLoader(),
        createXcodeXcstringsLoader(options.defaultLocale),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createVariableLoader({ type: "ieee" }),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xcode-xcstrings-v2":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createPlutilJsonTextLoader(),
        createLockedPatternsLoader(lockedPatterns),
        createJsonLoader(),
        createXcodeXcstringsLoader(options.defaultLocale),
        createXcodeXcstringsV2Loader(options.defaultLocale),
        createFlatLoader({ shouldPreserveObject: isICUPluralObject }),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createVariableLoader({ type: "ieee" }),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "yaml":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "yaml", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createYamlLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "yaml-root-key":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "yaml", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createYamlLoader(),
        createRootKeyLoader(true),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "flutter":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "json", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createJsonLoader(),
        createEnsureKeyOrderLoader(),
        createFlutterLoader(),
        createFlatLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xliff":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createXliffLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "xml":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createXmlLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "srt":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createSrtLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "dato":
      return composeLoaders(
        createDatoLoader(bucketPathPattern),
        createSyncLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "vtt":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createVttLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "php":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createPhpLoader(),
        createSyncLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "vue-json":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createVueJsonLoader(),
        createSyncLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "typescript":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(
          options.formatter,
          "typescript",
          bucketPathPattern
        ),
        createLockedPatternsLoader(lockedPatterns),
        createTypescriptLoader(),
        createFlatLoader(),
        createEnsureKeyOrderLoader(),
        createSyncLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "txt":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createTxtLoader(),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
    case "json-dictionary":
      return composeLoaders(
        createTextFileLoader(bucketPathPattern),
        createFormatterLoader(options.formatter, "json", bucketPathPattern),
        createLockedPatternsLoader(lockedPatterns),
        createJsonLoader(),
        createJsonDictionaryLoader(),
        createEnsureKeyOrderLoader(),
        createFlatLoader(),
        createInjectLocaleLoader(options.injectLocale),
        createLockedKeysLoader(lockedKeys || []),
        createIgnoredKeysLoader(ignoredKeys || []),
        createSyncLoader(),
        createUnlocalizableLoader(options.returnUnlocalizedKeys)
      );
  }
}

// src/cli/cmd/show/_shared-key-command.ts
async function executeKeyCommand(i18nConfig, buckets, options, config) {
  let hasAnyKeys = false;
  for (const bucket of buckets) {
    if (options.bucket && bucket.type !== options.bucket) {
      continue;
    }
    const keyPatterns = bucket[config.filterType];
    if (!keyPatterns || keyPatterns.length === 0) {
      continue;
    }
    hasAnyKeys = true;
    console.log(`
Bucket: ${bucket.type}`);
    console.log(
      `${capitalize(config.displayName)} key patterns: ${keyPatterns.join(", ")}`
    );
    for (const bucketConfig of bucket.paths) {
      const sourceLocale = resolveOverriddenLocale3(
        i18nConfig.locale.source,
        bucketConfig.delimiter
      );
      const sourcePath = bucketConfig.pathPattern.replace(
        /\[locale\]/g,
        sourceLocale
      );
      try {
        const loader = createBucketLoader(
          bucket.type,
          bucketConfig.pathPattern,
          {
            defaultLocale: sourceLocale,
            injectLocale: bucket.injectLocale
          },
          [],
          // Don't apply any filtering when reading
          [],
          []
        );
        loader.setDefaultLocale(sourceLocale);
        const data = await loader.pull(sourceLocale);
        if (!data || Object.keys(data).length === 0) {
          continue;
        }
        const matchedEntries = Object.entries(data).filter(
          ([key]) => matchesKeyPattern(key, keyPatterns)
        );
        if (matchedEntries.length > 0) {
          console.log(`
Matches in ${sourcePath}:`);
          for (const [key, value] of matchedEntries) {
            const displayValue = formatDisplayValue(value);
            console.log(`  - ${key}: ${displayValue}`);
          }
          console.log(
            `Total: ${matchedEntries.length} ${config.displayName} key(s)`
          );
        }
      } catch (error) {
        console.error(`  Error reading ${sourcePath}: ${error.message}`);
      }
    }
  }
  if (!hasAnyKeys) {
    if (options.bucket) {
      console.log(
        `No ${config.displayName} keys configured for bucket: ${options.bucket}`
      );
    } else {
      console.log(`No ${config.displayName} keys configured in any bucket.`);
    }
  }
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// src/cli/cmd/show/locked-keys.ts
var locked_keys_default = new Command7().command("locked-keys").description(
  "Show which key-value pairs in source files match lockedKeys patterns"
).option("--bucket <name>", "Only show locked keys for a specific bucket").helpOption("-h, --help", "Show help").action(async (options) => {
  const ora = Ora7();
  try {
    const i18nConfig = await getConfig();
    if (!i18nConfig) {
      throw new CLIError({
        message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
        docUrl: "i18nNotFound"
      });
    }
    const buckets = getBuckets(i18nConfig);
    await executeKeyCommand(i18nConfig, buckets, options, {
      filterType: "lockedKeys",
      displayName: "locked"
    });
  } catch (error) {
    ora.fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/show/ignored-keys.ts
import { Command as Command8 } from "interactive-commander";
import Ora8 from "ora";
var ignored_keys_default = new Command8().command("ignored-keys").description(
  "Show which key-value pairs in source files match ignoredKeys patterns"
).option("--bucket <name>", "Only show ignored keys for a specific bucket").helpOption("-h, --help", "Show help").action(async (options) => {
  const ora = Ora8();
  try {
    const i18nConfig = await getConfig();
    if (!i18nConfig) {
      throw new CLIError({
        message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
        docUrl: "i18nNotFound"
      });
    }
    const buckets = getBuckets(i18nConfig);
    await executeKeyCommand(i18nConfig, buckets, options, {
      filterType: "ignoredKeys",
      displayName: "ignored"
    });
  } catch (error) {
    ora.fail(error.message);
    process.exit(1);
  }
});

// src/cli/cmd/show/index.ts
var show_default = new Command9().command("show").description("Display configuration, locales, and file paths").helpOption("-h, --help", "Show help").addCommand(config_default).addCommand(locale_default).addCommand(files_default).addCommand(locked_keys_default).addCommand(ignored_keys_default);

// src/cli/cmd/config/index.ts
import { Command as Command13 } from "interactive-commander";

// src/cli/cmd/config/set.ts
import { Command as Command10 } from "interactive-commander";
import chalk2 from "chalk";
import dedent from "dedent";
import _26 from "lodash";
var set_default = new Command10().name("set").description("Set or update a CLI setting in ~/.lingodotdevrc").addHelpText("afterAll", `
Available keys:
  ${SETTINGS_KEYS.join("\n  ")}`).argument(
  "<key>",
  "Configuration key to set (dot notation, e.g., auth.apiKey)"
).argument("<value>", "The configuration value to set").helpOption("-h, --help", "Show help").action(async (key, value) => {
  if (!SETTINGS_KEYS.includes(key)) {
    console.error(
      dedent`
          ${chalk2.red("\u2716")} Unknown configuration key: ${chalk2.bold(key)}
          Run ${chalk2.dim("lingo.dev config set --help")} to see available keys.
        `
    );
    process.exitCode = 1;
    return;
  }
  const current = loadSystemSettings();
  const updated = _26.cloneDeep(current);
  _26.set(updated, key, value);
  try {
    saveSettings(updated);
    console.log(`${chalk2.green("\u2714")} Set ${chalk2.bold(key)}`);
  } catch (err) {
    console.error(
      chalk2.red(
        `\u2716 Failed to save configuration: ${chalk2.dim(
          err instanceof Error ? err.message : String(err)
        )}`
      )
    );
    process.exitCode = 1;
  }
});

// src/cli/cmd/config/unset.ts
import { Command as Command11 } from "interactive-commander";
import chalk3 from "chalk";
import dedent2 from "dedent";
import _27 from "lodash";
var unset_default = new Command11().name("unset").description("Remove a CLI setting from ~/.lingodotdevrc").addHelpText("afterAll", `
Available keys:
  ${SETTINGS_KEYS.join("\n  ")}`).argument(
  "<key>",
  "Configuration key to remove (must match one of the available keys listed below)"
).helpOption("-h, --help", "Show help").action(async (key) => {
  if (!SETTINGS_KEYS.includes(key)) {
    console.error(
      dedent2`
          ${chalk3.red("\u2716")} Unknown configuration key: ${chalk3.bold(key)}
          Run ${chalk3.dim(
        "lingo.dev config unset --help"
      )} to see available keys.
        `
    );
    process.exitCode = 1;
    return;
  }
  const settings = loadSystemSettings();
  const currentValue = _27.get(settings, key);
  if (!_27.trim(String(currentValue || ""))) {
    console.log(`${chalk3.cyan("\u2139")} ${chalk3.bold(key)} is not set.`);
    return;
  } else {
    const updated = _27.cloneDeep(settings);
    _27.unset(updated, key);
    try {
      saveSettings(updated);
      console.log(
        `${chalk3.green("\u2714")} Removed configuration key ${chalk3.bold(key)}`
      );
    } catch (err) {
      console.error(
        chalk3.red(
          `\u2716 Failed to save configuration: ${chalk3.dim(
            err instanceof Error ? err.message : String(err)
          )}`
        )
      );
      process.exitCode = 1;
    }
  }
});

// src/cli/cmd/config/get.ts
import { Command as Command12 } from "interactive-commander";
import chalk4 from "chalk";
import _28 from "lodash";
import dedent3 from "dedent";
var get_default = new Command12().name("get").description("Display the value of a CLI setting from ~/.lingodotdevrc").addHelpText("afterAll", `
Available keys:
  ${SETTINGS_KEYS.join("\n  ")}`).argument(
  "<key>",
  "Configuration key to read (choose from the available keys listed below)"
).helpOption("-h, --help", "Show help").action(async (key) => {
  if (!SETTINGS_KEYS.includes(key)) {
    console.error(
      dedent3`
          ${chalk4.red("\u2716")} Unknown configuration key: ${chalk4.bold(key)}
          Run ${chalk4.dim("lingo.dev config get --help")} to see available keys.
        `
    );
    process.exitCode = 1;
    return;
  }
  const settings = loadSystemSettings();
  const value = _28.get(settings, key);
  if (!value) {
    console.log(`${chalk4.cyan("\u2139")} ${chalk4.bold(key)} is not set.`);
    return;
  }
  if (typeof value === "object") {
    console.log(JSON.stringify(value, null, 2));
  } else {
    console.log(value);
  }
});

// src/cli/cmd/config/index.ts
var config_default2 = new Command13().command("config").description(
  "Manage CLI settings (authentication, API keys) stored in ~/.lingodotdevrc"
).helpOption("-h, --help", "Show help").addCommand(set_default).addCommand(unset_default).addCommand(get_default);

// src/cli/cmd/i18n.ts
import {
  bucketTypeSchema,
  localeCodeSchema,
  resolveOverriddenLocale as resolveOverriddenLocale4
} from "@lingo.dev/_spec";
import { Command as Command14 } from "interactive-commander";
import Z3 from "zod";
import _31 from "lodash";
import Ora9 from "ora";
import chalk6 from "chalk";
import { createTwoFilesPatch } from "diff";
import inquirer2 from "inquirer";
import externalEditor from "external-editor";

// src/cli/processor/index.ts
import chalk5 from "chalk";
import dedent4 from "dedent";

// src/cli/processor/lingo.ts
import { LingoDotDevEngine } from "@lingo.dev/_sdk";
function createLingoLocalizer(params) {
  return async (input2, onProgress) => {
    if (!Object.keys(input2.processableData).length) {
      return input2.processableData;
    }
    const lingo = new LingoDotDevEngine({
      apiKey: params.apiKey,
      apiUrl: params.apiUrl
    });
    const result = await lingo.localizeObject(
      input2.processableData,
      {
        sourceLocale: input2.sourceLocale,
        targetLocale: input2.targetLocale,
        reference: {
          [input2.sourceLocale]: input2.sourceData,
          [input2.targetLocale]: input2.targetData
        }
      },
      onProgress
    );
    return result;
  };
}

// src/cli/processor/basic.ts
import { generateText } from "ai";
import _29 from "lodash";
function createBasicTranslator(model, systemPrompt, settings = {}) {
  return async (input2, onProgress) => {
    const chunks = extractPayloadChunks(input2.processableData);
    const subResults = [];
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const result2 = await doJob({
        ...input2,
        processableData: chunk
      });
      subResults.push(result2);
      onProgress(i / chunks.length * 100, chunk, result2);
    }
    const result = _29.merge({}, ...subResults);
    return result;
  };
  async function doJob(input2) {
    if (!Object.keys(input2.processableData).length) {
      return input2.processableData;
    }
    const response = await generateText({
      model,
      ...settings,
      messages: [
        {
          role: "system",
          content: JSON.stringify({
            role: "system",
            content: systemPrompt.replaceAll("{source}", input2.sourceLocale).replaceAll("{target}", input2.targetLocale)
          })
        },
        {
          role: "user",
          content: JSON.stringify({
            sourceLocale: "en",
            targetLocale: "es",
            data: {
              message: "Hello, world!"
            }
          })
        },
        {
          role: "assistant",
          content: JSON.stringify({
            sourceLocale: "en",
            targetLocale: "es",
            data: {
              message: "Hola, mundo!"
            }
          })
        },
        {
          role: "user",
          content: JSON.stringify({
            sourceLocale: input2.sourceLocale,
            targetLocale: input2.targetLocale,
            data: input2.processableData
          })
        }
      ]
    });
    const result = JSON.parse(response.text);
    return result?.data || {};
  }
}
function extractPayloadChunks(payload) {
  const idealBatchItemSize = 250;
  const batchSize = 25;
  const result = [];
  let currentChunk = {};
  let currentChunkItemCount = 0;
  const payloadEntries = Object.entries(payload);
  for (let i = 0; i < payloadEntries.length; i++) {
    const [key, value] = payloadEntries[i];
    currentChunk[key] = value;
    currentChunkItemCount++;
    const currentChunkSize = countWordsInRecord(currentChunk);
    if (currentChunkSize > idealBatchItemSize || currentChunkItemCount >= batchSize || i === payloadEntries.length - 1) {
      result.push(currentChunk);
      currentChunk = {};
      currentChunkItemCount = 0;
    }
  }
  return result;
}
function countWordsInRecord(payload) {
  if (Array.isArray(payload)) {
    return payload.reduce((acc, item) => acc + countWordsInRecord(item), 0);
  } else if (typeof payload === "object" && payload !== null) {
    return Object.values(payload).reduce(
      (acc, item) => acc + countWordsInRecord(item),
      0
    );
  } else if (typeof payload === "string") {
    return payload.trim().split(/\s+/).filter(Boolean).length;
  } else {
    return 0;
  }
}

// src/cli/processor/index.ts
import { createOpenAI } from "@ai-sdk/openai";
import { createAnthropic } from "@ai-sdk/anthropic";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { createMistral } from "@ai-sdk/mistral";
import { createOllama } from "ollama-ai-provider";
function createProcessor(provider, params) {
  if (!provider) {
    const result = createLingoLocalizer(params);
    return result;
  } else {
    const model = getPureModelProvider(provider);
    const settings = provider.settings || {};
    const result = createBasicTranslator(model, provider.prompt, settings);
    return result;
  }
}
function getPureModelProvider(provider) {
  const createMissingKeyErrorMessage = (providerId, envVar) => dedent4`
  You're trying to use raw ${chalk5.dim(providerId)} API for translation. ${envVar ? `However, ${chalk5.dim(envVar)} environment variable is not set.` : "However, that provider is unavailable."}

  To fix this issue:
  1. ${envVar ? `Set ${chalk5.dim(envVar)} in your environment variables` : "Set the environment variable for your provider (if required)"}, or
  2. Remove the ${chalk5.italic(
    "provider"
  )} node from your i18n.json configuration to switch to ${chalk5.hex(
    colors.green
  )("Lingo.dev")}

  ${chalk5.hex(colors.blue)("Docs: https://lingo.dev/go/docs")}
`;
  const createUnsupportedProviderErrorMessage = (providerId) => dedent4`
  You're trying to use unsupported provider: ${chalk5.dim(providerId)}.

  To fix this issue:
  1. Switch to one of the supported providers, or
  2. Remove the ${chalk5.italic(
    "provider"
  )} node from your i18n.json configuration to switch to ${chalk5.hex(
    colors.green
  )("Lingo.dev")}

  ${chalk5.hex(colors.blue)("Docs: https://lingo.dev/go/docs")}
  `;
  switch (provider?.id) {
    case "openai": {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error(
          createMissingKeyErrorMessage("OpenAI", "OPENAI_API_KEY")
        );
      }
      return createOpenAI({
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: provider.baseUrl
      })(provider.model);
    }
    case "anthropic": {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error(
          createMissingKeyErrorMessage("Anthropic", "ANTHROPIC_API_KEY")
        );
      }
      return createAnthropic({
        apiKey: process.env.ANTHROPIC_API_KEY
      })(provider.model);
    }
    case "google": {
      if (!process.env.GOOGLE_API_KEY) {
        throw new Error(
          createMissingKeyErrorMessage("Google", "GOOGLE_API_KEY")
        );
      }
      return createGoogleGenerativeAI({
        apiKey: process.env.GOOGLE_API_KEY
      })(provider.model);
    }
    case "openrouter": {
      if (!process.env.OPENROUTER_API_KEY) {
        throw new Error(
          createMissingKeyErrorMessage("OpenRouter", "OPENROUTER_API_KEY")
        );
      }
      return createOpenRouter({
        apiKey: process.env.OPENROUTER_API_KEY,
        baseURL: provider.baseUrl
      })(provider.model);
    }
    case "ollama": {
      return createOllama()(provider.model);
    }
    case "mistral": {
      if (!process.env.MISTRAL_API_KEY) {
        throw new Error(
          createMissingKeyErrorMessage("Mistral", "MISTRAL_API_KEY")
        );
      }
      return createMistral({
        apiKey: process.env.MISTRAL_API_KEY,
        baseURL: provider.baseUrl
      })(provider.model);
    }
    default: {
      throw new Error(createUnsupportedProviderErrorMessage(provider?.id));
    }
  }
}

// src/cli/utils/exp-backoff.ts
function withExponentialBackoff(fn, maxAttempts = 3, baseDelay = 1e3) {
  return async (...args) => {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        return await fn(...args);
      } catch (error) {
        if (attempt === maxAttempts - 1) throw error;
        const delay = baseDelay * Math.pow(2, attempt);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error("Unreachable code");
  };
}

// src/cli/utils/observability.ts
import pkg from "node-machine-id";
import https from "https";
var { machineIdSync } = pkg;
var POSTHOG_API_KEY = "phc_eR0iSoQufBxNY36k0f0T15UvHJdTfHlh8rJcxsfhfXk";
var POSTHOG_HOST = "eu.i.posthog.com";
var POSTHOG_PATH = "/i/v0/e/";
var REQUEST_TIMEOUT_MS = 1e3;
function trackEvent(distinctId, event, properties) {
  if (process.env.DO_NOT_TRACK === "1") {
    return;
  }
  setImmediate(() => {
    try {
      const actualId = distinctId || `device-${machineIdSync()}`;
      const eventData = {
        api_key: POSTHOG_API_KEY,
        event,
        distinct_id: actualId,
        properties: {
          ...properties,
          $lib: "lingo.dev-cli",
          $lib_version: process.env.npm_package_version || "unknown",
          // Essential debugging context only
          node_version: process.version,
          is_ci: !!process.env.CI,
          debug_enabled: process.env.DEBUG === "true"
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      const payload = JSON.stringify(eventData);
      const options = {
        hostname: POSTHOG_HOST,
        path: POSTHOG_PATH,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": Buffer.byteLength(payload).toString()
        },
        timeout: REQUEST_TIMEOUT_MS
      };
      const req = https.request(options);
      req.on("timeout", () => {
        req.destroy();
      });
      req.on("error", (error) => {
        if (process.env.DEBUG === "true") {
          console.error("[Tracking] Error ignored:", error.message);
        }
      });
      req.write(payload);
      req.end();
      setTimeout(() => {
        if (!req.destroyed) {
          req.destroy();
        }
      }, REQUEST_TIMEOUT_MS);
    } catch (error) {
      if (process.env.DEBUG === "true") {
        console.error("[Tracking] Failed to send event:", error);
      }
    }
  });
}

// src/cli/utils/delta.ts
import _30 from "lodash";
import z from "zod";

// src/cli/utils/fs.ts
import * as fs11 from "fs";
import * as path14 from "path";
function tryReadFile(filePath, defaultValue = null) {
  try {
    const content = fs11.readFileSync(filePath, "utf-8");
    return content;
  } catch (error) {
    return defaultValue;
  }
}
function writeFile(filePath, content) {
  const dir = path14.dirname(filePath);
  if (!fs11.existsSync(dir)) {
    fs11.mkdirSync(dir, { recursive: true });
  }
  fs11.writeFileSync(filePath, content);
}
function checkIfFileExists(filePath) {
  return fs11.existsSync(filePath);
}

// src/cli/utils/delta.ts
import * as path15 from "path";
import YAML5 from "yaml";
var LockSchema = z.object({
  version: z.literal(1).default(1),
  checksums: z.record(
    z.string(),
    // localizable files' keys
    // checksums hashmap
    z.record(
      // key
      z.string(),
      // checksum of the key's value in the source locale
      z.string()
    ).default({})
  ).default({})
});
function createDeltaProcessor(fileKey) {
  const lockfilePath = path15.join(process.cwd(), "i18n.lock");
  return {
    async checkIfLockExists() {
      return checkIfFileExists(lockfilePath);
    },
    async calculateDelta(params) {
      let added = _30.difference(
        Object.keys(params.sourceData),
        Object.keys(params.targetData)
      );
      let removed = _30.difference(
        Object.keys(params.targetData),
        Object.keys(params.sourceData)
      );
      const updated = Object.keys(params.sourceData).filter(
        (key) => md5(params.sourceData[key]) !== params.checksums[key] && params.checksums[key]
      );
      const renamed = [];
      for (const addedKey of added) {
        const addedHash = md5(params.sourceData[addedKey]);
        for (const removedKey of removed) {
          if (params.checksums[removedKey] === addedHash) {
            renamed.push([removedKey, addedKey]);
            break;
          }
        }
      }
      added = added.filter(
        (key) => !renamed.some(([oldKey, newKey]) => newKey === key)
      );
      removed = removed.filter(
        (key) => !renamed.some(([oldKey, newKey]) => oldKey === key)
      );
      const hasChanges = [
        added.length > 0,
        removed.length > 0,
        updated.length > 0,
        renamed.length > 0
      ].some((v) => v);
      return {
        added,
        removed,
        updated,
        renamed,
        hasChanges
      };
    },
    async loadLock() {
      const lockfileContent = tryReadFile(lockfilePath, null);
      const lockfileYaml = lockfileContent ? YAML5.parse(lockfileContent) : null;
      const lockfileData = lockfileYaml ? LockSchema.parse(lockfileYaml) : {
        version: 1,
        checksums: {}
      };
      return lockfileData;
    },
    async saveLock(lockData) {
      const lockfileYaml = YAML5.stringify(lockData);
      writeFile(lockfilePath, lockfileYaml);
    },
    async loadChecksums() {
      const id = md5(fileKey);
      const lockfileData = await this.loadLock();
      return lockfileData.checksums[id] || {};
    },
    async saveChecksums(checksums) {
      const id = md5(fileKey);
      const lockfileData = await this.loadLock();
      lockfileData.checksums[id] = checksums;
      await this.saveLock(lockfileData);
    },
    async createChecksums(sourceData) {
      const checksums = _30.mapValues(sourceData, (value) => md5(value));
      return checksums;
    }
  };
}

// src/cli/cmd/i18n.ts
var i18n_default = new Command14().command("i18n").description(
  "DEPRECATED: Run localization pipeline (prefer `run` command instead)"
).helpOption("-h, --help", "Show help").option(
  "--locale <locale>",
  "Limit processing to the listed target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--bucket <bucket>",
  "Limit processing to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all buckets",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--key <key>",
  "Limit processing to a single translation key by exact match. Filters all buckets and locales to process only this key, useful for testing or debugging specific translations. Example: auth.login.title",
  (val) => encodeURIComponent(val)
).option(
  "--file [files...]",
  "Filter processing to only buckets whose file paths contain these substrings. Example: 'components' to process only files in components directories"
).option(
  "--frozen",
  "Validate translations are up-to-date without making changes - fails if source files, target files, or lockfile are out of sync. Ideal for CI/CD to ensure translation consistency before deployment"
).option(
  "--force",
  "Force re-translation of all keys, bypassing change detection. Useful when you want to regenerate translations with updated AI models or translation settings"
).option(
  "--verbose",
  "Print the translation data being processed as formatted JSON for each bucket and locale"
).option(
  "--interactive",
  "Review and edit AI-generated translations interactively before applying changes to files"
).option(
  "--api-key <api-key>",
  "Override API key from settings or environment variables"
).option(
  "--debug",
  "Pause before processing localization so you can attach a debugger"
).option(
  "--strict",
  "Stop immediately on first error instead of continuing to process remaining buckets and locales (fail-fast mode)"
).action(async function(options) {
  updateGitignore();
  const ora = Ora9();
  let flags;
  try {
    flags = parseFlags(options);
  } catch (parseError) {
    await trackEvent("unknown", "cmd.i18n.error", {
      errorType: "validation_error",
      errorName: parseError.name || "ValidationError",
      errorMessage: parseError.message || "Invalid command line options",
      errorStack: parseError.stack,
      fatal: true,
      errorCount: 1,
      stage: "flag_validation"
    });
    throw parseError;
  }
  if (flags.debug) {
    const { debug } = await inquirer2.prompt([
      {
        type: "confirm",
        name: "debug",
        message: "Debug mode. Wait for user input before continuing."
      }
    ]);
  }
  let hasErrors = false;
  let authId = null;
  const errorDetails = [];
  try {
    ora.start("Loading configuration...");
    const i18nConfig = getConfig();
    const settings = getSettings(flags.apiKey);
    ora.succeed("Configuration loaded");
    ora.start("Validating localization configuration...");
    validateParams(i18nConfig, flags);
    ora.succeed("Localization configuration is valid");
    ora.start("Connecting to Lingo.dev Localization Engine...");
    const isByokMode = !!i18nConfig?.provider;
    if (isByokMode) {
      authId = null;
      ora.succeed("Using external provider (BYOK mode)");
    } else {
      const auth = await validateAuth(settings);
      authId = auth.id;
      ora.succeed(`Authenticated as ${auth.email}`);
    }
    await trackEvent(authId, "cmd.i18n.start", {
      i18nConfig,
      flags
    });
    let buckets = getBuckets(i18nConfig);
    if (flags.bucket?.length) {
      buckets = buckets.filter(
        (bucket) => flags.bucket.includes(bucket.type)
      );
    }
    ora.succeed("Buckets retrieved");
    if (flags.file?.length) {
      buckets = buckets.map((bucket) => {
        const paths = bucket.paths.filter(
          (path19) => flags.file.find((file) => path19.pathPattern?.includes(file))
        );
        return { ...bucket, paths };
      }).filter((bucket) => bucket.paths.length > 0);
      if (buckets.length === 0) {
        ora.fail(
          "No buckets found. All buckets were filtered out by --file option."
        );
        throw new Error(
          "No buckets found. All buckets were filtered out by --file option."
        );
      } else {
        ora.info(`\x1B[36mProcessing only filtered buckets:\x1B[0m`);
        buckets.map((bucket) => {
          ora.info(`  ${bucket.type}:`);
          bucket.paths.forEach((path19) => {
            ora.info(`    - ${path19.pathPattern}`);
          });
        });
      }
    }
    const targetLocales = flags.locale?.length ? flags.locale : i18nConfig.locale.targets;
    ora.start("Setting up localization cache...");
    const checkLockfileProcessor = createDeltaProcessor("");
    const lockfileExists = await checkLockfileProcessor.checkIfLockExists();
    if (!lockfileExists) {
      ora.start("Creating i18n.lock...");
      for (const bucket of buckets) {
        for (const bucketPath of bucket.paths) {
          const sourceLocale = resolveOverriddenLocale4(
            i18nConfig.locale.source,
            bucketPath.delimiter
          );
          const bucketLoader = createBucketLoader(
            bucket.type,
            bucketPath.pathPattern,
            {
              defaultLocale: sourceLocale,
              injectLocale: bucket.injectLocale,
              formatter: i18nConfig.formatter
            },
            bucket.lockedKeys,
            bucket.lockedPatterns,
            bucket.ignoredKeys
          );
          bucketLoader.setDefaultLocale(sourceLocale);
          await bucketLoader.init();
          const sourceData = await bucketLoader.pull(
            i18nConfig.locale.source
          );
          const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);
          const checksums = await deltaProcessor.createChecksums(sourceData);
          await deltaProcessor.saveChecksums(checksums);
        }
      }
      ora.succeed("Localization cache initialized");
    } else {
      ora.succeed("Localization cache loaded");
    }
    if (flags.frozen) {
      ora.start("Checking for lockfile updates...");
      let requiresUpdate = null;
      bucketLoop: for (const bucket of buckets) {
        for (const bucketPath of bucket.paths) {
          const sourceLocale = resolveOverriddenLocale4(
            i18nConfig.locale.source,
            bucketPath.delimiter
          );
          const bucketLoader = createBucketLoader(
            bucket.type,
            bucketPath.pathPattern,
            {
              defaultLocale: sourceLocale,
              returnUnlocalizedKeys: true,
              injectLocale: bucket.injectLocale
            },
            bucket.lockedKeys,
            bucket.lockedPatterns,
            bucket.ignoredKeys
          );
          bucketLoader.setDefaultLocale(sourceLocale);
          await bucketLoader.init();
          const { unlocalizable: sourceUnlocalizable, ...sourceData } = await bucketLoader.pull(i18nConfig.locale.source);
          const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);
          const sourceChecksums = await deltaProcessor.createChecksums(sourceData);
          const savedChecksums = await deltaProcessor.loadChecksums();
          const updatedSourceData = _31.pickBy(
            sourceData,
            (value, key) => sourceChecksums[key] !== savedChecksums[key]
          );
          if (Object.keys(updatedSourceData).length > 0) {
            requiresUpdate = "updated";
            break bucketLoop;
          }
          for (const _targetLocale of targetLocales) {
            const targetLocale = resolveOverriddenLocale4(
              _targetLocale,
              bucketPath.delimiter
            );
            const { unlocalizable: targetUnlocalizable, ...targetData } = await bucketLoader.pull(targetLocale);
            const missingKeys = _31.difference(
              Object.keys(sourceData),
              Object.keys(targetData)
            );
            const extraKeys = _31.difference(
              Object.keys(targetData),
              Object.keys(sourceData)
            );
            const unlocalizableDataDiff = !_31.isEqual(
              sourceUnlocalizable,
              targetUnlocalizable
            );
            if (missingKeys.length > 0) {
              requiresUpdate = "missing";
              break bucketLoop;
            }
            if (extraKeys.length > 0) {
              requiresUpdate = "extra";
              break bucketLoop;
            }
            if (unlocalizableDataDiff) {
              requiresUpdate = "unlocalizable";
              break bucketLoop;
            }
          }
        }
      }
      if (requiresUpdate) {
        const message = {
          updated: "Source file has been updated.",
          missing: "Target file is missing translations.",
          extra: "Target file has extra translations not present in the source file.",
          unlocalizable: "Unlocalizable data (such as booleans, dates, URLs, etc.) do not match."
        }[requiresUpdate];
        ora.fail(
          `Localization data has changed; please update i18n.lock or run without --frozen.`
        );
        ora.fail(`  Details: ${message}`);
        throw new Error(
          `Localization data has changed; please update i18n.lock or run without --frozen. Details: ${message}`
        );
      } else {
        ora.succeed("No lockfile updates required.");
      }
    }
    for (const bucket of buckets) {
      try {
        console.log();
        ora.info(`Processing bucket: ${bucket.type}`);
        for (const bucketPath of bucket.paths) {
          const bucketOra = Ora9({ indent: 2 }).info(
            `Processing path: ${bucketPath.pathPattern}`
          );
          const sourceLocale = resolveOverriddenLocale4(
            i18nConfig.locale.source,
            bucketPath.delimiter
          );
          const bucketLoader = createBucketLoader(
            bucket.type,
            bucketPath.pathPattern,
            {
              defaultLocale: sourceLocale,
              injectLocale: bucket.injectLocale,
              formatter: i18nConfig.formatter
            },
            bucket.lockedKeys,
            bucket.lockedPatterns,
            bucket.ignoredKeys
          );
          bucketLoader.setDefaultLocale(sourceLocale);
          await bucketLoader.init();
          let sourceData = await bucketLoader.pull(sourceLocale);
          for (const _targetLocale of targetLocales) {
            const targetLocale = resolveOverriddenLocale4(
              _targetLocale,
              bucketPath.delimiter
            );
            try {
              bucketOra.start(
                `[${sourceLocale} -> ${targetLocale}] (0%) Localization in progress...`
              );
              sourceData = await bucketLoader.pull(sourceLocale);
              const targetData = await bucketLoader.pull(targetLocale);
              const deltaProcessor2 = createDeltaProcessor(
                bucketPath.pathPattern
              );
              const checksums2 = await deltaProcessor2.loadChecksums();
              const delta = await deltaProcessor2.calculateDelta({
                sourceData,
                targetData,
                checksums: checksums2
              });
              let processableData = _31.chain(sourceData).entries().filter(
                ([key, value]) => delta.added.includes(key) || delta.updated.includes(key) || !!flags.force
              ).fromPairs().value();
              if (flags.key) {
                processableData = _31.pickBy(
                  processableData,
                  (_36, key) => key === flags.key
                );
              }
              if (flags.verbose) {
                bucketOra.info(JSON.stringify(processableData, null, 2));
              }
              bucketOra.start(
                `[${sourceLocale} -> ${targetLocale}] [${Object.keys(processableData).length} entries] (0%) AI localization in progress...`
              );
              let processPayload = createProcessor(i18nConfig.provider, {
                apiKey: settings.auth.apiKey,
                apiUrl: settings.auth.apiUrl
              });
              processPayload = withExponentialBackoff(
                processPayload,
                3,
                1e3
              );
              const processedTargetData = await processPayload(
                {
                  sourceLocale,
                  sourceData,
                  processableData,
                  targetLocale,
                  targetData
                },
                (progress, sourceChunk, processedChunk) => {
                  bucketOra.text = `[${sourceLocale} -> ${targetLocale}] [${Object.keys(processableData).length} entries] (${progress}%) AI localization in progress...`;
                }
              );
              if (flags.verbose) {
                bucketOra.info(JSON.stringify(processedTargetData, null, 2));
              }
              let finalTargetData = _31.merge(
                {},
                sourceData,
                targetData,
                processedTargetData
              );
              finalTargetData = _31.chain(finalTargetData).entries().map(([key, value]) => {
                const renaming = delta.renamed.find(
                  ([oldKey, newKey]) => oldKey === key
                );
                if (!renaming) {
                  return [key, value];
                }
                return [renaming[1], value];
              }).fromPairs().value();
              if (flags.interactive) {
                bucketOra.stop();
                const reviewedData = await reviewChanges({
                  pathPattern: bucketPath.pathPattern,
                  targetLocale,
                  currentData: targetData,
                  proposedData: finalTargetData,
                  sourceData,
                  force: flags.force
                });
                finalTargetData = reviewedData;
                bucketOra.start(
                  `Applying changes to ${bucketPath} (${targetLocale})`
                );
              }
              const finalDiffSize = _31.chain(finalTargetData).omitBy((value, key) => {
                const targetValue = targetData[key];
                if (isICUPluralObject(value) && isICUPluralObject(targetValue)) {
                  return _31.isEqual(
                    { icu: value.icu, _meta: value._meta },
                    { icu: targetValue.icu, _meta: targetValue._meta }
                  );
                }
                return value === targetValue;
              }).size().value();
              await bucketLoader.push(targetLocale, finalTargetData);
              if (finalDiffSize > 0 || flags.force) {
                bucketOra.succeed(
                  `[${sourceLocale} -> ${targetLocale}] Localization completed`
                );
              } else {
                bucketOra.succeed(
                  `[${sourceLocale} -> ${targetLocale}] Localization completed (no changes).`
                );
              }
            } catch (_error) {
              const error = new LocalizationError(
                `[${sourceLocale} -> ${targetLocale}] Localization failed: ${_error.message}`,
                {
                  bucket: bucket.type,
                  sourceLocale,
                  targetLocale,
                  pathPattern: bucketPath.pathPattern
                }
              );
              errorDetails.push({
                type: "locale_error",
                bucket: bucket.type,
                locale: `${sourceLocale} -> ${targetLocale}`,
                pathPattern: bucketPath.pathPattern,
                message: _error.message,
                stack: _error.stack
              });
              if (flags.strict) {
                throw error;
              } else {
                bucketOra.fail(error.message);
                hasErrors = true;
              }
            }
          }
          const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);
          const checksums = await deltaProcessor.createChecksums(sourceData);
          if (!flags.locale?.length) {
            await deltaProcessor.saveChecksums(checksums);
          }
        }
      } catch (_error) {
        const error = new BucketProcessingError(
          `Failed to process bucket ${bucket.type}: ${_error.message}`,
          bucket.type
        );
        errorDetails.push({
          type: "bucket_error",
          bucket: bucket.type,
          message: _error.message,
          stack: _error.stack
        });
        if (flags.strict) {
          throw error;
        } else {
          ora.fail(error.message);
          hasErrors = true;
        }
      }
    }
    console.log();
    if (!hasErrors) {
      ora.succeed("Localization completed.");
      await trackEvent(authId, "cmd.i18n.success", {
        i18nConfig: {
          sourceLocale: i18nConfig.locale.source,
          targetLocales: i18nConfig.locale.targets,
          bucketTypes: Object.keys(i18nConfig.buckets)
        },
        flags,
        bucketCount: buckets.length,
        localeCount: targetLocales.length,
        processedSuccessfully: true
      });
    } else {
      ora.warn("Localization completed with errors.");
      await trackEvent(authId || "unknown", "cmd.i18n.error", {
        flags,
        ...aggregateErrorAnalytics(
          errorDetails,
          buckets,
          targetLocales,
          i18nConfig
        )
      });
    }
  } catch (error) {
    ora.fail(error.message);
    const errorType = getCLIErrorType(error);
    let errorContext = {};
    if (isLocalizationError(error)) {
      errorContext = {
        bucket: error.bucket,
        sourceLocale: error.sourceLocale,
        targetLocale: error.targetLocale,
        pathPattern: error.pathPattern
      };
    } else if (isBucketProcessingError(error)) {
      errorContext = {
        bucket: error.bucket
      };
    }
    await trackEvent(authId || "unknown", "cmd.i18n.error", {
      flags,
      errorType,
      errorName: error.name || "Error",
      errorMessage: error.message,
      errorStack: error.stack,
      errorContext,
      fatal: true,
      errorCount: errorDetails.length + 1,
      previousErrors: createPreviousErrorContext(errorDetails)
    });
  }
});
function parseFlags(options) {
  return Z3.object({
    apiKey: Z3.string().optional(),
    locale: Z3.array(localeCodeSchema).optional(),
    bucket: Z3.array(bucketTypeSchema).optional(),
    force: Z3.boolean().optional(),
    frozen: Z3.boolean().optional(),
    verbose: Z3.boolean().optional(),
    strict: Z3.boolean().optional(),
    key: Z3.string().optional(),
    file: Z3.array(Z3.string()).optional(),
    interactive: Z3.boolean().default(false),
    debug: Z3.boolean().default(false)
  }).parse(options);
}
async function validateAuth(settings) {
  if (!settings.auth.apiKey) {
    throw new AuthenticationError({
      message: "Not authenticated. Please run `lingo.dev login` to authenticate.",
      docUrl: "authError"
    });
  }
  const authenticator = createAuthenticator({
    apiKey: settings.auth.apiKey,
    apiUrl: settings.auth.apiUrl
  });
  const user = await authenticator.whoami();
  if (!user) {
    throw new AuthenticationError({
      message: "Invalid API key. Please run `lingo.dev login` to authenticate.",
      docUrl: "authError"
    });
  }
  return user;
}
function validateParams(i18nConfig, flags) {
  if (!i18nConfig) {
    throw new ConfigError({
      message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
      docUrl: "i18nNotFound"
    });
  } else if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {
    throw new ConfigError({
      message: "No buckets found in i18n.json. Please add at least one bucket containing i18n content.",
      docUrl: "bucketNotFound"
    });
  } else if (flags.locale?.some((locale) => !i18nConfig.locale.targets.includes(locale))) {
    throw new ValidationError({
      message: `One or more specified locales do not exist in i18n.json locale.targets. Please add them to the list and try again.`,
      docUrl: "localeTargetNotFound"
    });
  } else if (flags.bucket?.some(
    (bucket) => !i18nConfig.buckets[bucket]
  )) {
    throw new ValidationError({
      message: `One or more specified buckets do not exist in i18n.json. Please add them to the list and try again.`,
      docUrl: "bucketNotFound"
    });
  }
}
async function reviewChanges(args) {
  const currentStr = JSON.stringify(args.currentData, null, 2);
  const proposedStr = JSON.stringify(args.proposedData, null, 2);
  if (currentStr === proposedStr && !args.force) {
    console.log(
      `
${chalk6.blue(args.pathPattern)} (${chalk6.yellow(
        args.targetLocale
      )}): ${chalk6.gray("No changes to review")}`
    );
    return args.proposedData;
  }
  const patch = createTwoFilesPatch(
    `${args.pathPattern} (current)`,
    `${args.pathPattern} (proposed)`,
    currentStr,
    proposedStr,
    void 0,
    void 0,
    { context: 3 }
  );
  const coloredDiff = patch.split("\n").map((line) => {
    if (line.startsWith("+")) return chalk6.green(line);
    if (line.startsWith("-")) return chalk6.red(line);
    if (line.startsWith("@")) return chalk6.cyan(line);
    return line;
  }).join("\n");
  console.log(
    `
Reviewing changes for ${chalk6.blue(args.pathPattern)} (${chalk6.yellow(
      args.targetLocale
    )}):`
  );
  console.log(coloredDiff);
  const { action } = await inquirer2.prompt([
    {
      type: "list",
      name: "action",
      message: "Choose action:",
      choices: [
        { name: "Approve changes", value: "approve" },
        { name: "Skip changes", value: "skip" },
        { name: "Edit individually", value: "edit" }
      ],
      default: "approve"
    }
  ]);
  if (action === "approve") {
    return args.proposedData;
  }
  if (action === "skip") {
    return args.currentData;
  }
  const customData = { ...args.currentData };
  const changes = _31.reduce(
    args.proposedData,
    (result, value, key) => {
      if (args.currentData[key] !== value) {
        result.push(key);
      }
      return result;
    },
    []
  );
  for (const key of changes) {
    console.log(`
Editing value for: ${chalk6.cyan(key)}`);
    console.log(chalk6.gray("Source text:"), chalk6.blue(args.sourceData[key]));
    console.log(
      chalk6.gray("Current value:"),
      chalk6.red(args.currentData[key] || "(empty)")
    );
    console.log(
      chalk6.gray("Suggested value:"),
      chalk6.green(args.proposedData[key])
    );
    console.log(
      chalk6.gray(
        "\nYour editor will open. Edit the text and save to continue."
      )
    );
    console.log(chalk6.gray("------------"));
    try {
      const editorContent = [
        "# Edit the translation below.",
        "# Lines starting with # will be ignored.",
        "# Save and exit the editor to continue.",
        "#",
        `# Source text (${chalk6.blue("English")}):`,
        `# ${args.sourceData[key]}`,
        "#",
        `# Current value (${chalk6.red(args.targetLocale)}):`,
        `# ${args.currentData[key] || "(empty)"}`,
        "#",
        args.proposedData[key]
      ].join("\n");
      const result = externalEditor.edit(editorContent);
      const customValue = result.split("\n").filter((line) => !line.startsWith("#")).join("\n").trim();
      if (customValue) {
        customData[key] = customValue;
      } else {
        console.log(
          chalk6.yellow("Empty value provided, keeping the current value.")
        );
        customData[key] = args.currentData[key] || args.proposedData[key];
      }
    } catch (error) {
      console.log(
        chalk6.red("Error while editing, keeping the suggested value.")
      );
      customData[key] = args.proposedData[key];
    }
  }
  return customData;
}

// src/cli/cmd/lockfile.ts
import { Command as Command15 } from "interactive-commander";
import Z5 from "zod";
import Ora10 from "ora";

// src/cli/utils/lockfile.ts
import fs12 from "fs";
import path16 from "path";
import Z4 from "zod";
import YAML6 from "yaml";
import { MD5 as MD52 } from "object-hash";
import _32 from "lodash";
function createLockfileHelper() {
  return {
    isLockfileExists: () => {
      const lockfilePath = _getLockfilePath();
      return fs12.existsSync(lockfilePath);
    },
    registerSourceData: (pathPattern, sourceData) => {
      const lockfile = _loadLockfile();
      const sectionKey = MD52(pathPattern);
      const sectionChecksums = _32.mapValues(sourceData, (value) => MD52(value));
      lockfile.checksums[sectionKey] = sectionChecksums;
      _saveLockfile(lockfile);
    },
    registerPartialSourceData: (pathPattern, partialSourceData) => {
      const lockfile = _loadLockfile();
      const sectionKey = MD52(pathPattern);
      const sectionChecksums = _32.mapValues(
        partialSourceData,
        (value) => MD52(value)
      );
      lockfile.checksums[sectionKey] = _32.merge(
        {},
        lockfile.checksums[sectionKey] ?? {},
        sectionChecksums
      );
      _saveLockfile(lockfile);
    },
    extractUpdatedData: (pathPattern, sourceData) => {
      const lockfile = _loadLockfile();
      const sectionKey = MD52(pathPattern);
      const currentChecksums = _32.mapValues(sourceData, (value) => MD52(value));
      const savedChecksums = lockfile.checksums[sectionKey] || {};
      const updatedData = _32.pickBy(
        sourceData,
        (value, key) => savedChecksums[key] !== currentChecksums[key]
      );
      return updatedData;
    }
  };
  function _loadLockfile() {
    const lockfilePath = _getLockfilePath();
    if (!fs12.existsSync(lockfilePath)) {
      return LockfileSchema.parse({});
    }
    const content = fs12.readFileSync(lockfilePath, "utf-8");
    const result = LockfileSchema.parse(YAML6.parse(content));
    return result;
  }
  function _saveLockfile(lockfile) {
    const lockfilePath = _getLockfilePath();
    const content = YAML6.stringify(lockfile);
    fs12.writeFileSync(lockfilePath, content);
  }
  function _getLockfilePath() {
    return path16.join(process.cwd(), "i18n.lock");
  }
}
var LockfileSchema = Z4.object({
  version: Z4.literal(1).default(1),
  checksums: Z4.record(
    Z4.string(),
    // localizable files' keys
    Z4.record(
      // checksums hashmap
      Z4.string(),
      // key
      Z4.string()
      // checksum of the key's value in the source locale
    ).default({})
  ).default({})
});

// src/cli/cmd/lockfile.ts
import { resolveOverriddenLocale as resolveOverriddenLocale5 } from "@lingo.dev/_spec";
var lockfile_default = new Command15().command("lockfile").description(
  "Generate or refresh i18n.lock based on the current source locale content"
).helpOption("-h, --help", "Show help").option(
  "-f, --force",
  "Overwrite existing lockfile to reset translation tracking"
).action(async (options) => {
  const flags = flagsSchema.parse(options);
  const ora = Ora10();
  const lockfileHelper = createLockfileHelper();
  if (lockfileHelper.isLockfileExists() && !flags.force) {
    ora.warn(
      `Lockfile won't be created because it already exists. Use --force to overwrite.`
    );
  } else {
    const i18nConfig = getConfig();
    const buckets = getBuckets(i18nConfig);
    for (const bucket of buckets) {
      for (const bucketConfig of bucket.paths) {
        const sourceLocale = resolveOverriddenLocale5(
          i18nConfig.locale.source,
          bucketConfig.delimiter
        );
        const bucketLoader = createBucketLoader(
          bucket.type,
          bucketConfig.pathPattern,
          {
            defaultLocale: sourceLocale,
            formatter: i18nConfig.formatter
          },
          bucket.lockedKeys,
          bucket.lockedPatterns,
          bucket.ignoredKeys
        );
        bucketLoader.setDefaultLocale(sourceLocale);
        const sourceData = await bucketLoader.pull(sourceLocale);
        lockfileHelper.registerSourceData(
          bucketConfig.pathPattern,
          sourceData
        );
      }
    }
    ora.succeed("Lockfile created");
  }
});
var flagsSchema = Z5.object({
  force: Z5.boolean().default(false)
});

// src/cli/cmd/cleanup.ts
import { resolveOverriddenLocale as resolveOverriddenLocale6 } from "@lingo.dev/_spec";
import { Command as Command16 } from "interactive-commander";
import _33 from "lodash";
import Ora11 from "ora";
var cleanup_default = new Command16().command("cleanup").description(
  "Remove translation keys from target locales that no longer exist in the source locale"
).helpOption("-h, --help", "Show help").option(
  "--locale <locale>",
  "Limit cleanup to a specific target locale from i18n.json. Defaults to all configured target locales"
).option(
  "--bucket <bucket>",
  "Limit cleanup to a specific bucket type defined under `buckets` in i18n.json"
).option(
  "--dry-run",
  "Preview which keys would be deleted without making any changes"
).option(
  "--verbose",
  "Print detailed output showing the specific keys to be removed for each locale"
).action(async function(options) {
  const ora = Ora11();
  const results = [];
  try {
    ora.start("Loading configuration...");
    const i18nConfig = getConfig();
    validateConfig(i18nConfig);
    ora.succeed("Configuration loaded");
    let buckets = getBuckets(i18nConfig);
    if (options.bucket) {
      buckets = buckets.filter(
        (bucket) => bucket.type === options.bucket
      );
    }
    const targetLocales = options.locale ? [options.locale] : i18nConfig.locale.targets;
    for (const bucket of buckets) {
      console.log();
      ora.info(`Processing bucket: ${bucket.type}`);
      for (const bucketConfig of bucket.paths) {
        const sourceLocale = resolveOverriddenLocale6(
          i18nConfig.locale.source,
          bucketConfig.delimiter
        );
        const bucketOra = Ora11({ indent: 2 }).info(
          `Processing path: ${bucketConfig.pathPattern}`
        );
        const bucketLoader = createBucketLoader(
          bucket.type,
          bucketConfig.pathPattern,
          {
            defaultLocale: sourceLocale,
            formatter: i18nConfig.formatter
          },
          bucket.lockedKeys,
          bucket.lockedPatterns,
          bucket.ignoredKeys
        );
        bucketLoader.setDefaultLocale(sourceLocale);
        const sourceData = await bucketLoader.pull(sourceLocale);
        const sourceKeys = Object.keys(sourceData);
        for (const _targetLocale of targetLocales) {
          const targetLocale = resolveOverriddenLocale6(
            _targetLocale,
            bucketConfig.delimiter
          );
          try {
            const targetData = await bucketLoader.pull(targetLocale);
            const targetKeys = Object.keys(targetData);
            const keysToRemove = _33.difference(targetKeys, sourceKeys);
            if (keysToRemove.length === 0) {
              bucketOra.succeed(`[${targetLocale}] No keys to remove`);
              continue;
            }
            if (options.verbose) {
              bucketOra.info(
                `[${targetLocale}] Keys to remove: ${JSON.stringify(
                  keysToRemove,
                  null,
                  2
                )}`
              );
            }
            if (!options.dryRun) {
              const cleanedData = _33.pick(targetData, sourceKeys);
              await bucketLoader.push(targetLocale, cleanedData);
              bucketOra.succeed(
                `[${targetLocale}] Removed ${keysToRemove.length} keys`
              );
            } else {
              bucketOra.succeed(
                `[${targetLocale}] Would remove ${keysToRemove.length} keys (dry run)`
              );
            }
          } catch (error) {
            bucketOra.fail(
              `[${targetLocale}] Failed to cleanup: ${error.message}`
            );
            results.push({
              step: `Cleanup ${bucket.type}/${bucketConfig} for ${targetLocale}`,
              status: "Failed",
              error: error.message
            });
          }
        }
      }
    }
    console.log();
    ora.succeed("Cleanup completed!");
  } catch (error) {
    ora.fail(error.message);
    process.exit(1);
  } finally {
    displaySummary(results);
  }
});
function validateConfig(i18nConfig) {
  if (!i18nConfig) {
    throw new CLIError({
      message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
      docUrl: "i18nNotFound"
    });
  }
  if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {
    throw new CLIError({
      message: "No buckets found in i18n.json. Please add at least one bucket containing i18n content.",
      docUrl: "bucketNotFound"
    });
  }
}
function displaySummary(results) {
  if (results.length === 0) return;
  console.log("\nProcess Summary:");
  results.forEach((result) => {
    console.log(`${result.step}: ${result.status}`);
    if (result.error) console.log(`  - Error: ${result.error}`);
  });
}

// src/cli/cmd/mcp.ts
import { Command as Command17 } from "interactive-commander";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import Z6 from "zod";
import { ReplexicaEngine } from "@lingo.dev/_sdk";
var mcp_default = new Command17().command("mcp").description(
  "Start a Model Context Protocol (MCP) server for AI assistant integration"
).helpOption("-h, --help", "Show help").action(async (_36, program) => {
  const apiKey = program.args[0];
  const settings = getSettings(apiKey);
  if (!settings.auth.apiKey) {
    console.error("No API key provided");
    return;
  }
  const authenticator = createAuthenticator({
    apiUrl: settings.auth.apiUrl,
    apiKey: settings.auth.apiKey
  });
  const auth = await authenticator.whoami();
  if (!auth) {
    console.error("Not authenticated");
    return;
  } else {
    console.log(`Authenticated as ${auth.email}`);
  }
  const replexicaEngine = new ReplexicaEngine({
    apiKey: settings.auth.apiKey,
    apiUrl: settings.auth.apiUrl
  });
  const server = new McpServer({
    name: "Lingo.dev",
    version: "1.0.0"
  });
  server.tool(
    "translate",
    "Detect language and translate text with Lingo.dev.",
    {
      text: Z6.string(),
      targetLocale: Z6.string().regex(/^[a-z]{2}(-[A-Z]{2})?$/)
    },
    async ({ text, targetLocale }) => {
      const sourceLocale = await replexicaEngine.recognizeLocale(text);
      const data = await replexicaEngine.localizeText(text, {
        sourceLocale,
        targetLocale
      });
      return { content: [{ type: "text", text: data }] };
    }
  );
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.log("Lingo.dev MCP Server running on stdio");
});

// src/cli/cmd/ci/index.ts
import { Command as Command19 } from "interactive-commander";
import createOra from "ora";

// src/cli/cmd/ci/flows/pull-request.ts
import { execSync as execSync2 } from "child_process";

// src/cli/cmd/ci/flows/in-branch.ts
import { execSync } from "child_process";
import path18 from "path";

// src/cli/cmd/ci/flows/_base.ts
var IntegrationFlow = class {
  constructor(ora, platformKit) {
    this.ora = ora;
    this.platformKit = platformKit;
  }
  i18nBranchName;
};
function getGitConfig(platformKit) {
  return {
    userName: platformKit.config.commitAuthorName,
    userEmail: platformKit.config.commitAuthorEmail
  };
}
function escapeShellArg(arg) {
  return `'${arg.replace(/'/g, "'\\''")}'`;
}

// src/cli/cmd/run/index.ts
import { Command as Command18 } from "interactive-commander";
import { exec } from "child_process";
import path17 from "path";
import { fileURLToPath } from "url";
import os2 from "os";

// src/cli/cmd/run/setup.ts
import chalk10 from "chalk";
import { Listr } from "listr2";

// src/cli/cmd/run/_const.ts
import chalk7 from "chalk";
import { ListrDefaultRendererLogLevels } from "listr2";
var commonTaskRendererOptions = {
  color: {
    [ListrDefaultRendererLogLevels.COMPLETED]: (msg) => msg ? chalk7.hex(colors.green)(msg) : chalk7.hex(colors.green)("")
  },
  icon: {
    [ListrDefaultRendererLogLevels.COMPLETED]: chalk7.hex(colors.green)("\u2713")
  }
};

// src/cli/localizer/lingodotdev.ts
import dedent5 from "dedent";
import chalk8 from "chalk";
import { LingoDotDevEngine as LingoDotDevEngine2 } from "@lingo.dev/_sdk";
function createLingoDotDevLocalizer(explicitApiKey) {
  const { auth } = getSettings(explicitApiKey);
  if (!auth) {
    throw new Error(
      dedent5`
        You're trying to use ${chalk8.hex(colors.green)(
        "Lingo.dev"
      )} provider, however, you are not authenticated.

        To fix this issue:
        1. Run ${chalk8.dim("lingo.dev login")} to authenticate, or
        2. Use the ${chalk8.dim("--api-key")} flag to provide an API key.
        3. Set ${chalk8.dim("LINGODOTDEV_API_KEY")} environment variable.
      `
    );
  }
  const engine = new LingoDotDevEngine2({
    apiKey: auth.apiKey,
    apiUrl: auth.apiUrl
  });
  return {
    id: "Lingo.dev",
    checkAuth: async () => {
      try {
        const response = await engine.whoami();
        return {
          authenticated: !!response,
          username: response?.email
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { authenticated: false, error: errorMessage };
      }
    },
    localize: async (input2, onProgress) => {
      if (!Object.keys(input2.processableData).length) {
        return input2;
      }
      const processedData = await engine.localizeObject(
        input2.processableData,
        {
          sourceLocale: input2.sourceLocale,
          targetLocale: input2.targetLocale,
          reference: {
            [input2.sourceLocale]: input2.sourceData,
            [input2.targetLocale]: input2.targetData
          },
          hints: input2.hints
        },
        onProgress
      );
      return processedData;
    }
  };
}

// src/cli/localizer/explicit.ts
import { createAnthropic as createAnthropic2 } from "@ai-sdk/anthropic";
import { createGoogleGenerativeAI as createGoogleGenerativeAI2 } from "@ai-sdk/google";
import { createOpenAI as createOpenAI2 } from "@ai-sdk/openai";
import { createOpenRouter as createOpenRouter2 } from "@openrouter/ai-sdk-provider";
import { createMistral as createMistral2 } from "@ai-sdk/mistral";
import chalk9 from "chalk";
import dedent6 from "dedent";
import { generateText as generateText2 } from "ai";
import { jsonrepair as jsonrepair3 } from "jsonrepair";
import { createOllama as createOllama2 } from "ollama-ai-provider";
function createExplicitLocalizer(provider) {
  const settings = provider.settings || {};
  switch (provider.id) {
    default:
      throw new Error(
        dedent6`
          You're trying to use unsupported provider: ${chalk9.dim(provider.id)}.

          To fix this issue:
          1. Switch to one of the supported providers, or
          2. Remove the ${chalk9.italic(
          "provider"
        )} node from your i18n.json configuration to switch to ${chalk9.hex(
          colors.green
        )("Lingo.dev")}

          ${chalk9.hex(colors.blue)("Docs: https://lingo.dev/go/docs")}
        `
      );
    case "openai":
      return createAiSdkLocalizer({
        factory: (params) => createOpenAI2(params).languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        apiKeyName: "OPENAI_API_KEY",
        baseUrl: provider.baseUrl,
        settings
      });
    case "anthropic":
      return createAiSdkLocalizer({
        factory: (params) => createAnthropic2(params).languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        apiKeyName: "ANTHROPIC_API_KEY",
        baseUrl: provider.baseUrl,
        settings
      });
    case "google":
      return createAiSdkLocalizer({
        factory: (params) => createGoogleGenerativeAI2(params).languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        apiKeyName: "GOOGLE_API_KEY",
        baseUrl: provider.baseUrl,
        settings
      });
    case "openrouter":
      return createAiSdkLocalizer({
        factory: (params) => createOpenRouter2(params).languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        apiKeyName: "OPENROUTER_API_KEY",
        baseUrl: provider.baseUrl,
        settings
      });
    case "ollama":
      return createAiSdkLocalizer({
        factory: (_params) => createOllama2().languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        skipAuth: true,
        settings
      });
    case "mistral":
      return createAiSdkLocalizer({
        factory: (params) => createMistral2(params).languageModel(provider.model),
        id: provider.id,
        prompt: provider.prompt,
        apiKeyName: "MISTRAL_API_KEY",
        baseUrl: provider.baseUrl,
        settings
      });
  }
}
function createAiSdkLocalizer(params) {
  const skipAuth = params.skipAuth === true;
  const apiKey = process.env[params?.apiKeyName ?? ""];
  if (!skipAuth && !apiKey || !params.apiKeyName) {
    throw new Error(
      dedent6`
        You're trying to use raw ${chalk9.dim(params.id)} API for translation. ${params.apiKeyName ? `However, ${chalk9.dim(
        params.apiKeyName
      )} environment variable is not set.` : "However, that provider is unavailable."}

        To fix this issue:
        1. ${params.apiKeyName ? `Set ${chalk9.dim(
        params.apiKeyName
      )} in your environment variables` : "Set the environment variable for your provider (if required)"}, or
        2. Remove the ${chalk9.italic(
        "provider"
      )} node from your i18n.json configuration to switch to ${chalk9.hex(
        colors.green
      )("Lingo.dev")}

        ${chalk9.hex(colors.blue)("Docs: https://lingo.dev/go/docs")}
      `
    );
  }
  const model = params.factory(
    skipAuth ? {} : { apiKey, baseUrl: params.baseUrl }
  );
  return {
    id: params.id,
    checkAuth: async () => {
      return { authenticated: true, username: "anonymous" };
    },
    validateSettings: async () => {
      try {
        await generateText2({
          model,
          ...params.settings,
          messages: [
            { role: "system", content: "You are an echo server" },
            { role: "user", content: "OK" },
            { role: "assistant", content: "OK" },
            { role: "user", content: "OK" }
          ]
        });
        return { valid: true };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { valid: false, error: errorMessage };
      }
    },
    localize: async (input2) => {
      const systemPrompt = params.prompt.replaceAll("{source}", input2.sourceLocale).replaceAll("{target}", input2.targetLocale);
      const shots = [
        [
          {
            sourceLocale: "en",
            targetLocale: "es",
            data: {
              message: "Hello, world!"
            }
          },
          {
            sourceLocale: "en",
            targetLocale: "es",
            data: {
              message: "Hola, mundo!"
            }
          }
        ]
      ];
      const payload = {
        sourceLocale: input2.sourceLocale,
        targetLocale: input2.targetLocale,
        data: input2.processableData
      };
      const response = await generateText2({
        model,
        ...params.settings,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: "OK" },
          ...shots.flatMap(
            ([userShot, assistantShot]) => [
              { role: "user", content: JSON.stringify(userShot) },
              { role: "assistant", content: JSON.stringify(assistantShot) }
            ]
          ),
          { role: "user", content: JSON.stringify(payload) }
        ]
      });
      const result = JSON.parse(response.text);
      if (typeof result.data === "object" && result.data !== null) {
        return result.data;
      }
      const index = result.data.indexOf("{");
      const lastIndex = result.data.lastIndexOf("}");
      const trimmed = result.data.slice(index, lastIndex + 1);
      const repaired = jsonrepair3(trimmed);
      const finalResult = JSON.parse(repaired);
      return finalResult.data;
    }
  };
}

// src/cli/localizer/index.ts
function createLocalizer(provider, apiKey) {
  if (!provider) {
    return createLingoDotDevLocalizer(apiKey);
  } else {
    return createExplicitLocalizer(provider);
  }
}

// src/cli/cmd/run/setup.ts
async function setup(input2) {
  console.log(chalk10.hex(colors.orange)("[Setup]"));
  return new Listr(
    [
      {
        title: "Setting up the environment",
        task: async (ctx, task) => {
          task.title = `Environment setup completed`;
        }
      },
      {
        title: "Loading i18n configuration",
        task: async (ctx, task) => {
          ctx.config = getConfig(true);
          if (!ctx.config) {
            throw new Error(
              "i18n.json not found. Please run `lingo.dev init` to initialize the project."
            );
          } else if (!ctx.config.buckets || !Object.keys(ctx.config.buckets).length) {
            throw new Error(
              "No buckets found in i18n.json. Please add at least one bucket containing i18n content."
            );
          } else if (ctx.flags.bucket?.some(
            (bucket) => !ctx.config?.buckets[bucket]
          )) {
            throw new Error(
              `One or more specified buckets do not exist in i18n.json. Please add them to the list first and try again.`
            );
          }
          task.title = `Loaded i18n configuration`;
        }
      },
      {
        title: "Selecting localization provider",
        task: async (ctx, task) => {
          ctx.localizer = createLocalizer(
            ctx.config?.provider,
            ctx.flags.apiKey
          );
          if (!ctx.localizer) {
            throw new Error(
              "Could not create localization provider. Please check your i18n.json configuration."
            );
          }
          task.title = ctx.localizer.id === "Lingo.dev" ? `Using ${chalk10.hex(colors.green)(ctx.localizer.id)} provider` : `Using raw ${chalk10.hex(colors.yellow)(ctx.localizer.id)} API`;
        }
      },
      {
        title: "Checking authentication",
        enabled: (ctx) => ctx.localizer?.id === "Lingo.dev",
        task: async (ctx, task) => {
          const authStatus = await ctx.localizer.checkAuth();
          if (!authStatus.authenticated) {
            throw new Error(authStatus.error || "Authentication failed");
          }
          task.title = `Authenticated as ${chalk10.hex(colors.yellow)(
            authStatus.username
          )}`;
        }
      },
      {
        title: "Validating configuration",
        enabled: (ctx) => ctx.localizer?.id !== "Lingo.dev",
        task: async (ctx, task) => {
          const validationStatus = await ctx.localizer.validateSettings();
          if (!validationStatus.valid) {
            throw new Error(
              validationStatus.error || "Configuration validation failed"
            );
          }
          task.title = `Configuration validated`;
        }
      },
      {
        title: "Initializing localization provider",
        async task(ctx, task) {
          const isLingoDotDev = ctx.localizer.id === "Lingo.dev";
          const subTasks = isLingoDotDev ? [
            "Brand voice enabled",
            "Translation memory connected",
            "Glossary enabled",
            "Quality assurance enabled"
          ].map((title) => ({ title, task: () => {
          } })) : [
            "Skipping brand voice",
            "Skipping glossary",
            "Skipping translation memory",
            "Skipping quality assurance"
          ].map((title) => ({ title, task: () => {
          }, skip: true }));
          return task.newListr(subTasks, {
            concurrent: true,
            rendererOptions: { collapseSubtasks: false }
          });
        }
      }
    ],
    {
      rendererOptions: commonTaskRendererOptions
    }
  ).run(input2);
}

// src/cli/cmd/run/plan.ts
import chalk11 from "chalk";
import { Listr as Listr2 } from "listr2";
import { resolveOverriddenLocale as resolveOverriddenLocale7 } from "@lingo.dev/_spec";
async function plan(input2) {
  console.log(chalk11.hex(colors.orange)("[Planning]"));
  let buckets = getBuckets(input2.config);
  if (input2.flags.bucket) {
    buckets = buckets.filter((b) => input2.flags.bucket.includes(b.type));
  }
  const _sourceLocale = input2.flags.sourceLocale || input2.config.locale.source;
  if (!_sourceLocale) {
    throw new Error(
      `No source locale provided. Use --source-locale to specify the source locale or add it to i18n.json (locale.source)`
    );
  }
  const _targetLocales = input2.flags.targetLocale || input2.config.locale.targets;
  if (!_targetLocales.length) {
    throw new Error(
      `No target locales provided. Use --target-locale to specify the target locales or add them to i18n.json (locale.targets)`
    );
  }
  return new Listr2(
    [
      {
        title: "Locating content buckets",
        task: async (ctx, task) => {
          const bucketCount = buckets.length;
          const bucketFilter = input2.flags.bucket ? ` ${chalk11.dim(
            `(filtered by: ${chalk11.hex(colors.yellow)(
              input2.flags.bucket.join(", ")
            )})`
          )}` : "";
          task.title = `Found ${chalk11.hex(colors.yellow)(
            bucketCount.toString()
          )} bucket(s)${bucketFilter}`;
        }
      },
      {
        title: "Detecting locales",
        task: async (ctx, task) => {
          task.title = `Found ${chalk11.hex(colors.yellow)(
            _targetLocales.length.toString()
          )} target locale(s)`;
        }
      },
      {
        title: "Locating localizable files",
        task: async (ctx, task) => {
          const patterns = [];
          for (const bucket of buckets) {
            for (const bucketPath of bucket.paths) {
              if (input2.flags.file) {
                if (!input2.flags.file.some(
                  (f) => bucketPath.pathPattern.includes(f) || minimatch(bucketPath.pathPattern, f)
                )) {
                  continue;
                }
              }
              patterns.push(bucketPath.pathPattern);
            }
          }
          const fileFilter = input2.flags.file ? ` ${chalk11.dim(
            `(filtered by: ${chalk11.hex(colors.yellow)(
              input2.flags.file.join(", ")
            )})`
          )}` : "";
          task.title = `Found ${chalk11.hex(colors.yellow)(
            patterns.length.toString()
          )} path pattern(s)${fileFilter}`;
        }
      },
      {
        title: "Computing translation tasks",
        task: async (ctx, task) => {
          for (const bucket of buckets) {
            for (const bucketPath of bucket.paths) {
              if (input2.flags.file) {
                if (!input2.flags.file.some(
                  (f) => bucketPath.pathPattern.includes(f) || minimatch(bucketPath.pathPattern, f)
                )) {
                  continue;
                }
              }
              const sourceLocale = resolveOverriddenLocale7(
                _sourceLocale,
                bucketPath.delimiter
              );
              for (const _targetLocale of _targetLocales) {
                const targetLocale = resolveOverriddenLocale7(
                  _targetLocale,
                  bucketPath.delimiter
                );
                if (sourceLocale === targetLocale) continue;
                ctx.tasks.push({
                  sourceLocale,
                  targetLocale,
                  bucketType: bucket.type,
                  bucketPathPattern: bucketPath.pathPattern,
                  injectLocale: bucket.injectLocale || [],
                  lockedKeys: bucket.lockedKeys || [],
                  lockedPatterns: bucket.lockedPatterns || [],
                  ignoredKeys: bucket.ignoredKeys || [],
                  onlyKeys: input2.flags.key || [],
                  formatter: input2.config.formatter
                });
              }
            }
          }
          task.title = `Prepared ${chalk11.hex(colors.green)(
            ctx.tasks.length.toString()
          )} translation task(s)`;
        }
      }
    ],
    {
      rendererOptions: commonTaskRendererOptions
    }
  ).run(input2);
}

// src/cli/cmd/run/execute.ts
import chalk12 from "chalk";
import { Listr as Listr3 } from "listr2";
import pLimit from "p-limit";
import _34 from "lodash";
var MAX_WORKER_COUNT = 10;
async function execute(input2) {
  const effectiveConcurrency = Math.min(
    input2.flags.concurrency,
    input2.tasks.length,
    MAX_WORKER_COUNT
  );
  console.log(chalk12.hex(colors.orange)(`[Localization]`));
  return new Listr3(
    [
      {
        title: "Initializing localization engine",
        task: async (ctx, task) => {
          task.title = `Localization engine ${chalk12.hex(colors.green)(
            "ready"
          )} (${ctx.localizer.id})`;
        }
      },
      {
        title: `Processing localization tasks ${chalk12.dim(
          `(tasks: ${input2.tasks.length}, concurrency: ${effectiveConcurrency})`
        )}`,
        task: async (ctx, task) => {
          if (input2.tasks.length < 1) {
            task.title = `Skipping, nothing to localize.`;
            task.skip();
            return;
          }
          const initialChecksumsMap = /* @__PURE__ */ new Map();
          const uniqueBucketPatterns = _34.uniq(
            ctx.tasks.map((t2) => t2.bucketPathPattern)
          );
          for (const bucketPathPattern of uniqueBucketPatterns) {
            const deltaProcessor = createDeltaProcessor(bucketPathPattern);
            const checksums = await deltaProcessor.loadChecksums();
            initialChecksumsMap.set(bucketPathPattern, checksums);
          }
          const i18nLimiter = pLimit(effectiveConcurrency);
          const ioLimiter = pLimit(1);
          const perFileIoLimiters = /* @__PURE__ */ new Map();
          const getFileIoLimiter = (bucketPathPattern) => {
            const lockKey = bucketPathPattern;
            if (!perFileIoLimiters.has(lockKey)) {
              perFileIoLimiters.set(lockKey, pLimit(1));
            }
            return perFileIoLimiters.get(lockKey);
          };
          const workersCount = effectiveConcurrency;
          const workerTasks = [];
          for (let i = 0; i < workersCount; i++) {
            const assignedTasks = ctx.tasks.filter(
              (_36, idx) => idx % workersCount === i
            );
            workerTasks.push(
              createWorkerTask({
                ctx,
                assignedTasks,
                ioLimiter,
                i18nLimiter,
                initialChecksumsMap,
                getFileIoLimiter,
                onDone() {
                  task.title = createExecutionProgressMessage(ctx);
                }
              })
            );
          }
          return task.newListr(workerTasks, {
            concurrent: true,
            exitOnError: false,
            rendererOptions: {
              ...commonTaskRendererOptions,
              collapseSubtasks: true
            }
          });
        }
      }
    ],
    {
      exitOnError: false,
      rendererOptions: commonTaskRendererOptions
    }
  ).run(input2);
}
function createWorkerStatusMessage(args) {
  const displayPath = args.assignedTask.bucketPathPattern.replace(
    "[locale]",
    args.assignedTask.targetLocale
  );
  return `[${chalk12.hex(colors.yellow)(
    `${args.percentage}%`
  )}] Processing: ${chalk12.dim(displayPath)} (${chalk12.hex(colors.yellow)(
    args.assignedTask.sourceLocale
  )} -> ${chalk12.hex(colors.yellow)(args.assignedTask.targetLocale)})`;
}
function createExecutionProgressMessage(ctx) {
  const succeededTasksCount = countTasks(
    ctx,
    (_t, result) => result.status === "success"
  );
  const failedTasksCount = countTasks(
    ctx,
    (_t, result) => result.status === "error"
  );
  const skippedTasksCount = countTasks(
    ctx,
    (_t, result) => result.status === "skipped"
  );
  return `Processed ${chalk12.green(succeededTasksCount)}/${ctx.tasks.length}, Failed ${chalk12.red(failedTasksCount)}, Skipped ${chalk12.dim(
    skippedTasksCount
  )}`;
}
function createLoaderForTask(assignedTask) {
  const bucketLoader = createBucketLoader(
    assignedTask.bucketType,
    assignedTask.bucketPathPattern,
    {
      defaultLocale: assignedTask.sourceLocale,
      injectLocale: assignedTask.injectLocale,
      formatter: assignedTask.formatter
    },
    assignedTask.lockedKeys,
    assignedTask.lockedPatterns,
    assignedTask.ignoredKeys
  );
  bucketLoader.setDefaultLocale(assignedTask.sourceLocale);
  return bucketLoader;
}
function createWorkerTask(args) {
  return {
    title: "Initializing...",
    task: async (_subCtx, subTask) => {
      for (const assignedTask of args.assignedTasks) {
        subTask.title = createWorkerStatusMessage({
          assignedTask,
          percentage: 0
        });
        const bucketLoader = createLoaderForTask(assignedTask);
        const deltaProcessor = createDeltaProcessor(
          assignedTask.bucketPathPattern
        );
        const initialChecksums = args.initialChecksumsMap.get(assignedTask.bucketPathPattern) || {};
        const taskResult = await args.i18nLimiter(async () => {
          try {
            const fileIoLimiter = args.getFileIoLimiter(
              assignedTask.bucketPathPattern
            );
            const sourceData = await fileIoLimiter(
              async () => bucketLoader.pull(assignedTask.sourceLocale)
            );
            const hints = await fileIoLimiter(
              async () => bucketLoader.pullHints()
            );
            const targetData = await fileIoLimiter(
              async () => bucketLoader.pull(assignedTask.targetLocale)
            );
            const delta = await deltaProcessor.calculateDelta({
              sourceData,
              targetData,
              checksums: initialChecksums
            });
            const processableData = _34.chain(sourceData).entries().filter(
              ([key, value]) => delta.added.includes(key) || delta.updated.includes(key) || !!args.ctx.flags.force
            ).filter(
              ([key]) => !assignedTask.onlyKeys.length || assignedTask.onlyKeys?.some(
                (pattern) => minimatch(key, pattern)
              )
            ).fromPairs().value();
            if (!Object.keys(processableData).length) {
              await fileIoLimiter(async () => {
                await bucketLoader.push(assignedTask.targetLocale, targetData);
              });
              return {
                status: "skipped",
                pathPattern: assignedTask.bucketPathPattern,
                sourceLocale: assignedTask.sourceLocale,
                targetLocale: assignedTask.targetLocale
              };
            }
            const relevantHints = _34.pick(hints, Object.keys(processableData));
            const processedTargetData = await args.ctx.localizer.localize(
              {
                sourceLocale: assignedTask.sourceLocale,
                targetLocale: assignedTask.targetLocale,
                sourceData,
                targetData,
                processableData,
                hints: relevantHints
              },
              async (progress, _sourceChunk, processedChunk) => {
                await fileIoLimiter(async () => {
                  await bucketLoader.pull(assignedTask.sourceLocale);
                  const latestTargetData = await bucketLoader.pull(
                    assignedTask.targetLocale
                  );
                  const _partialData = _34.merge(
                    {},
                    latestTargetData,
                    processedChunk
                  );
                  const finalChunkTargetData = processRenamedKeys(
                    delta,
                    _partialData
                  );
                  await bucketLoader.push(
                    assignedTask.targetLocale,
                    finalChunkTargetData
                  );
                });
                subTask.title = createWorkerStatusMessage({
                  assignedTask,
                  percentage: progress
                });
              }
            );
            const finalTargetData = _34.merge(
              {},
              sourceData,
              targetData,
              processedTargetData
            );
            const finalRenamedTargetData = processRenamedKeys(
              delta,
              finalTargetData
            );
            await fileIoLimiter(async () => {
              await bucketLoader.pull(assignedTask.sourceLocale);
              await bucketLoader.push(
                assignedTask.targetLocale,
                finalRenamedTargetData
              );
              const checksums = await deltaProcessor.createChecksums(sourceData);
              if (!args.ctx.flags.targetLocale?.length) {
                await deltaProcessor.saveChecksums(checksums);
              }
            });
            return {
              status: "success",
              pathPattern: assignedTask.bucketPathPattern,
              sourceLocale: assignedTask.sourceLocale,
              targetLocale: assignedTask.targetLocale
            };
          } catch (error) {
            return {
              status: "error",
              error,
              pathPattern: assignedTask.bucketPathPattern,
              sourceLocale: assignedTask.sourceLocale,
              targetLocale: assignedTask.targetLocale
            };
          }
        });
        args.ctx.results.set(assignedTask, taskResult);
      }
      subTask.title = "Done";
    }
  };
}
function countTasks(ctx, predicate) {
  return Array.from(ctx.results.entries()).filter(
    ([task, result]) => predicate(task, result)
  ).length;
}
function processRenamedKeys(delta, targetData) {
  return _34.chain(targetData).entries().map(([key, value]) => {
    const renaming = delta.renamed.find(([oldKey]) => oldKey === key);
    if (!renaming) {
      return [key, value];
    }
    return [renaming[1], value];
  }).fromPairs().value();
}

// src/cli/cmd/run/watch.ts
import * as chokidar from "chokidar";
import chalk13 from "chalk";
async function watch2(ctx) {
  const debounceDelay = ctx.flags.debounce || 5e3;
  console.log(chalk13.hex(colors.orange)("[Watch Mode]"));
  console.log(
    `\u{1F440} Watching for changes... (Press ${chalk13.yellow("Ctrl+C")} to stop)`
  );
  console.log(chalk13.dim(`   Debounce delay: ${debounceDelay}ms`));
  console.log("");
  const state = {
    isRunning: false,
    pendingChanges: /* @__PURE__ */ new Set()
  };
  const watchPatterns = await getWatchPatterns(ctx);
  if (watchPatterns.length === 0) {
    console.log(chalk13.yellow("\u26A0\uFE0F  No source files found to watch"));
    return;
  }
  console.log(chalk13.dim(`Watching ${watchPatterns.length} file pattern(s):`));
  watchPatterns.forEach((pattern) => {
    console.log(chalk13.dim(`  \u2022 ${pattern}`));
  });
  console.log("");
  const watcher = chokidar.watch(watchPatterns, {
    ignoreInitial: true,
    persistent: true,
    awaitWriteFinish: {
      stabilityThreshold: 500,
      pollInterval: 100
    }
  });
  watcher.on("change", (path19) => {
    handleFileChange(path19, state, ctx);
  });
  watcher.on("add", (path19) => {
    handleFileChange(path19, state, ctx);
  });
  watcher.on("unlink", (path19) => {
    handleFileChange(path19, state, ctx);
  });
  watcher.on("error", (error) => {
    console.error(
      chalk13.red(
        `Watch error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
  });
  process.on("SIGINT", () => {
    console.log(chalk13.yellow("\n\n\u{1F6D1} Stopping watch mode..."));
    watcher.close();
    process.exit(0);
  });
  await new Promise(() => {
  });
}
async function getWatchPatterns(ctx) {
  if (!ctx.config) return [];
  const buckets = getBuckets(ctx.config);
  const patterns = [];
  for (const bucket of buckets) {
    if (ctx.flags.bucket && !ctx.flags.bucket.includes(bucket.type)) {
      continue;
    }
    for (const bucketPath of bucket.paths) {
      if (ctx.flags.file) {
        if (!ctx.flags.file.some(
          (f) => bucketPath.pathPattern.includes(f) || minimatch(bucketPath.pathPattern, f)
        )) {
          continue;
        }
      }
      const sourceLocale = ctx.flags.sourceLocale || ctx.config.locale.source;
      const sourcePattern = bucketPath.pathPattern.replace(
        "[locale]",
        sourceLocale
      );
      patterns.push(sourcePattern);
    }
  }
  return patterns;
}
function handleFileChange(filePath, state, ctx) {
  const debounceDelay = ctx.flags.debounce || 5e3;
  state.pendingChanges.add(filePath);
  console.log(chalk13.dim(`\u{1F4DD} File changed: ${filePath}`));
  if (state.debounceTimer) {
    clearTimeout(state.debounceTimer);
  }
  state.debounceTimer = setTimeout(async () => {
    if (state.isRunning) {
      console.log(
        chalk13.yellow("\u23F3 Translation already in progress, skipping...")
      );
      return;
    }
    await triggerRetranslation(state, ctx);
  }, debounceDelay);
}
async function triggerRetranslation(state, ctx) {
  if (state.isRunning) return;
  state.isRunning = true;
  try {
    const changedFiles = Array.from(state.pendingChanges);
    state.pendingChanges.clear();
    console.log(chalk13.hex(colors.green)("\n\u{1F504} Triggering retranslation..."));
    console.log(chalk13.dim(`Changed files: ${changedFiles.join(", ")}`));
    console.log("");
    const runCtx = {
      ...ctx,
      tasks: [],
      results: /* @__PURE__ */ new Map()
    };
    await plan(runCtx);
    if (runCtx.tasks.length === 0) {
      console.log(chalk13.dim("\u2728 No translation tasks needed"));
    } else {
      await execute(runCtx);
      await renderSummary(runCtx.results);
    }
    console.log(chalk13.hex(colors.green)("\u2705 Retranslation completed"));
    console.log(chalk13.dim("\u{1F440} Continuing to watch for changes...\n"));
  } catch (error) {
    console.error(chalk13.red(`\u274C Retranslation failed: ${error.message}`));
    console.log(chalk13.dim("\u{1F440} Continuing to watch for changes...\n"));
  } finally {
    state.isRunning = false;
  }
}

// src/cli/cmd/run/_types.ts
import {
  bucketTypeSchema as bucketTypeSchema3
} from "@lingo.dev/_spec";
import { z as z2 } from "zod";
var flagsSchema2 = z2.object({
  bucket: z2.array(bucketTypeSchema3).optional(),
  key: z2.array(z2.string()).optional(),
  file: z2.array(z2.string()).optional(),
  apiKey: z2.string().optional(),
  force: z2.boolean().optional(),
  frozen: z2.boolean().optional(),
  verbose: z2.boolean().optional(),
  strict: z2.boolean().optional(),
  interactive: z2.boolean().default(false),
  concurrency: z2.number().positive().default(10),
  debug: z2.boolean().default(false),
  sourceLocale: z2.string().optional(),
  targetLocale: z2.array(z2.string()).optional(),
  watch: z2.boolean().default(false),
  debounce: z2.number().positive().default(5e3),
  // 5 seconds default
  sound: z2.boolean().optional()
});

// src/cli/cmd/run/frozen.ts
import chalk14 from "chalk";
import { Listr as Listr4 } from "listr2";
import _35 from "lodash";
import { resolveOverriddenLocale as resolveOverriddenLocale8 } from "@lingo.dev/_spec";
async function frozen(input2) {
  console.log(chalk14.hex(colors.orange)("[Frozen]"));
  let buckets = getBuckets(input2.config);
  if (input2.flags.bucket?.length) {
    buckets = buckets.filter((b) => input2.flags.bucket.includes(b.type));
  }
  if (input2.flags.file?.length) {
    buckets = buckets.map((bucket) => {
      const paths = bucket.paths.filter(
        (p) => input2.flags.file.some(
          (f) => p.pathPattern.includes(f) || minimatch(p.pathPattern, f)
        )
      );
      return { ...bucket, paths };
    }).filter((bucket) => bucket.paths.length > 0);
  }
  const _sourceLocale = input2.flags.sourceLocale || input2.config.locale.source;
  const _targetLocales = input2.flags.targetLocale || input2.config.locale.targets;
  return new Listr4(
    [
      {
        title: "Setting up localization cache",
        task: async (_ctx, task) => {
          const checkLockfileProcessor = createDeltaProcessor("");
          const lockfileExists = await checkLockfileProcessor.checkIfLockExists();
          if (!lockfileExists) {
            for (const bucket of buckets) {
              for (const bucketPath of bucket.paths) {
                const resolvedSourceLocale = resolveOverriddenLocale8(
                  _sourceLocale,
                  bucketPath.delimiter
                );
                const loader = createBucketLoader(
                  bucket.type,
                  bucketPath.pathPattern,
                  {
                    defaultLocale: resolvedSourceLocale,
                    injectLocale: bucket.injectLocale,
                    formatter: input2.config.formatter
                  },
                  bucket.lockedKeys,
                  bucket.lockedPatterns,
                  bucket.ignoredKeys
                );
                loader.setDefaultLocale(resolvedSourceLocale);
                await loader.init();
                const sourceData = await loader.pull(_sourceLocale);
                const delta = createDeltaProcessor(bucketPath.pathPattern);
                const checksums = await delta.createChecksums(sourceData);
                await delta.saveChecksums(checksums);
              }
            }
            task.title = "Localization cache initialized";
          } else {
            task.title = "Localization cache loaded";
          }
        }
      },
      {
        title: "Validating frozen state",
        enabled: () => !!input2.flags.frozen,
        task: async (_ctx, task) => {
          for (const bucket of buckets) {
            for (const bucketPath of bucket.paths) {
              const resolvedSourceLocale = resolveOverriddenLocale8(
                _sourceLocale,
                bucketPath.delimiter
              );
              const loader = createBucketLoader(
                bucket.type,
                bucketPath.pathPattern,
                {
                  defaultLocale: resolvedSourceLocale,
                  returnUnlocalizedKeys: true,
                  injectLocale: bucket.injectLocale
                },
                bucket.lockedKeys,
                bucket.lockedPatterns,
                bucket.ignoredKeys
              );
              loader.setDefaultLocale(resolvedSourceLocale);
              await loader.init();
              const { unlocalizable: srcUnlocalizable, ...src } = await loader.pull(_sourceLocale);
              const delta = createDeltaProcessor(bucketPath.pathPattern);
              const sourceChecksums = await delta.createChecksums(src);
              const savedChecksums = await delta.loadChecksums();
              const updatedSourceData = _35.pickBy(
                src,
                (value, key) => sourceChecksums[key] !== savedChecksums[key]
              );
              if (Object.keys(updatedSourceData).length > 0) {
                throw new Error(
                  `Localization data has changed; please update i18n.lock or run without --frozen. Details: Source file has been updated.`
                );
              }
              for (const _tgt of _targetLocales) {
                const resolvedTargetLocale = resolveOverriddenLocale8(
                  _tgt,
                  bucketPath.delimiter
                );
                const { unlocalizable: tgtUnlocalizable, ...tgt } = await loader.pull(resolvedTargetLocale);
                const missingKeys = _35.difference(
                  Object.keys(src),
                  Object.keys(tgt)
                );
                if (missingKeys.length > 0) {
                  throw new Error(
                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Target file is missing translations.`
                  );
                }
                const extraKeys = _35.difference(
                  Object.keys(tgt),
                  Object.keys(src)
                );
                if (extraKeys.length > 0) {
                  throw new Error(
                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Target file has extra translations not present in the source file.`
                  );
                }
                const unlocalizableDataDiff = !_35.isEqual(
                  srcUnlocalizable,
                  tgtUnlocalizable
                );
                if (unlocalizableDataDiff) {
                  throw new Error(
                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Unlocalizable data (such as booleans, dates, URLs, etc.) do not match.`
                  );
                }
              }
            }
          }
          task.title = "No lockfile updates required";
        }
      }
    ],
    {
      rendererOptions: commonTaskRendererOptions
    }
  ).run(input2);
}

// src/cli/cmd/run/_utils.ts
async function determineAuthId(ctx) {
  const isByokMode = !!ctx.config?.provider;
  if (isByokMode) {
    return null;
  } else {
    try {
      const authStatus = await ctx.localizer?.checkAuth();
      return authStatus?.username || null;
    } catch {
      return null;
    }
  }
}

// src/cli/cmd/run/index.ts
var __dirname = path17.dirname(fileURLToPath(import.meta.url));
function playSound(type) {
  const platform = os2.platform();
  return new Promise((resolve) => {
    const assetDir = path17.join(__dirname, "../assets");
    const soundFiles = [path17.join(assetDir, `${type}.mp3`)];
    let command = "";
    if (platform === "linux") {
      command = soundFiles.map(
        (file) => `mpg123 -q "${file}" 2>/dev/null || aplay "${file}" 2>/dev/null`
      ).join(" || ");
    } else if (platform === "darwin") {
      command = soundFiles.map((file) => `afplay "${file}"`).join(" || ");
    } else if (platform === "win32") {
      command = `powershell -c "try { (New-Object Media.SoundPlayer '${soundFiles[1]}').PlaySync() } catch { Start-Process -FilePath '${soundFiles[0]}' -WindowStyle Hidden -Wait }"`;
    } else {
      command = soundFiles.map(
        (file) => `aplay "${file}" 2>/dev/null || afplay "${file}" 2>/dev/null`
      ).join(" || ");
    }
    exec(command, () => {
      resolve();
    });
    setTimeout(resolve, 3e3);
  });
}
var run_default = new Command18().command("run").description("Run localization pipeline").helpOption("-h, --help", "Show help").option(
  "--source-locale <source-locale>",
  "Override the source locale from i18n.json for this run"
).option(
  "--target-locale <target-locale>",
  "Limit processing to the listed target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--bucket <bucket>",
  "Limit processing to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all configured buckets",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--file <file>",
  "Filter bucket path pattern values by substring match. Examples: messages.json or locale/. Repeat to add multiple filters",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--key <key>",
  "Filter keys by prefix matching on dot-separated paths. Example: auth.login to match all keys starting with auth.login. Repeat for multiple patterns",
  (val, prev) => prev ? [...prev, encodeURIComponent(val)] : [encodeURIComponent(val)]
).option(
  "--force",
  "Force re-translation of all keys, bypassing change detection. Useful when you want to regenerate translations with updated AI models or translation settings"
).option(
  "--frozen",
  "Validate translations are up-to-date without making changes - fails if source files, target files, or lockfile are out of sync. Ideal for CI/CD to ensure translation consistency before deployment"
).option(
  "--api-key <api-key>",
  "Override API key from settings or environment variables"
).option("--debug", "Pause before processing to allow attaching a debugger.").option(
  "--concurrency <concurrency>",
  "Number of translation jobs to run concurrently. Higher values can speed up large translation batches but may increase memory usage. Defaults to 10 (maximum 10)",
  (val) => parseInt(val)
).option(
  "--watch",
  "Watch source locale files continuously and retranslate automatically when files change"
).option(
  "--debounce <milliseconds>",
  "Delay in milliseconds after file changes before retranslating in watch mode. Defaults to 5000",
  (val) => parseInt(val)
).option(
  "--sound",
  "Play audio feedback when translations complete (success or failure sounds)"
).action(async (args) => {
  let authId = null;
  try {
    const ctx = {
      flags: flagsSchema2.parse(args),
      config: null,
      results: /* @__PURE__ */ new Map(),
      tasks: [],
      localizer: null
    };
    await pauseIfDebug(ctx.flags.debug);
    await renderClear();
    await renderSpacer();
    await renderBanner();
    await renderHero();
    await renderSpacer();
    await setup(ctx);
    authId = await determineAuthId(ctx);
    await trackEvent(authId, "cmd.run.start", {
      config: ctx.config,
      flags: ctx.flags
    });
    await renderSpacer();
    await plan(ctx);
    await renderSpacer();
    await frozen(ctx);
    await renderSpacer();
    await execute(ctx);
    await renderSpacer();
    await renderSummary(ctx.results);
    await renderSpacer();
    if (ctx.flags.sound) {
      await playSound("success");
    }
    if (ctx.flags.watch) {
      await watch2(ctx);
    }
    await trackEvent(authId, "cmd.run.success", {
      config: ctx.config,
      flags: ctx.flags
    });
  } catch (error) {
    await trackEvent(authId || "unknown", "cmd.run.error", {});
    if (args.sound) {
      await playSound("failure");
    }
    throw error;
  }
});

// src/cli/cmd/ci/flows/in-branch.ts
var InBranchFlow = class extends IntegrationFlow {
  async preRun() {
    this.ora.start("Configuring git");
    const canContinue = this.configureGit();
    this.ora.succeed("Git configured");
    return canContinue;
  }
  async run(options) {
    this.ora.start("Running Lingo.dev");
    await this.runLingoDotDev(options.parallel);
    this.ora.succeed("Done running Lingo.dev");
    execSync(`rm -f i18n.cache`, { stdio: "inherit" });
    this.ora.start("Checking for changes");
    const hasChanges = this.checkCommitableChanges();
    this.ora.succeed(hasChanges ? "Changes detected" : "No changes detected");
    if (hasChanges) {
      this.ora.start("Committing changes");
      execSync(`git add .`, { stdio: "inherit" });
      execSync(`git status --porcelain`, { stdio: "inherit" });
      execSync(
        `git commit -m ${escapeShellArg(
          this.platformKit.config.commitMessage
        )} --no-verify`,
        {
          stdio: "inherit"
        }
      );
      this.ora.succeed("Changes committed");
      this.ora.start("Pushing changes to remote");
      const currentBranch = this.i18nBranchName ?? this.platformKit.platformConfig.baseBranchName;
      execSync(
        `git push origin ${currentBranch} ${options.force ? "--force" : ""}`,
        {
          stdio: "inherit"
        }
      );
      this.ora.succeed("Changes pushed to remote");
    }
    return hasChanges;
  }
  checkCommitableChanges() {
    return execSync('git status --porcelain || echo "has_changes"', {
      encoding: "utf8"
    }).length > 0;
  }
  async runLingoDotDev(isParallel) {
    try {
      if (!isParallel) {
        await i18n_default.exitOverride().parseAsync(["--api-key", this.platformKit.config.replexicaApiKey], {
          from: "user"
        });
      } else {
        await run_default.exitOverride().parseAsync(["--api-key", this.platformKit.config.replexicaApiKey], {
          from: "user"
        });
      }
    } catch (err) {
      if (err.code === "commander.helpDisplayed") return;
      throw err;
    }
  }
  configureGit() {
    const { processOwnCommits } = this.platformKit.config;
    const { baseBranchName } = this.platformKit.platformConfig;
    const gitConfig = getGitConfig(this.platformKit);
    this.ora.info(`Current working directory:`);
    execSync(`pwd`, { stdio: "inherit" });
    execSync(`ls -la`, { stdio: "inherit" });
    execSync(`git config --global safe.directory ${process.cwd()}`);
    execSync(`git config user.name "${gitConfig.userName}"`);
    execSync(`git config user.email "${gitConfig.userEmail}"`);
    this.platformKit?.gitConfig();
    execSync(`git fetch origin ${baseBranchName}`, { stdio: "inherit" });
    execSync(`git checkout ${baseBranchName} --`, { stdio: "inherit" });
    if (!processOwnCommits) {
      const currentAuthor = `${gitConfig.userName} <${gitConfig.userEmail}>`;
      const authorOfLastCommit = execSync(
        `git log -1 --pretty=format:'%an <%ae>'`
      ).toString();
      if (authorOfLastCommit === currentAuthor) {
        this.ora.warn(
          `The last commit was already made by ${currentAuthor}, so this run will be skipped, as running again would have no effect. See docs: https://lingo.dev/ci`
        );
        return false;
      }
    }
    const workingDir = path18.resolve(
      process.cwd(),
      this.platformKit.config.workingDir
    );
    if (workingDir !== process.cwd()) {
      this.ora.info(
        `Changing to working directory: ${this.platformKit.config.workingDir}`
      );
      process.chdir(workingDir);
    }
    return true;
  }
};

// src/cli/cmd/ci/flows/pull-request.ts
var PullRequestFlow = class extends InBranchFlow {
  async preRun() {
    const canContinue = await super.preRun?.();
    if (!canContinue) {
      return false;
    }
    this.ora.start("Calculating automated branch name");
    this.i18nBranchName = this.calculatePrBranchName();
    this.ora.succeed(
      `Automated branch name calculated: ${this.i18nBranchName}`
    );
    this.ora.start("Checking if branch exists");
    const branchExists = await this.checkBranchExistance(this.i18nBranchName);
    this.ora.succeed(branchExists ? "Branch exists" : "Branch does not exist");
    if (branchExists) {
      this.ora.start(`Checking out branch ${this.i18nBranchName}`);
      this.checkoutI18nBranch(this.i18nBranchName);
      this.ora.succeed(`Checked out branch ${this.i18nBranchName}`);
      this.ora.start(
        `Syncing with ${this.platformKit.platformConfig.baseBranchName}`
      );
      this.syncI18nBranch();
      this.ora.succeed(`Checked out and synced branch ${this.i18nBranchName}`);
    } else {
      this.ora.start(`Creating branch ${this.i18nBranchName}`);
      this.createI18nBranch(this.i18nBranchName);
      this.ora.succeed(`Created branch ${this.i18nBranchName}`);
    }
    return true;
  }
  async run(options) {
    return super.run({
      force: true,
      ...options
    });
  }
  async postRun() {
    if (!this.i18nBranchName) {
      throw new Error(
        "i18nBranchName is not set. Did you forget to call preRun?"
      );
    }
    this.ora.start("Checking if PR already exists");
    const pullRequestNumber = await this.ensureFreshPr(this.i18nBranchName);
    this.ora.succeed(
      `Pull request ready: ${this.platformKit.buildPullRequestUrl(
        pullRequestNumber
      )}`
    );
  }
  calculatePrBranchName() {
    return `lingo.dev/${this.platformKit.platformConfig.baseBranchName}`;
  }
  async checkBranchExistance(prBranchName) {
    return this.platformKit.branchExists({
      branch: prBranchName
    });
  }
  async ensureFreshPr(i18nBranchName) {
    this.ora.start(
      `Checking for existing PR with head ${i18nBranchName} and base ${this.platformKit.platformConfig.baseBranchName}`
    );
    let prNumber = await this.platformKit.getOpenPullRequestNumber({
      branch: i18nBranchName
    });
    if (prNumber) {
      this.ora.succeed(`Existing PR found: #${prNumber}`);
    } else {
      this.ora.start(`Creating new PR`);
      prNumber = await this.platformKit.createPullRequest({
        head: i18nBranchName,
        title: this.platformKit.config.pullRequestTitle,
        body: this.getPrBodyContent()
      });
      this.ora.succeed(`Created new PR: #${prNumber}`);
    }
    return prNumber;
  }
  checkoutI18nBranch(i18nBranchName) {
    execSync2(`git fetch origin ${i18nBranchName}`, { stdio: "inherit" });
    execSync2(`git checkout -b ${i18nBranchName}`, {
      stdio: "inherit"
    });
  }
  createI18nBranch(i18nBranchName) {
    try {
      execSync2(
        `git fetch origin ${this.platformKit.platformConfig.baseBranchName}`,
        { stdio: "inherit" }
      );
      execSync2(
        `git checkout -b ${i18nBranchName} origin/${this.platformKit.platformConfig.baseBranchName}`,
        {
          stdio: "inherit"
        }
      );
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      this.ora.fail(`Failed to create branch: ${errorMessage}`);
      this.ora.info(`
      Troubleshooting tips:
      1. Make sure you have permission to create branches
      2. Check if the branch already exists locally (try 'git branch -a')
      3. Verify connectivity to remote repository
    `);
      throw new Error(`Branch creation failed: ${errorMessage}`);
    }
  }
  syncI18nBranch() {
    if (!this.i18nBranchName) {
      throw new Error("i18nBranchName is not set");
    }
    this.ora.start(
      `Fetching latest changes from ${this.platformKit.platformConfig.baseBranchName}`
    );
    execSync2(
      `git fetch origin ${this.platformKit.platformConfig.baseBranchName}`,
      { stdio: "inherit" }
    );
    this.ora.succeed(
      `Fetched latest changes from ${this.platformKit.platformConfig.baseBranchName}`
    );
    try {
      this.ora.start("Attempting to rebase branch");
      execSync2(
        `git rebase origin/${this.platformKit.platformConfig.baseBranchName}`,
        { stdio: "inherit" }
      );
      this.ora.succeed("Successfully rebased branch");
    } catch (error) {
      this.ora.warn("Rebase failed, falling back to alternative sync method");
      this.ora.start("Aborting failed rebase");
      execSync2("git rebase --abort", { stdio: "inherit" });
      this.ora.succeed("Aborted failed rebase");
      this.ora.start(
        `Resetting to ${this.platformKit.platformConfig.baseBranchName}`
      );
      execSync2(
        `git reset --hard origin/${this.platformKit.platformConfig.baseBranchName}`,
        { stdio: "inherit" }
      );
      this.ora.succeed(
        `Reset to ${this.platformKit.platformConfig.baseBranchName}`
      );
      this.ora.start("Restoring target files");
      const targetFiles = ["i18n.lock"];
      const targetFileNames = execSync2(
        `npx lingo.dev@latest show files --target ${this.platformKit.platformConfig.baseBranchName}`,
        { encoding: "utf8" }
      ).split("\n").filter(Boolean);
      targetFiles.push(...targetFileNames);
      execSync2(`git fetch origin ${this.i18nBranchName}`, { stdio: "inherit" });
      for (const file of targetFiles) {
        try {
          execSync2(`git checkout FETCH_HEAD -- ${file}`, { stdio: "inherit" });
        } catch (error2) {
          this.ora.warn(`Skipping non-existent file: ${file}`);
          continue;
        }
      }
      this.ora.succeed("Restored target files");
    }
    this.ora.start("Checking for changes to commit");
    const hasChanges = this.checkCommitableChanges();
    if (hasChanges) {
      execSync2("git add .", { stdio: "inherit" });
      execSync2(
        `git commit -m "chore: sync with ${this.platformKit.platformConfig.baseBranchName}" --no-verify`,
        {
          stdio: "inherit"
        }
      );
      this.ora.succeed("Committed additional changes");
    } else {
      this.ora.succeed("No changes to commit");
    }
  }
  getPrBodyContent() {
    return `
Hey team,

[**Lingo.dev**](https://lingo.dev) here with fresh translations!

### In this update

- Added missing translations
- Performed brand voice, context and glossary checks
- Enhanced translations using Lingo.dev Localization Engine

### Next Steps

- [ ] Review the changes
- [ ] Merge when ready
    `.trim();
  }
};

// src/cli/cmd/ci/platforms/bitbucket.ts
import { execSync as execSync4 } from "child_process";
import bbLib from "bitbucket";
import Z8 from "zod";

// src/cli/cmd/ci/platforms/_base.ts
import { execSync as execSync3 } from "child_process";
import Z7 from "zod";
var defaultMessage = "feat: update translations via @lingodotdev";
var PlatformKit = class {
  gitConfig(token, repoUrl) {
    if (token && repoUrl) {
      execSync3(`git remote set-url origin ${repoUrl}`, {
        stdio: "inherit"
      });
    }
  }
  get config() {
    const env = Z7.object({
      LINGODOTDEV_API_KEY: Z7.string(),
      LINGODOTDEV_PULL_REQUEST: Z7.preprocess(
        (val) => val === "true" || val === true,
        Z7.boolean()
      ),
      LINGODOTDEV_COMMIT_MESSAGE: Z7.string().optional(),
      LINGODOTDEV_PULL_REQUEST_TITLE: Z7.string().optional(),
      LINGODOTDEV_COMMIT_AUTHOR_NAME: Z7.string().optional(),
      LINGODOTDEV_COMMIT_AUTHOR_EMAIL: Z7.string().optional(),
      LINGODOTDEV_WORKING_DIRECTORY: Z7.string().optional(),
      LINGODOTDEV_PROCESS_OWN_COMMITS: Z7.preprocess(
        (val) => val === "true" || val === true,
        Z7.boolean()
      ).optional()
    }).parse(process.env);
    return {
      replexicaApiKey: env.LINGODOTDEV_API_KEY,
      isPullRequestMode: env.LINGODOTDEV_PULL_REQUEST,
      commitMessage: env.LINGODOTDEV_COMMIT_MESSAGE || defaultMessage,
      pullRequestTitle: env.LINGODOTDEV_PULL_REQUEST_TITLE || defaultMessage,
      commitAuthorName: env.LINGODOTDEV_COMMIT_AUTHOR_NAME || "Lingo.dev",
      commitAuthorEmail: env.LINGODOTDEV_COMMIT_AUTHOR_EMAIL || "support@lingo.dev",
      workingDir: env.LINGODOTDEV_WORKING_DIRECTORY || ".",
      processOwnCommits: env.LINGODOTDEV_PROCESS_OWN_COMMITS || false
    };
  }
};

// src/cli/cmd/ci/platforms/bitbucket.ts
var { Bitbucket } = bbLib;
var BitbucketPlatformKit = class extends PlatformKit {
  _bb;
  get bb() {
    if (!this._bb) {
      this._bb = new Bitbucket({
        auth: { token: this.platformConfig.bbToken || "" }
      });
    }
    return this._bb;
  }
  async branchExists({ branch }) {
    return await this.bb.repositories.getBranch({
      workspace: this.platformConfig.repositoryOwner,
      repo_slug: this.platformConfig.repositoryName,
      name: branch
    }).then((r) => r.data).then((v) => !!v).catch((r) => r.status === 404 ? false : Promise.reject(r));
  }
  async getOpenPullRequestNumber({ branch }) {
    return await this.bb.repositories.listPullRequests({
      workspace: this.platformConfig.repositoryOwner,
      repo_slug: this.platformConfig.repositoryName,
      state: "OPEN"
    }).then(({ data: { values } }) => {
      return values?.find(
        ({ source, destination }) => source?.branch?.name === branch && destination?.branch?.name === this.platformConfig.baseBranchName
      );
    }).then((pr) => pr?.id);
  }
  async closePullRequest({ pullRequestNumber }) {
    await this.bb.repositories.declinePullRequest({
      workspace: this.platformConfig.repositoryOwner,
      repo_slug: this.platformConfig.repositoryName,
      pull_request_id: pullRequestNumber
    });
  }
  async createPullRequest({
    title,
    body,
    head
  }) {
    return await this.bb.repositories.createPullRequest({
      workspace: this.platformConfig.repositoryOwner,
      repo_slug: this.platformConfig.repositoryName,
      _body: {
        title,
        description: body,
        source: { branch: { name: head } },
        destination: { branch: { name: this.platformConfig.baseBranchName } }
      }
    }).then(({ data }) => data.id ?? 0);
  }
  async commentOnPullRequest({
    pullRequestNumber,
    body
  }) {
    await this.bb.repositories.createPullRequestComment({
      workspace: this.platformConfig.repositoryOwner,
      repo_slug: this.platformConfig.repositoryName,
      pull_request_id: pullRequestNumber,
      _body: {
        content: {
          raw: body
        }
      }
    });
  }
  async gitConfig() {
    execSync4("git config --unset http.${BITBUCKET_GIT_HTTP_ORIGIN}.proxy", {
      stdio: "inherit"
    });
    execSync4(
      "git config http.${BITBUCKET_GIT_HTTP_ORIGIN}.proxy http://host.docker.internal:29418/",
      {
        stdio: "inherit"
      }
    );
  }
  get platformConfig() {
    const env = Z8.object({
      BITBUCKET_BRANCH: Z8.string(),
      BITBUCKET_REPO_FULL_NAME: Z8.string(),
      BB_TOKEN: Z8.string().optional()
    }).parse(process.env);
    const [repositoryOwner, repositoryName] = env.BITBUCKET_REPO_FULL_NAME.split("/");
    return {
      baseBranchName: env.BITBUCKET_BRANCH,
      repositoryOwner,
      repositoryName,
      bbToken: env.BB_TOKEN
    };
  }
  buildPullRequestUrl(pullRequestNumber) {
    const { repositoryOwner, repositoryName } = this.platformConfig;
    return `https://bitbucket.org/${repositoryOwner}/${repositoryName}/pull-requests/${pullRequestNumber}`;
  }
};

// src/cli/cmd/ci/platforms/github.ts
import { Octokit } from "octokit";
import Z9 from "zod";
var GitHubPlatformKit = class extends PlatformKit {
  _octokit;
  get octokit() {
    if (!this._octokit) {
      this._octokit = new Octokit({ auth: this.platformConfig.ghToken });
    }
    return this._octokit;
  }
  async branchExists({ branch }) {
    return await this.octokit.rest.repos.getBranch({
      branch,
      owner: this.platformConfig.repositoryOwner,
      repo: this.platformConfig.repositoryName
    }).then((r) => r.data).then((v) => !!v).catch((r) => r.status === 404 ? false : Promise.reject(r));
  }
  async getOpenPullRequestNumber({ branch }) {
    return await this.octokit.rest.pulls.list({
      head: `${this.platformConfig.repositoryOwner}:${branch}`,
      owner: this.platformConfig.repositoryOwner,
      repo: this.platformConfig.repositoryName,
      base: this.platformConfig.baseBranchName,
      state: "open"
    }).then(({ data }) => data[0]).then((pr) => pr?.number);
  }
  async closePullRequest({ pullRequestNumber }) {
    await this.octokit.rest.pulls.update({
      pull_number: pullRequestNumber,
      owner: this.platformConfig.repositoryOwner,
      repo: this.platformConfig.repositoryName,
      state: "closed"
    });
  }
  async createPullRequest({
    head,
    title,
    body
  }) {
    return await this.octokit.rest.pulls.create({
      head,
      title,
      body,
      owner: this.platformConfig.repositoryOwner,
      repo: this.platformConfig.repositoryName,
      base: this.platformConfig.baseBranchName
    }).then(({ data }) => data.number);
  }
  async commentOnPullRequest({
    pullRequestNumber,
    body
  }) {
    await this.octokit.rest.issues.createComment({
      issue_number: pullRequestNumber,
      body,
      owner: this.platformConfig.repositoryOwner,
      repo: this.platformConfig.repositoryName
    });
  }
  async gitConfig() {
    const { ghToken, repositoryOwner, repositoryName } = this.platformConfig;
    const { processOwnCommits } = this.config;
    if (ghToken && processOwnCommits) {
      console.log(
        "Using provided GH_TOKEN. This will trigger your CI/CD pipeline to run again."
      );
      const url = `https://${ghToken}@github.com/${repositoryOwner}/${repositoryName}.git`;
      super.gitConfig(ghToken, url);
    }
  }
  get platformConfig() {
    const env = Z9.object({
      GITHUB_REPOSITORY: Z9.string(),
      GITHUB_REPOSITORY_OWNER: Z9.string(),
      GITHUB_REF_NAME: Z9.string(),
      GITHUB_HEAD_REF: Z9.string(),
      GH_TOKEN: Z9.string().optional()
    }).parse(process.env);
    const baseBranchName = !env.GITHUB_REF_NAME.endsWith("/merge") ? env.GITHUB_REF_NAME : env.GITHUB_HEAD_REF;
    return {
      ghToken: env.GH_TOKEN,
      baseBranchName,
      repositoryOwner: env.GITHUB_REPOSITORY_OWNER,
      repositoryName: env.GITHUB_REPOSITORY.split("/")[1]
    };
  }
  buildPullRequestUrl(pullRequestNumber) {
    const { repositoryOwner, repositoryName } = this.platformConfig;
    return `https://github.com/${repositoryOwner}/${repositoryName}/pull/${pullRequestNumber}`;
  }
};

// src/cli/cmd/ci/platforms/gitlab.ts
import { Gitlab } from "@gitbeaker/rest";
import Z10 from "zod";
var gl = new Gitlab({ token: "" });
var GitlabPlatformKit = class extends PlatformKit {
  _gitlab;
  constructor() {
    super();
    process.chdir(this.platformConfig.projectDir);
  }
  get gitlab() {
    if (!this._gitlab) {
      this._gitlab = new Gitlab({
        token: this.platformConfig.glToken || ""
      });
    }
    return this._gitlab;
  }
  get platformConfig() {
    const env = Z10.object({
      GL_TOKEN: Z10.string().optional(),
      CI_COMMIT_BRANCH: Z10.string(),
      CI_MERGE_REQUEST_SOURCE_BRANCH_NAME: Z10.string().optional(),
      CI_PROJECT_NAMESPACE: Z10.string(),
      CI_PROJECT_NAME: Z10.string(),
      CI_PROJECT_ID: Z10.string(),
      CI_PROJECT_DIR: Z10.string(),
      CI_REPOSITORY_URL: Z10.string()
    }).parse(process.env);
    const config = {
      glToken: env.GL_TOKEN,
      baseBranchName: env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME ?? env.CI_COMMIT_BRANCH,
      repositoryOwner: env.CI_PROJECT_NAMESPACE,
      repositoryName: env.CI_PROJECT_NAME,
      gitlabProjectId: env.CI_PROJECT_ID,
      projectDir: env.CI_PROJECT_DIR,
      reporitoryUrl: env.CI_REPOSITORY_URL
    };
    return config;
  }
  async branchExists({ branch }) {
    try {
      await this.gitlab.Branches.show(
        this.platformConfig.gitlabProjectId,
        branch
      );
      return true;
    } catch {
      return false;
    }
  }
  async getOpenPullRequestNumber({
    branch
  }) {
    const mergeRequests = await this.gitlab.MergeRequests.all({
      projectId: this.platformConfig.gitlabProjectId,
      sourceBranch: branch,
      state: "opened"
    });
    return mergeRequests[0]?.iid;
  }
  async closePullRequest({
    pullRequestNumber
  }) {
    await this.gitlab.MergeRequests.edit(
      this.platformConfig.gitlabProjectId,
      pullRequestNumber,
      {
        stateEvent: "close"
      }
    );
  }
  async createPullRequest({
    head,
    title,
    body
  }) {
    const mr = await this.gitlab.MergeRequests.create(
      this.platformConfig.gitlabProjectId,
      head,
      this.platformConfig.baseBranchName,
      title,
      {
        description: body
      }
    );
    return mr.iid;
  }
  async commentOnPullRequest({
    pullRequestNumber,
    body
  }) {
    await this.gitlab.MergeRequestNotes.create(
      this.platformConfig.gitlabProjectId,
      pullRequestNumber,
      body
    );
  }
  gitConfig() {
    const glToken = this.platformConfig.glToken;
    const url = `https://oauth2:${glToken}@gitlab.com/${this.platformConfig.repositoryOwner}/${this.platformConfig.repositoryName}.git`;
    super.gitConfig(glToken, url);
  }
  buildPullRequestUrl(pullRequestNumber) {
    return `https://gitlab.com/${this.platformConfig.repositoryOwner}/${this.platformConfig.repositoryName}/-/merge_requests/${pullRequestNumber}`;
  }
};

// src/cli/cmd/ci/platforms/index.ts
var getPlatformKit = () => {
  if (process.env.BITBUCKET_PIPELINE_UUID) {
    return new BitbucketPlatformKit();
  }
  if (process.env.GITHUB_ACTION) {
    return new GitHubPlatformKit();
  }
  if (process.env.GITLAB_CI) {
    return new GitlabPlatformKit();
  }
  throw new Error("This platform is not supported");
};

// src/cli/cmd/ci/index.ts
var ci_default = new Command19().command("ci").description("Run localization pipeline in CI/CD environment").helpOption("-h, --help", "Show help").option(
  "--parallel [boolean]",
  "Process translations concurrently for faster execution. Defaults to false",
  parseBooleanArg
).option(
  "--api-key <key>",
  "Override API key from settings or environment variables"
).option(
  "--pull-request [boolean]",
  "Create or update translations on a dedicated branch and manage pull requests automatically. When false, commits directly to current branch. Defaults to false",
  parseBooleanArg
).option(
  "--commit-message <message>",
  "Commit message for localization changes. Defaults to 'feat: update translations via @lingodotdev'"
).option(
  "--pull-request-title <title>",
  "Title for the pull request when using --pull-request mode. Defaults to 'feat: update translations via @lingodotdev'"
).option(
  "--commit-author-name <name>",
  "Git commit author name. Defaults to 'Lingo.dev'"
).option(
  "--commit-author-email <email>",
  "Git commit author email. Defaults to 'support@lingo.dev'"
).option(
  "--working-directory <dir>",
  "Directory to run localization from (useful for monorepos where localization files are in a subdirectory)"
).option(
  "--process-own-commits [boolean]",
  "Allow processing commits made by this CI user (bypasses infinite loop prevention)",
  parseBooleanArg
).action(async (options) => {
  const settings = getSettings(options.apiKey);
  console.log(options);
  if (!settings.auth.apiKey) {
    console.error("No API key provided");
    return;
  }
  const authenticator = createAuthenticator({
    apiUrl: settings.auth.apiUrl,
    apiKey: settings.auth.apiKey
  });
  const auth = await authenticator.whoami();
  if (!auth) {
    console.error("Not authenticated");
    return;
  }
  const env = {
    LINGODOTDEV_API_KEY: settings.auth.apiKey,
    LINGODOTDEV_PULL_REQUEST: options.pullRequest?.toString() || "false",
    ...options.commitMessage && {
      LINGODOTDEV_COMMIT_MESSAGE: options.commitMessage
    },
    ...options.pullRequestTitle && {
      LINGODOTDEV_PULL_REQUEST_TITLE: options.pullRequestTitle
    },
    ...options.commitAuthorName && {
      LINGODOTDEV_COMMIT_AUTHOR_NAME: options.commitAuthorName
    },
    ...options.commitAuthorEmail && {
      LINGODOTDEV_COMMIT_AUTHOR_EMAIL: options.commitAuthorEmail
    },
    ...options.workingDirectory && {
      LINGODOTDEV_WORKING_DIRECTORY: options.workingDirectory
    },
    ...options.processOwnCommits && {
      LINGODOTDEV_PROCESS_OWN_COMMITS: options.processOwnCommits.toString()
    }
  };
  process.env = { ...process.env, ...env };
  const ora = createOra();
  const platformKit = getPlatformKit();
  const { isPullRequestMode } = platformKit.config;
  ora.info(`Pull request mode: ${isPullRequestMode ? "on" : "off"}`);
  const flow = isPullRequestMode ? new PullRequestFlow(ora, platformKit) : new InBranchFlow(ora, platformKit);
  const canRun = await flow.preRun?.();
  if (canRun === false) {
    return;
  }
  const hasChanges = await flow.run({
    parallel: options.parallel
  });
  if (!hasChanges) {
    return;
  }
  await flow.postRun?.();
});
function parseBooleanArg(val) {
  if (val === true) return true;
  if (typeof val === "string") {
    return val.toLowerCase() === "true";
  }
  return false;
}

// src/cli/cmd/status.ts
import {
  bucketTypeSchema as bucketTypeSchema4,
  localeCodeSchema as localeCodeSchema3,
  resolveOverriddenLocale as resolveOverriddenLocale9
} from "@lingo.dev/_spec";
import { Command as Command20 } from "interactive-commander";
import Z11 from "zod";
import Ora12 from "ora";
import chalk15 from "chalk";
import Table from "cli-table3";

// src/cli/utils/exit-gracefully.ts
var STEP_WAIT_INTERVAL = 250;
var MAX_WAIT_INTERVAL = 2e3;
function exitGracefully(elapsedMs = 0) {
  const hasPendingOperations = checkForPendingOperations();
  if (hasPendingOperations && elapsedMs < MAX_WAIT_INTERVAL) {
    setTimeout(
      () => exitGracefully(elapsedMs + STEP_WAIT_INTERVAL),
      STEP_WAIT_INTERVAL
    );
  } else {
    process.exit(0);
  }
}
function checkForPendingOperations() {
  const activeHandles = process._getActiveHandles?.() || [];
  const activeRequests = process._getActiveRequests?.() || [];
  const nonStandardHandles = activeHandles.filter((handle) => {
    if (handle === process.stdin || handle === process.stdout || handle === process.stderr) {
      return false;
    }
    if (handle && typeof handle === "object" && "hasRef" in handle && !handle.hasRef()) {
      return false;
    }
    return true;
  });
  const hasFileWatchers = nonStandardHandles.some(
    (handle) => handle && typeof handle === "object" && "close" in handle
  );
  const hasPendingPromises = activeRequests.length > 0;
  return nonStandardHandles.length > 0 || hasFileWatchers || hasPendingPromises;
}

// src/cli/cmd/status.ts
var status_default = new Command20().command("status").description("Show the status of the localization process").helpOption("-h, --help", "Show help").option(
  "--locale <locale>",
  "Limit the report to specific target locales from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--bucket <bucket>",
  "Limit the report to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all buckets",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--file [files...]",
  "Filter the status report to only include files whose paths contain these substrings. Example: 'components' to match any file path containing 'components'"
).option(
  "--force",
  "Force all keys to be counted as needing translation, bypassing change detection. Shows word estimates for a complete retranslation regardless of current translation status"
).option(
  "--verbose",
  "Print detailed output showing missing and updated key counts with example key names for each file and locale"
).option(
  "--api-key <api-key>",
  "Override the API key from settings or environment variables for this run"
).action(async function(options) {
  const ora = Ora12();
  const flags = parseFlags2(options);
  let authId = null;
  try {
    ora.start("Loading configuration...");
    const i18nConfig = getConfig();
    const settings = getSettings(flags.apiKey);
    ora.succeed("Configuration loaded");
    try {
      ora.start("Checking authentication status...");
      const auth = await tryAuthenticate(settings);
      if (auth) {
        authId = auth.id;
        ora.succeed(`Authenticated as ${auth.email}`);
      } else {
        ora.info(
          "Not authenticated. Continuing without authentication. (Run `lingo.dev login` to authenticate)"
        );
      }
    } catch (error) {
      ora.info("Authentication failed. Continuing without authentication.");
    }
    ora.start("Validating localization configuration...");
    validateParams2(i18nConfig, flags);
    ora.succeed("Localization configuration is valid");
    trackEvent(authId || "status", "cmd.status.start", {
      i18nConfig,
      flags
    });
    let buckets = getBuckets(i18nConfig);
    if (flags.bucket?.length) {
      buckets = buckets.filter(
        (bucket) => flags.bucket.includes(bucket.type)
      );
    }
    ora.succeed("Buckets retrieved");
    if (flags.file?.length) {
      buckets = buckets.map((bucket) => {
        const paths = bucket.paths.filter(
          (path19) => flags.file.find(
            (file) => path19.pathPattern?.includes(file) || path19.pathPattern?.match(file) || minimatch(path19.pathPattern, file)
          )
        );
        return { ...bucket, paths };
      }).filter((bucket) => bucket.paths.length > 0);
      if (buckets.length === 0) {
        ora.fail(
          "No buckets found. All buckets were filtered out by --file option."
        );
        process.exit(1);
      } else {
        ora.info(`\x1B[36mProcessing only filtered buckets:\x1B[0m`);
        buckets.map((bucket) => {
          ora.info(`  ${bucket.type}:`);
          bucket.paths.forEach((path19) => {
            ora.info(`    - ${path19.pathPattern}`);
          });
        });
      }
    }
    const targetLocales = flags.locale?.length ? flags.locale : i18nConfig.locale.targets;
    let totalSourceKeyCount = 0;
    let uniqueKeysToTranslate = 0;
    let totalExistingTranslations = 0;
    const totalWordCount = /* @__PURE__ */ new Map();
    const languageStats = {};
    for (const locale of targetLocales) {
      languageStats[locale] = {
        complete: 0,
        missing: 0,
        updated: 0,
        words: 0
      };
      totalWordCount.set(locale, 0);
    }
    const fileStats = {};
    for (const bucket of buckets) {
      try {
        console.log();
        ora.info(`Analyzing bucket: ${bucket.type}`);
        for (const bucketPath of bucket.paths) {
          const bucketOra = Ora12({ indent: 2 }).info(
            `Analyzing path: ${bucketPath.pathPattern}`
          );
          const sourceLocale = resolveOverriddenLocale9(
            i18nConfig.locale.source,
            bucketPath.delimiter
          );
          const bucketLoader = createBucketLoader(
            bucket.type,
            bucketPath.pathPattern,
            {
              defaultLocale: sourceLocale,
              injectLocale: bucket.injectLocale,
              formatter: i18nConfig.formatter
            },
            bucket.lockedKeys,
            bucket.lockedPatterns,
            bucket.ignoredKeys
          );
          bucketLoader.setDefaultLocale(sourceLocale);
          await bucketLoader.init();
          const filePath = bucketPath.pathPattern;
          if (!fileStats[filePath]) {
            fileStats[filePath] = {
              path: filePath,
              sourceKeys: 0,
              wordCount: 0,
              languageStats: {}
            };
            for (const locale of targetLocales) {
              fileStats[filePath].languageStats[locale] = {
                complete: 0,
                missing: 0,
                updated: 0,
                words: 0
              };
            }
          }
          const sourceData = await bucketLoader.pull(sourceLocale);
          const sourceKeys = Object.keys(sourceData);
          fileStats[filePath].sourceKeys = sourceKeys.length;
          totalSourceKeyCount += sourceKeys.length;
          let sourceWordCount = 0;
          for (const key of sourceKeys) {
            const value = sourceData[key];
            if (typeof value === "string") {
              const words = value.trim().split(/\s+/).length;
              sourceWordCount += words;
            }
          }
          fileStats[filePath].wordCount = sourceWordCount;
          for (const _targetLocale of targetLocales) {
            const targetLocale = resolveOverriddenLocale9(
              _targetLocale,
              bucketPath.delimiter
            );
            bucketOra.start(
              `[${sourceLocale} -> ${targetLocale}] Analyzing translation status...`
            );
            let targetData = {};
            let fileExists = true;
            try {
              targetData = await bucketLoader.pull(targetLocale);
            } catch (error) {
              fileExists = false;
              bucketOra.info(
                `[${sourceLocale} -> ${targetLocale}] Target file not found, assuming all keys need translation.`
              );
            }
            if (!fileExists) {
              fileStats[filePath].languageStats[_targetLocale].missing = sourceKeys.length;
              fileStats[filePath].languageStats[_targetLocale].words = sourceWordCount;
              languageStats[_targetLocale].missing += sourceKeys.length;
              languageStats[_targetLocale].words += sourceWordCount;
              totalWordCount.set(
                _targetLocale,
                (totalWordCount.get(_targetLocale) || 0) + sourceWordCount
              );
              bucketOra.succeed(
                `[${sourceLocale} -> ${targetLocale}] ${chalk15.red(
                  `0% complete`
                )} (0/${sourceKeys.length} keys) - file not found`
              );
              continue;
            }
            const deltaProcessor = createDeltaProcessor(
              bucketPath.pathPattern
            );
            const checksums = await deltaProcessor.loadChecksums();
            const delta = await deltaProcessor.calculateDelta({
              sourceData,
              targetData,
              checksums
            });
            const missingKeys = delta.added;
            const updatedKeys = delta.updated;
            const completeKeys = sourceKeys.filter(
              (key) => !missingKeys.includes(key) && !updatedKeys.includes(key)
            );
            let wordsToTranslate = 0;
            const keysToProcess = flags.force ? sourceKeys : [...missingKeys, ...updatedKeys];
            for (const key of keysToProcess) {
              const value = sourceData[String(key)];
              if (typeof value === "string") {
                const words = value.trim().split(/\s+/).length;
                wordsToTranslate += words;
              }
            }
            fileStats[filePath].languageStats[_targetLocale].missing = missingKeys.length;
            fileStats[filePath].languageStats[_targetLocale].updated = updatedKeys.length;
            fileStats[filePath].languageStats[_targetLocale].complete = completeKeys.length;
            fileStats[filePath].languageStats[_targetLocale].words = wordsToTranslate;
            languageStats[_targetLocale].missing += missingKeys.length;
            languageStats[_targetLocale].updated += updatedKeys.length;
            languageStats[_targetLocale].complete += completeKeys.length;
            languageStats[_targetLocale].words += wordsToTranslate;
            totalWordCount.set(
              _targetLocale,
              (totalWordCount.get(_targetLocale) || 0) + wordsToTranslate
            );
            const totalKeysInFile = sourceKeys.length;
            const completionPercent = (completeKeys.length / totalKeysInFile * 100).toFixed(1);
            if (missingKeys.length === 0 && updatedKeys.length === 0) {
              bucketOra.succeed(
                `[${sourceLocale} -> ${targetLocale}] ${chalk15.green(
                  `100% complete`
                )} (${completeKeys.length}/${totalKeysInFile} keys)`
              );
            } else {
              const message = `[${sourceLocale} -> ${targetLocale}] ${parseFloat(completionPercent) > 50 ? chalk15.yellow(`${completionPercent}% complete`) : chalk15.red(`${completionPercent}% complete`)} (${completeKeys.length}/${totalKeysInFile} keys)`;
              bucketOra.succeed(message);
              if (flags.verbose) {
                if (missingKeys.length > 0) {
                  console.log(
                    `    ${chalk15.red(`Missing:`)} ${missingKeys.length} keys, ~${wordsToTranslate} words`
                  );
                  console.log(
                    `    ${chalk15.red(`Missing:`)} ${missingKeys.length} keys, ~${wordsToTranslate} words`
                  );
                  console.log(
                    `    ${chalk15.dim(
                      `Example missing: ${missingKeys.slice(0, 2).join(", ")}${missingKeys.length > 2 ? "..." : ""}`
                    )}`
                  );
                }
                if (updatedKeys.length > 0) {
                  console.log(
                    `    ${chalk15.yellow(`Updated:`)} ${updatedKeys.length} keys that changed in source`
                  );
                }
              }
            }
          }
        }
      } catch (error) {
        ora.fail(`Failed to analyze bucket ${bucket.type}: ${error.message}`);
      }
    }
    const totalKeysNeedingTranslation = Object.values(languageStats).reduce(
      (sum, stats) => {
        return sum + stats.missing + stats.updated;
      },
      0
    );
    const totalCompletedKeys = totalSourceKeyCount - totalKeysNeedingTranslation / targetLocales.length;
    console.log();
    ora.succeed(chalk15.green(`Localization status completed.`));
    console.log(chalk15.bold.cyan(`
\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557`));
    console.log(chalk15.bold.cyan(`\u2551   LOCALIZATION STATUS REPORT       \u2551`));
    console.log(chalk15.bold.cyan(`\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D`));
    console.log(chalk15.bold(`
\u{1F4DD} SOURCE CONTENT:`));
    console.log(
      `\u2022 Source language: ${chalk15.green(i18nConfig.locale.source)}`
    );
    console.log(
      `\u2022 Source keys: ${chalk15.yellow(
        totalSourceKeyCount.toString()
      )} keys across all files`
    );
    console.log(chalk15.bold(`
\u{1F310} LANGUAGE BY LANGUAGE BREAKDOWN:`));
    const table = new Table({
      head: [
        "Language",
        "Status",
        "Complete",
        "Missing",
        "Updated",
        "Total Keys",
        "Words to Translate"
      ],
      style: {
        head: ["white"],
        // White color for headers
        border: []
        // No color for borders
      },
      colWidths: [12, 20, 18, 12, 12, 12, 15]
      // Explicit column widths, making Status column wider
    });
    let totalWordsToTranslate = 0;
    for (const locale of targetLocales) {
      const stats = languageStats[locale];
      const percentComplete = (stats.complete / totalSourceKeyCount * 100).toFixed(1);
      const totalNeeded = stats.missing + stats.updated;
      let statusText;
      let statusColor;
      if (stats.missing === totalSourceKeyCount) {
        statusText = "\u{1F534} Not started";
        statusColor = chalk15.red;
      } else if (stats.missing === 0 && stats.updated === 0) {
        statusText = "\u2705 Complete";
        statusColor = chalk15.green;
      } else if (parseFloat(percentComplete) > 80) {
        statusText = "\u{1F7E1} Almost done";
        statusColor = chalk15.yellow;
      } else if (parseFloat(percentComplete) > 0) {
        statusText = "\u{1F7E0} In progress";
        statusColor = chalk15.yellow;
      } else {
        statusText = "\u{1F534} Not started";
        statusColor = chalk15.red;
      }
      const words = totalWordCount.get(locale) || 0;
      totalWordsToTranslate += words;
      table.push([
        locale,
        statusColor(statusText),
        `${stats.complete}/${totalSourceKeyCount} (${percentComplete}%)`,
        stats.missing > 0 ? chalk15.red(stats.missing.toString()) : "0",
        stats.updated > 0 ? chalk15.yellow(stats.updated.toString()) : "0",
        totalNeeded > 0 ? chalk15.magenta(totalNeeded.toString()) : "0",
        words > 0 ? `~${words.toLocaleString()}` : "0"
      ]);
    }
    console.log(table.toString());
    console.log(chalk15.bold(`
\u{1F4CA} USAGE ESTIMATE:`));
    console.log(
      `\u2022 WORDS TO BE CONSUMED: ~${chalk15.yellow.bold(
        totalWordsToTranslate.toLocaleString()
      )} words across all languages`
    );
    console.log(
      `  (Words are counted from source language for keys that need translation in target languages)`
    );
    if (targetLocales.length > 1) {
      console.log(`\u2022 Per-language breakdown:`);
      for (const locale of targetLocales) {
        const words = totalWordCount.get(locale) || 0;
        const percent = (words / totalWordsToTranslate * 100).toFixed(1);
        console.log(
          `  - ${locale}: ~${words.toLocaleString()} words (${percent}% of total)`
        );
      }
    }
    if (flags.confirm && Object.keys(fileStats).length > 0) {
      console.log(chalk15.bold(`
\u{1F4D1} BREAKDOWN BY FILE:`));
      Object.entries(fileStats).sort((a, b) => b[1].wordCount - a[1].wordCount).forEach(([path19, stats]) => {
        if (stats.sourceKeys === 0) return;
        console.log(chalk15.bold(`
\u2022 ${path19}:`));
        console.log(
          `  ${stats.sourceKeys} source keys, ~${stats.wordCount.toLocaleString()} source words`
        );
        const fileTable = new Table({
          head: ["Language", "Status", "Details"],
          style: {
            head: ["white"],
            border: []
          },
          colWidths: [12, 20, 50]
          // Explicit column widths for file detail table
        });
        for (const locale of targetLocales) {
          const langStats = stats.languageStats[locale];
          const complete = langStats.complete;
          const total = stats.sourceKeys;
          const completion = (complete / total * 100).toFixed(1);
          let status = "\u2705 Complete";
          let statusColor = chalk15.green;
          if (langStats.missing === total) {
            status = "\u274C Not started";
            statusColor = chalk15.red;
          } else if (langStats.missing > 0 || langStats.updated > 0) {
            status = `\u26A0\uFE0F ${completion}% complete`;
            statusColor = chalk15.yellow;
          }
          let details = "";
          if (langStats.missing > 0 || langStats.updated > 0) {
            const parts = [];
            if (langStats.missing > 0)
              parts.push(`${langStats.missing} missing`);
            if (langStats.updated > 0)
              parts.push(`${langStats.updated} changed`);
            details = `${parts.join(", ")}, ~${langStats.words} words`;
          } else {
            details = "All keys translated";
          }
          fileTable.push([locale, statusColor(status), details]);
        }
        console.log(fileTable.toString());
      });
    }
    const completeLanguages = targetLocales.filter(
      (locale) => languageStats[locale].missing === 0 && languageStats[locale].updated === 0
    );
    const missingLanguages = targetLocales.filter(
      (locale) => languageStats[locale].complete === 0
    );
    console.log(chalk15.bold.green(`
\u{1F4A1} OPTIMIZATION TIPS:`));
    if (missingLanguages.length > 0) {
      console.log(
        `\u2022 ${chalk15.yellow(missingLanguages.join(", "))} ${missingLanguages.length === 1 ? "has" : "have"} no translations yet`
      );
    }
    if (completeLanguages.length > 0) {
      console.log(
        `\u2022 ${chalk15.green(completeLanguages.join(", "))} ${completeLanguages.length === 1 ? "is" : "are"} completely translated`
      );
    }
    if (targetLocales.length > 1) {
      console.log(`\u2022 Translating one language at a time reduces complexity`);
      console.log(
        `\u2022 Try 'lingo.dev@latest i18n --locale ${targetLocales[0]}' to process just one language`
      );
    }
    trackEvent(authId || "status", "cmd.status.success", {
      i18nConfig,
      flags,
      totalSourceKeyCount,
      languageStats,
      totalWordsToTranslate,
      authenticated: !!authId
    });
    exitGracefully();
  } catch (error) {
    ora.fail(error.message);
    trackEvent(authId || "status", "cmd.status.error", {
      flags,
      error: error.message,
      authenticated: !!authId
    });
    process.exit(1);
  }
});
function parseFlags2(options) {
  return Z11.object({
    locale: Z11.array(localeCodeSchema3).optional(),
    bucket: Z11.array(bucketTypeSchema4).optional(),
    force: Z11.boolean().optional(),
    confirm: Z11.boolean().optional(),
    verbose: Z11.boolean().optional(),
    file: Z11.array(Z11.string()).optional(),
    apiKey: Z11.string().optional()
  }).parse(options);
}
async function tryAuthenticate(settings) {
  if (!settings.auth.apiKey) {
    return null;
  }
  try {
    const authenticator = createAuthenticator({
      apiKey: settings.auth.apiKey,
      apiUrl: settings.auth.apiUrl
    });
    const user = await authenticator.whoami();
    return user;
  } catch (error) {
    return null;
  }
}
function validateParams2(i18nConfig, flags) {
  if (!i18nConfig) {
    throw new CLIError({
      message: "i18n.json not found. Please run `lingo.dev init` to initialize the project.",
      docUrl: "i18nNotFound"
    });
  } else if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {
    throw new CLIError({
      message: "No buckets found in i18n.json. Please add at least one bucket containing i18n content.",
      docUrl: "bucketNotFound"
    });
  } else if (flags.locale?.some((locale) => !i18nConfig.locale.targets.includes(locale))) {
    throw new CLIError({
      message: `One or more specified locales do not exist in i18n.json locale.targets. Please add them to the list and try again.`,
      docUrl: "localeTargetNotFound"
    });
  } else if (flags.bucket?.some(
    (bucket) => !i18nConfig.buckets[bucket]
  )) {
    throw new CLIError({
      message: `One or more specified buckets do not exist in i18n.json. Please add them to the list and try again.`,
      docUrl: "bucketNotFound"
    });
  }
}

// src/cli/cmd/may-the-fourth.ts
import { Command as Command21 } from "interactive-commander";
import * as cp from "node:child_process";
import figlet2 from "figlet";
import chalk16 from "chalk";
import { vice as vice2 } from "gradient-string";
var colors2 = {
  orange: "#ff6600",
  green: "#6ae300",
  blue: "#0090ff",
  yellow: "#ffcc00",
  grey: "#808080",
  red: "#ff0000"
};
var may_the_fourth_default = new Command21().command("may-the-fourth").description("May the Fourth be with you").helpOption("-h, --help", "Show help").action(async () => {
  await renderClear2();
  await renderBanner2();
  await renderSpacer2();
  console.log(chalk16.hex(colors2.yellow)("Loading the Star Wars movie..."));
  await renderSpacer2();
  await new Promise((resolve, reject) => {
    const ssh = cp.spawn("ssh", ["starwarstel.net"], {
      stdio: "inherit"
    });
    ssh.on("close", (code) => {
      if (code !== 0) {
        console.error(`SSH process exited with code ${code}`);
      }
      resolve();
    });
    ssh.on("error", (err) => {
      console.error("Failed to start SSH process:", err);
      reject(err);
    });
  });
  await renderSpacer2();
  console.log(
    `${chalk16.hex(colors2.green)("We hope you enjoyed it! :)")} ${chalk16.hex(
      colors2.blue
    )("May the Fourth be with you! \u{1F680}")}`
  );
  await renderSpacer2();
  console.log(chalk16.dim(`---`));
  await renderSpacer2();
  await renderHero2();
});
async function renderClear2() {
  console.log("\x1Bc");
}
async function renderSpacer2() {
  console.log(" ");
}
async function renderBanner2() {
  console.log(
    vice2(
      figlet2.textSync("LINGO.DEV", {
        font: "ANSI Shadow",
        horizontalLayout: "default",
        verticalLayout: "default"
      })
    )
  );
}
async function renderHero2() {
  console.log(
    `\u26A1\uFE0F ${chalk16.hex(colors2.green)(
      "Lingo.dev"
    )} - open-source, AI-powered i18n CLI for web & mobile localization.`
  );
  console.log(" ");
  console.log(chalk16.hex(colors2.blue)("\u{1F4DA} Docs: https://lingo.dev/go/docs"));
  console.log(
    chalk16.hex(colors2.blue)("\u2B50 Star the repo: https://lingo.dev/go/gh")
  );
  console.log(
    chalk16.hex(colors2.blue)("\u{1F3AE} Join Discord: https://lingo.dev/go/discord")
  );
}

// package.json
var package_default = {
  name: "lingo.dev",
  version: "0.115.0",
  description: "Lingo.dev CLI",
  private: false,
  publishConfig: {
    access: "public"
  },
  type: "module",
  sideEffects: false,
  exports: {
    "./cli": {
      types: "./build/cli.d.ts",
      import: "./build/cli.mjs",
      require: "./build/cli.cjs"
    },
    "./sdk": {
      types: "./build/sdk.d.ts",
      import: "./build/sdk.mjs",
      require: "./build/sdk.cjs"
    },
    "./spec": {
      types: "./build/spec.d.ts",
      import: "./build/spec.mjs",
      require: "./build/spec.cjs"
    },
    "./compiler": {
      types: "./build/compiler.d.ts",
      import: "./build/compiler.mjs",
      require: "./build/compiler.cjs"
    },
    "./react": {
      types: "./build/react.d.ts",
      import: "./build/react.mjs",
      require: "./build/react.cjs"
    },
    "./react-client": {
      types: "./build/react/client.d.ts",
      import: "./build/react/client.mjs",
      require: "./build/react/client.cjs"
    },
    "./react/client": {
      types: "./build/react/client.d.ts",
      import: "./build/react/client.mjs",
      require: "./build/react/client.cjs"
    },
    "./react-rsc": {
      types: "./build/react/rsc.d.ts",
      import: "./build/react/rsc.mjs",
      require: "./build/react/rsc.cjs"
    },
    "./react/rsc": {
      types: "./build/react/rsc.d.ts",
      import: "./build/react/rsc.mjs",
      require: "./build/react/rsc.cjs"
    },
    "./react-router": {
      types: "./build/react/react-router.d.ts",
      import: "./build/react/react-router.mjs",
      require: "./build/react/react-router.cjs"
    },
    "./react/react-router": {
      types: "./build/react/react-router.d.ts",
      import: "./build/react/react-router.mjs",
      require: "./build/react/react-router.cjs"
    },
    "./locale-codes": {
      types: "./build/locale-codes.d.ts",
      import: "./build/locale-codes.mjs",
      require: "./build/locale-codes.cjs"
    }
  },
  typesVersions: {
    "*": {
      sdk: [
        "./build/sdk.d.ts"
      ],
      cli: [
        "./build/cli.d.ts"
      ],
      spec: [
        "./build/spec.d.ts"
      ],
      compiler: [
        "./build/compiler.d.ts"
      ],
      react: [
        "./build/react.d.ts"
      ],
      "react/client": [
        "./build/react/client.d.ts"
      ],
      "react/rsc": [
        "./build/react/rsc.d.ts"
      ],
      "react/react-router": [
        "./build/react/react-router.d.ts"
      ],
      "locale-codes": [
        "./build/locale-codes.d.ts"
      ]
    }
  },
  bin: {
    "lingo.dev": "./bin/cli.mjs"
  },
  files: [
    "bin",
    "build",
    "assets"
  ],
  scripts: {
    "lingo.dev": "node --inspect=9229 ./bin/cli.mjs",
    dev: "tsup --watch",
    build: "pnpm typecheck && tsup",
    typecheck: "tsc --noEmit",
    test: "vitest run",
    "test:watch": "vitest",
    clean: "rm -rf build"
  },
  keywords: [],
  author: "",
  license: "Apache-2.0",
  dependencies: {
    "@ai-sdk/anthropic": "^1.2.11",
    "@ai-sdk/google": "^1.2.19",
    "@ai-sdk/mistral": "^1.2.8",
    "@ai-sdk/openai": "^1.3.22",
    "@babel/generator": "^7.27.1",
    "@babel/parser": "^7.27.1",
    "@babel/traverse": "^7.27.4",
    "@babel/types": "^7.27.1",
    "@biomejs/js-api": "^3.0.0",
    "@biomejs/wasm-nodejs": "^2.2.4",
    "@datocms/cma-client-node": "^4.0.1",
    "@gitbeaker/rest": "^39.34.3",
    "@inkjs/ui": "^2.0.0",
    "@inquirer/prompts": "^7.8.0",
    "@lingo.dev/_compiler": "workspace:*",
    "@lingo.dev/_locales": "workspace:*",
    "@lingo.dev/_react": "workspace:*",
    "@lingo.dev/_sdk": "workspace:*",
    "@lingo.dev/_spec": "workspace:*",
    "@markdoc/markdoc": "^0.5.4",
    "@modelcontextprotocol/sdk": "^1.5.0",
    "@openrouter/ai-sdk-provider": "^0.7.1",
    "@paralleldrive/cuid2": "^2.2.2",
    "@types/ejs": "^3.1.5",
    ai: "^4.3.15",
    bitbucket: "^2.12.0",
    chalk: "^5.4.1",
    chokidar: "^4.0.3",
    "cli-progress": "^3.12.0",
    "cli-table3": "^0.6.5",
    cors: "^2.8.5",
    "csv-parse": "^5.6.0",
    "csv-stringify": "^6.5.2",
    "date-fns": "^4.1.0",
    dedent: "^1.5.3",
    diff: "^7.0.0",
    dotenv: "^16.4.7",
    ejs: "^3.1.10",
    express: "^5.1.0",
    "external-editor": "^3.1.0",
    figlet: "^1.8.2",
    flat: "^6.0.1",
    "gettext-parser": "^8.0.0",
    glob: "<11.0.0",
    "gradient-string": "^3.0.0",
    "gray-matter": "^4.0.3",
    ini: "^5.0.0",
    ink: "^4.2.0",
    "ink-progress-bar": "^3.0.0",
    "ink-spinner": "^5.0.0",
    inquirer: "^12.6.0",
    "interactive-commander": "^0.5.194",
    "is-url": "^1.2.4",
    jsdom: "^25.0.1",
    json5: "^2.2.3",
    "jsonc-parser": "^3.3.1",
    jsonrepair: "^3.11.2",
    listr2: "^8.3.2",
    lodash: "^4.17.21",
    marked: "^15.0.6",
    "mdast-util-from-markdown": "^2.0.2",
    "mdast-util-gfm": "^3.1.0",
    "micromark-extension-gfm": "^3.0.0",
    "node-machine-id": "^1.1.12",
    "node-webvtt": "^1.9.4",
    "object-hash": "^3.0.0",
    octokit: "^4.0.2",
    "ollama-ai-provider": "^1.2.0",
    open: "^10.2.0",
    ora: "^8.1.1",
    "p-limit": "^6.2.0",
    "php-array-reader": "^2.1.2",
    plist: "^3.1.0",
    "posthog-node": "^5.8.1",
    prettier: "^3.4.2",
    react: "^18.3.1",
    "rehype-stringify": "^10.0.1",
    "remark-disable-tokenizers": "^1.1.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    "remark-mdx": "^3.1.0",
    "remark-mdx-frontmatter": "^5.1.0",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "remark-stringify": "^11.0.0",
    sax: "^1.4.1",
    "srt-parser-2": "^1.2.3",
    unified: "^11.0.5",
    "unist-util-visit": "^5.0.0",
    vfile: "^6.0.3",
    xliff: "^6.2.1",
    xml2js: "^0.6.2",
    xpath: "^0.0.34",
    yaml: "^2.7.0",
    zod: "^3.25.76"
  },
  devDependencies: {
    "@types/babel__generator": "^7.27.0",
    "@types/chokidar": "^2.1.7",
    "@types/cli-progress": "^3.11.6",
    "@types/cors": "^2.8.17",
    "@types/diff": "^7.0.0",
    "@types/express": "^5.0.3",
    "@types/figlet": "^1.7.0",
    "@types/gettext-parser": "^4.0.4",
    "@types/glob": "^8.1.0",
    "@types/ini": "^4.1.1",
    "@types/is-url": "^1.2.32",
    "@types/jsdom": "^21.1.7",
    "@types/lodash": "^4.17.16",
    "@types/mdast": "^4.0.4",
    "@types/node": "^22.10.2",
    "@types/node-gettext": "^3.0.6",
    "@types/object-hash": "^3.0.6",
    "@types/plist": "^3.0.5",
    "@types/react": "^18.3.20",
    "@types/xml2js": "^0.4.14",
    tsup: "^8.3.5",
    typescript: "^5.8.3",
    vitest: "^3.1.2"
  },
  engines: {
    node: ">=18"
  },
  packageManager: "pnpm@9.12.3"
};

// src/cli/cmd/purge.ts
import { Command as Command22 } from "interactive-commander";
import Ora13 from "ora";
import { resolveOverriddenLocale as resolveOverriddenLocale10 } from "@lingo.dev/_spec";
import { confirm as confirm3 } from "@inquirer/prompts";
var purge_default = new Command22().command("purge").description(
  "WARNING: Permanently delete translation entries from bucket path patterns defined in i18n.json. This is a destructive operation that cannot be undone. Without any filters, ALL managed keys will be removed from EVERY target locale."
).helpOption("-h, --help", "Show help").option(
  "--bucket <bucket>",
  "Limit the purge to specific bucket types defined under `buckets` in i18n.json. Repeat the flag to include multiple bucket types. Defaults to all buckets",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--file [files...]",
  "Filter which file paths to purge by matching against path patterns. Only paths containing any of these values will be processed. Examples: --file messages.json --file admin/"
).option(
  "--key <key>",
  "Filter which keys to delete using prefix matching on dot-separated key paths. Example: 'auth.login' matches all keys starting with auth.login. Omit this option to delete ALL keys. Keys marked as locked or ignored in i18n.json are automatically skipped",
  (val) => encodeURIComponent(val)
).option(
  "--locale <locale>",
  "Limit purging to specific target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales. Warning: Including the source locale will delete content from it as well.",
  (val, prev) => prev ? [...prev, val] : [val]
).option(
  "--yes-really",
  "Bypass safety confirmations for destructive operations. Use with extreme caution - this will delete translation keys without asking for confirmation. Intended for automated scripts and CI environments only."
).action(async function(options) {
  const ora = Ora13();
  try {
    ora.start("Loading configuration...");
    const i18nConfig = getConfig();
    if (!i18nConfig) {
      throw new Error("i18n.json not found. Please run `lingo.dev init`.");
    }
    ora.succeed("Configuration loaded");
    let buckets = getBuckets(i18nConfig);
    if (options.bucket && options.bucket.length) {
      buckets = buckets.filter(
        (bucket) => options.bucket.includes(bucket.type)
      );
    }
    if (options.file && options.file.length) {
      buckets = buckets.map((bucket) => {
        const paths = bucket.paths.filter(
          (bucketPath) => options.file?.some((f) => bucketPath.pathPattern.includes(f))
        );
        return { ...bucket, paths };
      }).filter((bucket) => bucket.paths.length > 0);
      if (buckets.length === 0) {
        ora.fail("All files were filtered out by --file option.");
        process.exit(1);
      }
    }
    const sourceLocale = i18nConfig.locale.source;
    const targetLocales = options.locale && options.locale.length ? options.locale : i18nConfig.locale.targets;
    let removedAny = false;
    for (const bucket of buckets) {
      console.log();
      ora.info(`Processing bucket: ${bucket.type}`);
      for (const bucketPath of bucket.paths) {
        for (const _targetLocale of targetLocales) {
          const targetLocale = resolveOverriddenLocale10(
            _targetLocale,
            bucketPath.delimiter
          );
          const bucketOra = Ora13({ indent: 2 }).start(
            `Processing path: ${bucketPath.pathPattern} [${targetLocale}]`
          );
          try {
            const bucketLoader = createBucketLoader(
              bucket.type,
              bucketPath.pathPattern,
              {
                defaultLocale: sourceLocale,
                injectLocale: bucket.injectLocale,
                formatter: i18nConfig.formatter
              },
              bucket.lockedKeys,
              bucket.lockedPatterns,
              bucket.ignoredKeys
            );
            await bucketLoader.init();
            bucketLoader.setDefaultLocale(sourceLocale);
            await bucketLoader.pull(sourceLocale);
            let targetData = await bucketLoader.pull(targetLocale);
            if (!targetData || Object.keys(targetData).length === 0) {
              bucketOra.info(
                `No translations found for ${bucketPath.pathPattern} [${targetLocale}]`
              );
              continue;
            }
            let newData = { ...targetData };
            let keysToRemove = [];
            if (options.key) {
              keysToRemove = Object.keys(newData).filter(
                (k) => minimatch(k, options.key)
              );
            } else {
              keysToRemove = Object.keys(newData);
            }
            if (keysToRemove.length > 0) {
              if (options.key) {
                bucketOra.info(
                  `About to delete ${keysToRemove.length} key(s) matching '${options.key}' from ${bucketPath.pathPattern} [${targetLocale}]:
  ${keysToRemove.slice(0, 10).join(", ")}${keysToRemove.length > 10 ? ", ..." : ""}`
                );
              } else {
                bucketOra.info(
                  `About to delete all (${keysToRemove.length}) keys from ${bucketPath.pathPattern} [${targetLocale}]`
                );
              }
              if (!options.yesReally) {
                bucketOra.warn(
                  "This is a destructive operation. If you are sure, type 'y' to continue. (Use --yes-really to skip this check.)"
                );
                const confirmed = await confirm3({
                  message: `Delete these keys from ${bucketPath.pathPattern} [${targetLocale}]?`,
                  default: false
                });
                if (!confirmed) {
                  bucketOra.info("Skipped by user.");
                  continue;
                }
              }
              for (const key of keysToRemove) {
                delete newData[key];
              }
              removedAny = true;
              await bucketLoader.push(targetLocale, newData);
              if (options.key) {
                bucketOra.succeed(
                  `Removed ${keysToRemove.length} key(s) matching '${options.key}' from ${bucketPath.pathPattern} [${targetLocale}]`
                );
              } else {
                bucketOra.succeed(
                  `Removed all keys (${keysToRemove.length}) from ${bucketPath.pathPattern} [${targetLocale}]`
                );
              }
            } else if (options.key) {
              bucketOra.info(
                `No keys matching '${options.key}' found in ${bucketPath.pathPattern} [${targetLocale}]`
              );
            } else {
              bucketOra.info("No keys to remove.");
            }
          } catch (error) {
            const err = error;
            bucketOra.fail(`Failed: ${err.message}`);
          }
        }
      }
    }
    if (!removedAny) {
      ora.info("No keys were removed.");
    } else {
      ora.succeed("Purge completed.");
    }
  } catch (error) {
    const err = error;
    ora.fail(err.message);
    process.exit(1);
  }
});

// src/cli/index.ts
dotenv.config();
var cli_default = new InteractiveCommand2().name("lingo.dev").description("Lingo.dev CLI").helpOption("-h, --help", "Show help").addHelpText(
  "beforeAll",
  `
${vice3(
    figlet3.textSync("LINGO.DEV", {
      font: "ANSI Shadow",
      horizontalLayout: "default",
      verticalLayout: "default"
    })
  )}

\u26A1\uFE0F AI-powered open-source CLI for web & mobile localization.

Star the the repo :) https://github.com/LingoDotDev/lingo.dev
`
).version(`v${package_default.version}`, "-v, --version", "Show version").addCommand(init_default).interactive(
  "-y, --no-interactive",
  "Run every command in non-interactive mode (no prompts); required when scripting"
).addCommand(i18n_default).addCommand(auth_default).addCommand(login_default).addCommand(logout_default).addCommand(show_default).addCommand(config_default2).addCommand(lockfile_default).addCommand(cleanup_default).addCommand(mcp_default).addCommand(ci_default).addCommand(status_default).addCommand(may_the_fourth_default, { hidden: true }).addCommand(run_default).addCommand(purge_default).exitOverride((err) => {
  if (err.code === "commander.helpDisplayed" || err.code === "commander.version" || err.code === "commander.help") {
    process.exit(0);
  }
  process.exit(1);
});
export {
  cli_default as default
};
//# sourceMappingURL=cli.mjs.map