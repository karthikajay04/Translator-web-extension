{"version":3,"sources":["../src/cli/index.ts","../src/cli/cmd/auth.ts","../src/cli/utils/settings.ts","../src/cli/utils/errors.ts","../src/cli/utils/cloudflare-status.ts","../src/cli/utils/auth.ts","../src/cli/cmd/login.ts","../src/cli/utils/ui.ts","../src/cli/constants.ts","../src/cli/cmd/logout.ts","../src/cli/cmd/init.ts","../src/cli/utils/config.ts","../src/cli/utils/find-locale-paths.ts","../src/cli/utils/ensure-patterns.ts","../src/cli/utils/update-gitignore.ts","../src/cli/utils/init-ci-cd.ts","../src/cli/cmd/show/index.ts","../src/cli/cmd/show/config.ts","../src/cli/cmd/show/locale.ts","../src/cli/cmd/show/files.ts","../src/cli/utils/buckets.ts","../src/cli/cmd/show/locked-keys.ts","../src/cli/cmd/show/_shared-key-command.ts","../src/cli/loaders/_utils.ts","../src/cli/loaders/json.ts","../src/cli/loaders/json5.ts","../src/cli/loaders/jsonc.ts","../src/cli/loaders/flat.ts","../src/cli/loaders/text-file.ts","../src/cli/loaders/yaml.ts","../src/cli/loaders/root-key.ts","../src/cli/loaders/flutter.ts","../src/cli/loaders/android.ts","../src/cli/loaders/csv.ts","../src/cli/loaders/html.ts","../src/cli/loaders/markdown.ts","../src/cli/loaders/markdoc.ts","../src/cli/loaders/properties.ts","../src/cli/loaders/xcode-strings/tokenizer.ts","../src/cli/loaders/xcode-strings/escape.ts","../src/cli/loaders/xcode-strings/parser.ts","../src/cli/loaders/xcode-strings.ts","../src/cli/loaders/xcode-stringsdict.ts","../src/cli/loaders/xcode-xcstrings.ts","../src/cli/loaders/xcode-xcstrings-icu.ts","../src/cli/loaders/xcode-xcstrings-v2-loader.ts","../src/cli/loaders/unlocalizable.ts","../src/cli/loaders/formatters/prettier.ts","../src/cli/loaders/formatters/_base.ts","../src/cli/loaders/formatters/biome.ts","../src/cli/loaders/formatters/index.ts","../src/cli/loaders/po/index.ts","../src/cli/loaders/xliff.ts","../src/cli/loaders/xml.ts","../src/cli/loaders/srt.ts","../src/cli/loaders/dato/index.ts","../src/cli/loaders/dato/_base.ts","../src/cli/loaders/dato/filter.ts","../src/cli/loaders/dato/api.ts","../src/cli/loaders/dato/_utils.ts","../src/cli/loaders/dato/extract.ts","../src/cli/loaders/vtt.ts","../src/cli/loaders/variable/index.ts","../src/cli/loaders/sync.ts","../src/cli/utils/plutil-formatter.ts","../src/cli/loaders/plutil-json-loader.ts","../src/cli/loaders/php.ts","../src/cli/loaders/vue-json.ts","../src/cli/loaders/typescript/index.ts","../src/cli/loaders/typescript/cjs-interop.ts","../src/cli/loaders/inject-locale.ts","../../../node_modules/.pnpm/@isaacs+balanced-match@4.0.1/node_modules/@isaacs/balanced-match/src/index.ts","../../../node_modules/.pnpm/@isaacs+brace-expansion@5.0.0/node_modules/@isaacs/brace-expansion/src/index.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/assert-valid-pattern.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/brace-expressions.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/unescape.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/ast.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/escape.ts","../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/src/index.ts","../src/cli/loaders/locked-keys.ts","../src/cli/utils/key-matching.ts","../src/cli/loaders/mdx2/frontmatter-split.ts","../src/cli/utils/md5.ts","../src/cli/loaders/mdx2/code-placeholder.ts","../src/cli/loaders/mdx2/localizable-document.ts","../src/cli/loaders/mdx2/sections-split-2.ts","../src/cli/loaders/locked-patterns.ts","../src/cli/loaders/ignored-keys.ts","../src/cli/loaders/ejs.ts","../src/cli/loaders/ensure-key-order.ts","../src/cli/loaders/txt.ts","../src/cli/loaders/json-dictionary.ts","../src/cli/loaders/index.ts","../src/cli/cmd/show/ignored-keys.ts","../src/cli/cmd/config/index.ts","../src/cli/cmd/config/set.ts","../src/cli/cmd/config/unset.ts","../src/cli/cmd/config/get.ts","../src/cli/cmd/i18n.ts","../src/cli/processor/index.ts","../src/cli/processor/lingo.ts","../src/cli/processor/basic.ts","../src/cli/utils/exp-backoff.ts","../src/cli/utils/observability.ts","../src/cli/utils/delta.ts","../src/cli/utils/fs.ts","../src/cli/cmd/lockfile.ts","../src/cli/utils/lockfile.ts","../src/cli/cmd/cleanup.ts","../src/cli/cmd/mcp.ts","../src/cli/cmd/ci/index.ts","../src/cli/cmd/ci/flows/pull-request.ts","../src/cli/cmd/ci/flows/in-branch.ts","../src/cli/cmd/ci/flows/_base.ts","../src/cli/cmd/run/index.ts","../src/cli/cmd/run/setup.ts","../src/cli/cmd/run/_const.ts","../src/cli/localizer/lingodotdev.ts","../src/cli/localizer/explicit.ts","../src/cli/localizer/index.ts","../src/cli/cmd/run/plan.ts","../src/cli/cmd/run/execute.ts","../src/cli/cmd/run/watch.ts","../src/cli/cmd/run/_types.ts","../src/cli/cmd/run/frozen.ts","../src/cli/cmd/run/_utils.ts","../src/cli/cmd/ci/platforms/bitbucket.ts","../src/cli/cmd/ci/platforms/_base.ts","../src/cli/cmd/ci/platforms/github.ts","../src/cli/cmd/ci/platforms/gitlab.ts","../src/cli/cmd/ci/platforms/index.ts","../src/cli/cmd/status.ts","../src/cli/utils/exit-gracefully.ts","../src/cli/cmd/may-the-fourth.ts","../package.json","../src/cli/cmd/purge.ts"],"sourcesContent":["import dotenv from \"dotenv\";\ndotenv.config();\n\nimport { InteractiveCommand } from \"interactive-commander\";\nimport figlet from \"figlet\";\nimport { vice } from \"gradient-string\";\n\nimport authCmd from \"./cmd/auth\";\nimport loginCmd from \"./cmd/login\";\nimport logoutCmd from \"./cmd/logout\";\nimport initCmd from \"./cmd/init\";\nimport showCmd from \"./cmd/show\";\nimport configCmd from \"./cmd/config\";\nimport i18nCmd from \"./cmd/i18n\";\nimport lockfileCmd from \"./cmd/lockfile\";\nimport cleanupCmd from \"./cmd/cleanup\";\nimport mcpCmd from \"./cmd/mcp\";\nimport ciCmd from \"./cmd/ci\";\nimport statusCmd from \"./cmd/status\";\nimport mayTheFourthCmd from \"./cmd/may-the-fourth\";\nimport packageJson from \"../../package.json\";\nimport run from \"./cmd/run\";\nimport purgeCmd from \"./cmd/purge\";\n\nexport default new InteractiveCommand()\n  .name(\"lingo.dev\")\n  .description(\"Lingo.dev CLI\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .addHelpText(\n    \"beforeAll\",\n    `\n${vice(\n  figlet.textSync(\"LINGO.DEV\", {\n    font: \"ANSI Shadow\",\n    horizontalLayout: \"default\",\n    verticalLayout: \"default\",\n  }),\n)}\n\n‚ö°Ô∏è AI-powered open-source CLI for web & mobile localization.\n\nStar the the repo :) https://github.com/LingoDotDev/lingo.dev\n`,\n  )\n  .version(`v${packageJson.version}`, \"-v, --version\", \"Show version\")\n  .addCommand(initCmd)\n  .interactive(\n    \"-y, --no-interactive\",\n    \"Run every command in non-interactive mode (no prompts); required when scripting\",\n  ) // all interactive commands above\n  .addCommand(i18nCmd)\n  .addCommand(authCmd)\n  .addCommand(loginCmd)\n  .addCommand(logoutCmd)\n  .addCommand(showCmd)\n  .addCommand(configCmd)\n  .addCommand(lockfileCmd)\n  .addCommand(cleanupCmd)\n  .addCommand(mcpCmd)\n  .addCommand(ciCmd)\n  .addCommand(statusCmd)\n  .addCommand(mayTheFourthCmd, { hidden: true })\n  .addCommand(run)\n  .addCommand(purgeCmd)\n  .exitOverride((err) => {\n    // Exit with code 0 when help or version is displayed\n    if (\n      err.code === \"commander.helpDisplayed\" ||\n      err.code === \"commander.version\" ||\n      err.code === \"commander.help\"\n    ) {\n      process.exit(0);\n    }\n    process.exit(1);\n  });\n","import { Command } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport { getSettings, saveSettings } from \"../utils/settings\";\nimport { createAuthenticator } from \"../utils/auth\";\n\nexport default new Command()\n  .command(\"auth\")\n  .description(\"Show current authentication status and user email\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  // Deprecated options, safe to remove after September 2025\n  .option(\n    \"--login\",\n    \"DEPRECATED: Shows deprecation warning and exits. Use `lingo.dev login` instead\",\n  )\n  .option(\n    \"--logout\",\n    \"DEPRECATED: Shows deprecation warning and exits. Use `lingo.dev logout` instead\",\n  )\n  .action(async (options) => {\n    try {\n      // Handle deprecated login option\n      if (options.login) {\n        Ora().warn(\n          \"‚ö†Ô∏è  DEPRECATED: '--login' is deprecated. Please use 'lingo.dev login' instead.\",\n        );\n        process.exit(1);\n      }\n\n      // Handle deprecated logout option\n      if (options.logout) {\n        Ora().warn(\n          \"‚ö†Ô∏è  DEPRECATED: '--logout' is deprecated. Please use 'lingo.dev logout' instead.\",\n        );\n        process.exit(1);\n      }\n\n      // Default behavior: show authentication status\n      const settings = await getSettings(undefined);\n      const authenticator = createAuthenticator({\n        apiUrl: settings.auth.apiUrl,\n        apiKey: settings.auth.apiKey!,\n      });\n      const auth = await authenticator.whoami();\n      if (!auth) {\n        Ora().warn(\"Not authenticated\");\n      } else {\n        Ora().succeed(`Authenticated as ${auth.email}`);\n      }\n    } catch (error: any) {\n      Ora().fail(error.message);\n      process.exit(1);\n    }\n  });\n","import os from \"os\";\nimport path from \"path\";\nimport _ from \"lodash\";\nimport Z from \"zod\";\nimport fs from \"fs\";\nimport Ini from \"ini\";\n\nexport type CliSettings = Z.infer<typeof SettingsSchema>;\n\nexport function getSettings(explicitApiKey: string | undefined): CliSettings {\n  const env = _loadEnv();\n  const systemFile = _loadSystemFile();\n  const defaults = _loadDefaults();\n\n  _legacyEnvVarWarning();\n\n  _envVarsInfo();\n\n  return {\n    auth: {\n      apiKey:\n        explicitApiKey ||\n        env.LINGODOTDEV_API_KEY ||\n        systemFile.auth?.apiKey ||\n        defaults.auth.apiKey,\n      apiUrl:\n        env.LINGODOTDEV_API_URL ||\n        systemFile.auth?.apiUrl ||\n        defaults.auth.apiUrl,\n      webUrl:\n        env.LINGODOTDEV_WEB_URL ||\n        systemFile.auth?.webUrl ||\n        defaults.auth.webUrl,\n    },\n    llm: {\n      openaiApiKey: env.OPENAI_API_KEY || systemFile.llm?.openaiApiKey,\n      anthropicApiKey: env.ANTHROPIC_API_KEY || systemFile.llm?.anthropicApiKey,\n      groqApiKey: env.GROQ_API_KEY || systemFile.llm?.groqApiKey,\n      googleApiKey: env.GOOGLE_API_KEY || systemFile.llm?.googleApiKey,\n      openrouterApiKey:\n        env.OPENROUTER_API_KEY || systemFile.llm?.openrouterApiKey,\n      mistralApiKey: env.MISTRAL_API_KEY || systemFile.llm?.mistralApiKey,\n    },\n  };\n}\n\nexport function saveSettings(settings: CliSettings): void {\n  _saveSystemFile(settings);\n}\n\nexport function loadSystemSettings() {\n  return _loadSystemFile();\n}\n\nconst flattenZodObject = (schema: Z.ZodObject<any>, prefix = \"\"): string[] => {\n  return Object.entries(schema.shape).flatMap(([key, value]) => {\n    const newPrefix = prefix ? `${prefix}.${key}` : key;\n    if (value instanceof Z.ZodObject) {\n      return flattenZodObject(value, newPrefix);\n    }\n    return [newPrefix];\n  });\n};\n\nconst SettingsSchema = Z.object({\n  auth: Z.object({\n    apiKey: Z.string(),\n    apiUrl: Z.string(),\n    webUrl: Z.string(),\n  }),\n  llm: Z.object({\n    openaiApiKey: Z.string().optional(),\n    anthropicApiKey: Z.string().optional(),\n    groqApiKey: Z.string().optional(),\n    googleApiKey: Z.string().optional(),\n    openrouterApiKey: Z.string().optional(),\n    mistralApiKey: Z.string().optional(),\n  }),\n});\n\nexport const SETTINGS_KEYS = flattenZodObject(\n  SettingsSchema,\n) as readonly string[];\n\n// Private\n\nfunction _loadDefaults(): CliSettings {\n  return {\n    auth: {\n      apiKey: \"\",\n      apiUrl: \"https://engine.lingo.dev\",\n      webUrl: \"https://lingo.dev\",\n    },\n    llm: {},\n  };\n}\n\nfunction _loadEnv() {\n  return Z.object({\n    LINGODOTDEV_API_KEY: Z.string().optional(),\n    LINGODOTDEV_API_URL: Z.string().optional(),\n    LINGODOTDEV_WEB_URL: Z.string().optional(),\n    OPENAI_API_KEY: Z.string().optional(),\n    ANTHROPIC_API_KEY: Z.string().optional(),\n    GROQ_API_KEY: Z.string().optional(),\n    GOOGLE_API_KEY: Z.string().optional(),\n    OPENROUTER_API_KEY: Z.string().optional(),\n    MISTRAL_API_KEY: Z.string().optional(),\n  })\n    .passthrough()\n    .parse(process.env);\n}\n\nfunction _loadSystemFile() {\n  const settingsFilePath = _getSettingsFilePath();\n  const content = fs.existsSync(settingsFilePath)\n    ? fs.readFileSync(settingsFilePath, \"utf-8\")\n    : \"\";\n  const data = Ini.parse(content);\n\n  return Z.object({\n    auth: Z.object({\n      apiKey: Z.string().optional(),\n      apiUrl: Z.string().optional(),\n      webUrl: Z.string().optional(),\n    }).optional(),\n    llm: Z.object({\n      openaiApiKey: Z.string().optional(),\n      anthropicApiKey: Z.string().optional(),\n      groqApiKey: Z.string().optional(),\n      googleApiKey: Z.string().optional(),\n      openrouterApiKey: Z.string().optional(),\n      mistralApiKey: Z.string().optional(),\n    }).optional(),\n  })\n    .passthrough()\n    .parse(data);\n}\n\nfunction _saveSystemFile(settings: CliSettings) {\n  const settingsFilePath = _getSettingsFilePath();\n  const content = Ini.stringify(settings);\n  fs.writeFileSync(settingsFilePath, content);\n}\n\nfunction _getSettingsFilePath(): string {\n  const settingsFile = \".lingodotdevrc\";\n  const homedir = os.homedir();\n  const settingsFilePath = path.join(homedir, settingsFile);\n  return settingsFilePath;\n}\n\nfunction _legacyEnvVarWarning() {\n  const env = _loadEnv();\n\n  if (env.REPLEXICA_API_KEY && !env.LINGODOTDEV_API_KEY) {\n    console.warn(\n      \"\\x1b[33m%s\\x1b[0m\",\n      `\n‚ö†Ô∏è  WARNING: REPLEXICA_API_KEY env var is deprecated ‚ö†Ô∏è\n===========================================================\n\nPlease use LINGODOTDEV_API_KEY instead.\n===========================================================\n`,\n    );\n  }\n}\n\nfunction _envVarsInfo() {\n  const env = _loadEnv();\n  const systemFile = _loadSystemFile();\n\n  if (env.LINGODOTDEV_API_KEY && systemFile.auth?.apiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using LINGODOTDEV_API_KEY env var instead of credentials from user config`,\n    );\n  }\n  if (env.OPENAI_API_KEY && systemFile.llm?.openaiApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using OPENAI_API_KEY env var instead of key from user config.`,\n    );\n  }\n  if (env.ANTHROPIC_API_KEY && systemFile.llm?.anthropicApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using ANTHROPIC_API_KEY env var instead of key from user config`,\n    );\n  }\n  if (env.GROQ_API_KEY && systemFile.llm?.groqApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using GROQ_API_KEY env var instead of key from user config`,\n    );\n  }\n  if (env.GOOGLE_API_KEY && systemFile.llm?.googleApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using GOOGLE_API_KEY env var instead of key from user config`,\n    );\n  }\n  if (env.OPENROUTER_API_KEY && systemFile.llm?.openrouterApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using OPENROUTER_API_KEY env var instead of key from user config`,\n    );\n  }\n  if (env.MISTRAL_API_KEY && systemFile.llm?.mistralApiKey) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using MISTRAL_API_KEY env var instead of key from user config`,\n    );\n  }\n  if (env.LINGODOTDEV_API_URL) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using LINGODOTDEV_API_URL: ${env.LINGODOTDEV_API_URL}`,\n    );\n  }\n  if (env.LINGODOTDEV_WEB_URL) {\n    console.info(\n      \"\\x1b[36m%s\\x1b[0m\",\n      `‚ÑπÔ∏è  Using LINGODOTDEV_WEB_URL: ${env.LINGODOTDEV_WEB_URL}`,\n    );\n  }\n}\n","export const docLinks = {\n  i18nNotFound: \"https://lingo.dev/cli\",\n  bucketNotFound: \"https://lingo.dev/cli\",\n  authError: \"https://lingo.dev/cli\",\n  localeTargetNotFound: \"https://lingo.dev/cli\",\n  lockFiletNotFound: \"https://lingo.dev/cli\",\n  failedReplexicaEngine: \"https://lingo.dev/cli\",\n  placeHolderFailed: \"https://lingo.dev/cli\",\n  translationFailed: \"https://lingo.dev/cli\",\n  connectionFailed: \"https://lingo.dev/cli\",\n  invalidType: \"https://lingo.dev/cli\",\n  invalidPathPattern: \"https://lingo.dev/cli\",\n  androidResouceError: \"https://lingo.dev/cli\",\n  invalidBucketType: \"https://lingo.dev/cli\",\n  invalidStringDict: \"https://lingo.dev/cli\",\n};\n\ntype DocLinkKeys = keyof typeof docLinks;\n\nexport class CLIError extends Error {\n  public readonly docUrl: string;\n  public readonly errorType: string = \"cli_error\";\n\n  constructor({ message, docUrl }: { message: string; docUrl: DocLinkKeys }) {\n    super(message);\n    this.docUrl = docLinks[docUrl];\n    this.message = `${this.message}\\n visit: ${this.docUrl}`;\n  }\n}\n\nexport class ConfigError extends CLIError {\n  public readonly errorType = \"config_error\";\n\n  constructor({ message, docUrl }: { message: string; docUrl: DocLinkKeys }) {\n    super({ message, docUrl });\n    this.name = \"ConfigError\";\n  }\n}\n\nexport class AuthenticationError extends CLIError {\n  public readonly errorType = \"auth_error\";\n\n  constructor({ message, docUrl }: { message: string; docUrl: DocLinkKeys }) {\n    super({ message, docUrl });\n    this.name = \"AuthenticationError\";\n  }\n}\n\nexport class ValidationError extends CLIError {\n  public readonly errorType = \"validation_error\";\n\n  constructor({ message, docUrl }: { message: string; docUrl: DocLinkKeys }) {\n    super({ message, docUrl });\n    this.name = \"ValidationError\";\n  }\n}\n\nexport class LocalizationError extends Error {\n  public readonly errorType = \"locale_error\";\n  public readonly bucket?: string;\n  public readonly sourceLocale?: string;\n  public readonly targetLocale?: string;\n  public readonly pathPattern?: string;\n\n  constructor(\n    message: string,\n    context?: {\n      bucket?: string;\n      sourceLocale?: string;\n      targetLocale?: string;\n      pathPattern?: string;\n    },\n  ) {\n    super(message);\n    this.name = \"LocalizationError\";\n    this.bucket = context?.bucket;\n    this.sourceLocale = context?.sourceLocale;\n    this.targetLocale = context?.targetLocale;\n    this.pathPattern = context?.pathPattern;\n  }\n}\n\nexport class BucketProcessingError extends Error {\n  public readonly errorType = \"bucket_error\";\n  public readonly bucket: string;\n\n  constructor(message: string, bucket: string) {\n    super(message);\n    this.name = \"BucketProcessingError\";\n    this.bucket = bucket;\n  }\n}\n\n// Type guard functions for robust error detection\nexport function isConfigError(error: any): error is ConfigError {\n  return error instanceof ConfigError || error.errorType === \"config_error\";\n}\n\nexport function isAuthenticationError(\n  error: any,\n): error is AuthenticationError {\n  return (\n    error instanceof AuthenticationError || error.errorType === \"auth_error\"\n  );\n}\n\nexport function isValidationError(error: any): error is ValidationError {\n  return (\n    error instanceof ValidationError || error.errorType === \"validation_error\"\n  );\n}\n\nexport function isLocalizationError(error: any): error is LocalizationError {\n  return (\n    error instanceof LocalizationError || error.errorType === \"locale_error\"\n  );\n}\n\nexport function isBucketProcessingError(\n  error: any,\n): error is BucketProcessingError {\n  return (\n    error instanceof BucketProcessingError || error.errorType === \"bucket_error\"\n  );\n}\n\nexport function getCLIErrorType(error: any): string {\n  if (isConfigError(error)) return \"config_error\";\n  if (isAuthenticationError(error)) return \"auth_error\";\n  if (isValidationError(error)) return \"validation_error\";\n  if (isLocalizationError(error)) return \"locale_error\";\n  if (isBucketProcessingError(error)) return \"bucket_error\";\n  if (error instanceof CLIError) return \"cli_error\";\n  return \"unknown_error\";\n}\n\n// Error detail interface for consistent tracking\nexport interface ErrorDetail {\n  type:\n    | \"bucket_error\"\n    | \"locale_error\"\n    | \"validation_error\"\n    | \"auth_error\"\n    | \"config_error\";\n  bucket?: string;\n  locale?: string;\n  pathPattern?: string;\n  message: string;\n  stack?: string;\n}\n\n// Utility to create previous error context for fatal errors\nexport function createPreviousErrorContext(errorDetails: ErrorDetail[]) {\n  if (errorDetails.length === 0) return undefined;\n\n  return {\n    count: errorDetails.length,\n    types: [...new Set(errorDetails.map((e) => e.type))],\n    buckets: [...new Set(errorDetails.map((e) => e.bucket).filter(Boolean))],\n  };\n}\n\n// Utility to create aggregated error analytics\nexport function aggregateErrorAnalytics(\n  errorDetails: ErrorDetail[],\n  buckets: any[],\n  targetLocales: string[],\n  i18nConfig: any,\n) {\n  if (errorDetails.length === 0) {\n    return {\n      errorCount: 0,\n      errorTypes: [],\n      errorsByBucket: {},\n      errorsByType: {},\n      firstError: undefined,\n      bucketCount: buckets.length,\n      localeCount: targetLocales.length,\n      i18nConfig: {\n        sourceLocale: i18nConfig.locale.source,\n        targetLocales: i18nConfig.locale.targets,\n        bucketTypes: Object.keys(i18nConfig.buckets),\n      },\n    };\n  }\n\n  const errorsByBucket = errorDetails.reduce(\n    (acc, error) => {\n      if (error.bucket) {\n        acc[error.bucket] = (acc[error.bucket] || 0) + 1;\n      }\n      return acc;\n    },\n    {} as Record<string, number>,\n  );\n\n  const errorsByType = errorDetails.reduce(\n    (acc, error) => {\n      acc[error.type] = (acc[error.type] || 0) + 1;\n      return acc;\n    },\n    {} as Record<string, number>,\n  );\n\n  return {\n    errorCount: errorDetails.length,\n    errorTypes: [...new Set(errorDetails.map((e) => e.type))],\n    errorsByBucket,\n    errorsByType,\n    firstError: {\n      type: errorDetails[0].type,\n      bucket: errorDetails[0].bucket,\n      locale: errorDetails[0].locale,\n      pathPattern: errorDetails[0].pathPattern,\n      message: errorDetails[0].message,\n    },\n    bucketCount: buckets.length,\n    localeCount: targetLocales.length,\n    i18nConfig: {\n      sourceLocale: i18nConfig.locale.source,\n      targetLocales: i18nConfig.locale.targets,\n      bucketTypes: Object.keys(i18nConfig.buckets),\n    },\n  };\n}\n","export interface CloudflareStatusResponse {\n  status: {\n    indicator: \"none\" | \"minor\" | \"major\" | \"critical\";\n    description: string;\n  };\n}\n\nexport async function checkCloudflareStatus(): Promise<CloudflareStatusResponse | null> {\n  try {\n    const response = await fetch(\n      \"https://www.cloudflarestatus.com/api/v2/status.json\",\n      {\n        signal: AbortSignal.timeout(5000),\n      },\n    );\n    if (response.ok) {\n      return await response.json();\n    }\n  } catch (error) {}\n  return null;\n}\n\nexport function formatCloudflareStatusMessage(\n  status: CloudflareStatusResponse,\n): string {\n  if (status.status.indicator === \"none\") {\n    return \"\";\n  }\n  return `Cloudflare is experiencing ${status.status.indicator} issues: ${status.status.description}. This may be affecting the API connection.`;\n}\n","import { CLIError } from \"./errors\";\nimport {\n  checkCloudflareStatus,\n  formatCloudflareStatusMessage,\n} from \"./cloudflare-status\";\n\nexport type AuthenticatorParams = {\n  apiUrl: string;\n  apiKey: string;\n};\n\nexport type AuthPayload = {\n  email: string;\n  id: string;\n};\n\nexport function createAuthenticator(params: AuthenticatorParams) {\n  return {\n    async whoami(): Promise<AuthPayload | null> {\n      try {\n        const res = await fetch(`${params.apiUrl}/whoami`, {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${params.apiKey}`,\n            ContentType: \"application/json\",\n          },\n        });\n\n        if (res.ok) {\n          const payload = await res.json();\n          if (!payload?.email) {\n            return null;\n          }\n\n          return {\n            email: payload.email,\n            id: payload.id,\n          };\n        }\n\n        if (res.status >= 500 && res.status < 600) {\n          const originalErrorMessage = `Server error (${res.status}): ${res.statusText}. Please try again later.`;\n\n          const cloudflareStatus = await checkCloudflareStatus();\n\n          if (!cloudflareStatus) {\n            throw new CLIError({\n              message: originalErrorMessage,\n              docUrl: \"connectionFailed\",\n            });\n          }\n\n          if (cloudflareStatus.status.indicator !== \"none\") {\n            const cloudflareMessage =\n              formatCloudflareStatusMessage(cloudflareStatus);\n            throw new CLIError({\n              message: cloudflareMessage,\n              docUrl: \"connectionFailed\",\n            });\n          }\n\n          throw new CLIError({\n            message: originalErrorMessage,\n            docUrl: \"connectionFailed\",\n          });\n        }\n\n        return null;\n      } catch (error) {\n        if (error instanceof CLIError) {\n          throw error;\n        }\n\n        const isNetworkError =\n          error instanceof TypeError && error.message === \"fetch failed\";\n        if (isNetworkError) {\n          throw new CLIError({\n            message: `Failed to connect to the API at ${params.apiUrl}. Please check your connection and try again.`,\n            docUrl: \"connectionFailed\",\n          });\n        } else {\n          throw error;\n        }\n      }\n    },\n  };\n}\n","import { Command } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport open from \"open\";\nimport readline from \"readline/promises\";\nimport { getSettings, saveSettings } from \"../utils/settings\";\nimport {\n  renderClear,\n  renderSpacer,\n  renderBanner,\n  renderHero,\n} from \"../utils/ui\";\n\nexport default new Command()\n  .command(\"login\")\n  .description(\n    \"Open browser to authenticate with lingo.dev and save your API key\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async () => {\n    try {\n      await renderClear();\n      await renderSpacer();\n      await renderBanner();\n      await renderHero();\n      await renderSpacer();\n\n      const settings = await getSettings(undefined);\n      const apiKey = await login(settings.auth.webUrl);\n      settings.auth.apiKey = apiKey;\n      await saveSettings(settings);\n      Ora().succeed(\"Successfully logged in\");\n    } catch (error: any) {\n      Ora().fail(error.message);\n      process.exit(1);\n    }\n  });\n\nexport async function login(webAppUrl: string) {\n  await readline\n    .createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    })\n    .question(\n      `\nPress Enter to open the browser for authentication.\n\n---\n\nHaving issues? Put LINGODOTDEV_API_KEY in your .env file instead.\n    `.trim() + \"\\n\",\n    );\n\n  const spinner = Ora().start(\"Waiting for the API key\");\n  const apiKey = await waitForApiKey(async (port) => {\n    await open(`${webAppUrl}/app/cli?port=${port}`, { wait: false });\n  });\n  spinner.succeed(\"API key received\");\n\n  return apiKey;\n}\n\nasync function waitForApiKey(cb: (port: string) => void): Promise<string> {\n  const app = express();\n  app.use(express.json());\n  app.use(cors());\n\n  return new Promise((resolve) => {\n    const server = app.listen(0, async () => {\n      const port = (server.address() as any).port;\n      cb(port.toString());\n    });\n\n    app.post(\"/\", (req, res) => {\n      const apiKey = req.body.apiKey;\n      res.end();\n      server.close(() => {\n        resolve(apiKey);\n      });\n    });\n  });\n}\n","import chalk from \"chalk\";\nimport figlet from \"figlet\";\nimport { vice } from \"gradient-string\";\nimport readline from \"readline\";\nimport { colors } from \"../constants\";\n\nexport async function renderClear() {\n  console.log(\"\\x1Bc\");\n}\n\nexport async function renderSpacer() {\n  console.log(\" \");\n}\n\nexport async function renderBanner() {\n  console.log(\n    vice(\n      figlet.textSync(\"LINGO.DEV\", {\n        font: \"ANSI Shadow\",\n        horizontalLayout: \"default\",\n        verticalLayout: \"default\",\n      }),\n    ),\n  );\n}\n\nexport async function renderHero() {\n  console.log(\n    `‚ö°Ô∏è ${chalk.hex(colors.green)(\n      \"Lingo.dev\",\n    )} - open-source, AI-powered i18n CLI for web & mobile localization.`,\n  );\n  console.log(\"\");\n\n  const label1 = \"üìö Docs:\";\n  const label2 = \"‚≠ê Star the repo:\";\n  const label3 = \"üéÆ Join Discord:\";\n  const maxLabelWidth = 17; // Approximate visual width accounting for emoji\n\n  console.log(\n    `${chalk.hex(colors.blue)(label1.padEnd(maxLabelWidth + 1))} ${chalk.hex(\n      colors.blue,\n    )(\"https://lingo.dev/go/docs\")}`,\n  ); // Docs emoji seems narrower\n  console.log(\n    `${chalk.hex(colors.blue)(label2.padEnd(maxLabelWidth))} ${chalk.hex(\n      colors.blue,\n    )(\"https://lingo.dev/go/gh\")}`,\n  );\n  console.log(\n    `${chalk.hex(colors.blue)(label3.padEnd(maxLabelWidth + 1))} ${chalk.hex(\n      colors.blue,\n    )(\"https://lingo.dev/go/discord\")}`,\n  );\n}\n\nexport async function waitForUserPrompt(message: string): Promise<void> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(chalk.dim(`[${message}]\\n`), () => {\n      rl.close();\n      resolve();\n    });\n  });\n}\n\nexport async function pauseIfDebug(debug: boolean) {\n  if (debug) {\n    await waitForUserPrompt(\"Press Enter to continue...\");\n  }\n}\n\nexport async function renderSummary(results: Map<any, any>) {\n  console.log(chalk.hex(colors.green)(\"[Done]\"));\n\n  const skippedResults = Array.from(results.values()).filter(\n    (r) => r.status === \"skipped\",\n  );\n  const succeededResults = Array.from(results.values()).filter(\n    (r) => r.status === \"success\",\n  );\n  const failedResults = Array.from(results.values()).filter(\n    (r) => r.status === \"error\",\n  );\n\n  console.log(\n    `‚Ä¢ ${chalk.hex(colors.yellow)(skippedResults.length)} from cache`,\n  );\n  console.log(\n    `‚Ä¢ ${chalk.hex(colors.yellow)(succeededResults.length)} processed`,\n  );\n  console.log(`‚Ä¢ ${chalk.hex(colors.yellow)(failedResults.length)} failed`);\n\n  // Show processed files\n  if (succeededResults.length > 0) {\n    console.log(chalk.hex(colors.green)(\"\\n[Processed Files]\"));\n    for (const result of succeededResults) {\n      const displayPath =\n        result.pathPattern?.replace(\"[locale]\", result.targetLocale) ||\n        \"unknown\";\n      console.log(\n        `  ‚úì ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} ‚Üí ${result.targetLocale})`)}`,\n      );\n    }\n  }\n\n  // Show cached files\n  if (skippedResults.length > 0) {\n    console.log(chalk.hex(colors.blue)(\"\\n[Cached Files]\"));\n    for (const result of skippedResults) {\n      const displayPath =\n        result.pathPattern?.replace(\"[locale]\", result.targetLocale) ||\n        \"unknown\";\n      console.log(\n        `  ‚ö° ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} ‚Üí ${result.targetLocale})`)}`,\n      );\n    }\n  }\n\n  // Show failed files\n  if (failedResults.length > 0) {\n    console.log(chalk.hex(colors.orange)(\"\\n[Failed Files]\"));\n    for (const result of failedResults) {\n      const displayPath =\n        result.pathPattern?.replace(\"[locale]\", result.targetLocale) ||\n        \"unknown\";\n      console.log(\n        `  ‚ùå ${chalk.dim(displayPath)} ${chalk.hex(colors.yellow)(`(${result.sourceLocale} ‚Üí ${result.targetLocale})`)}`,\n      );\n      console.log(\n        `     ${chalk.hex(colors.white)(String(result.error?.message || \"Unknown error\"))}`,\n      );\n    }\n  }\n}\n","export const colors = {\n  orange: \"#ff6600\",\n  green: \"#6ae300\",\n  blue: \"#0090ff\",\n  yellow: \"#ffcc00\",\n  grey: \"#808080\",\n  red: \"#ff0000\",\n  white: \"#ffffff\",\n};\n","import { Command } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport { getSettings, saveSettings } from \"../utils/settings\";\nimport {\n  renderClear,\n  renderSpacer,\n  renderBanner,\n  renderHero,\n} from \"../utils/ui\";\n\nexport default new Command()\n  .command(\"logout\")\n  .description(\"Log out by removing saved authentication credentials\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async () => {\n    try {\n      await renderClear();\n      await renderSpacer();\n      await renderBanner();\n      await renderHero();\n      await renderSpacer();\n\n      const settings = await getSettings(undefined);\n      settings.auth.apiKey = \"\";\n      await saveSettings(settings);\n      Ora().succeed(\"Successfully logged out\");\n    } catch (error: any) {\n      Ora().fail(error.message);\n      process.exit(1);\n    }\n  });\n","import { InteractiveCommand, InteractiveOption } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport { getConfig, saveConfig } from \"../utils/config\";\nimport {\n  defaultConfig,\n  LocaleCode,\n  resolveLocaleCode,\n  bucketTypes,\n} from \"@lingo.dev/_spec\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport _ from \"lodash\";\nimport { checkbox, confirm, input } from \"@inquirer/prompts\";\nimport { login } from \"./login\";\nimport { getSettings, saveSettings } from \"../utils/settings\";\nimport { createAuthenticator } from \"../utils/auth\";\nimport findLocaleFiles from \"../utils/find-locale-paths\";\nimport { ensurePatterns } from \"../utils/ensure-patterns\";\nimport updateGitignore from \"../utils/update-gitignore\";\nimport initCICD from \"../utils/init-ci-cd\";\nimport open from \"open\";\n\nconst openUrl = (path: string) => {\n  const settings = getSettings(undefined);\n  open(`${settings.auth.webUrl}${path}`, { wait: false });\n};\n\nconst throwHelpError = (option: string, value: string) => {\n  if (value === \"help\") {\n    openUrl(\"/go/call\");\n  }\n  throw new Error(\n    `Invalid ${option}: ${value}\\n\\nDo you need support for ${value} ${option}? Type \"help\" and we will.`,\n  );\n};\n\nexport default new InteractiveCommand()\n  .command(\"init\")\n  .description(\"Create i18n.json configuration file for a new project\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .addOption(\n    new InteractiveOption(\n      \"-f --force\",\n      \"Overwrite existing Lingo.dev configuration instead of aborting initialization (destructive operation)\",\n    )\n      .prompt(undefined)\n      .default(false),\n  )\n  .addOption(\n    new InteractiveOption(\n      \"-s --source <locale>\",\n      \"Primary language of your application that content will be translated from. Defaults to 'en'\",\n    )\n      .argParser((value) => {\n        try {\n          resolveLocaleCode(value as LocaleCode);\n        } catch (e) {\n          throwHelpError(\"locale\", value);\n        }\n        return value;\n      })\n      .default(\"en\"),\n  )\n  .addOption(\n    new InteractiveOption(\n      \"-t --targets <locale...>\",\n      \"Target languages to translate to. Accepts locale codes like 'es', 'fr', 'de-AT' separated by commas or spaces. Defaults to 'es'\",\n    )\n      .argParser((value) => {\n        const values = (\n          value.includes(\",\") ? value.split(\",\") : value.split(\" \")\n        ) as LocaleCode[];\n        values.forEach((value) => {\n          try {\n            resolveLocaleCode(value);\n          } catch (e) {\n            throwHelpError(\"locale\", value);\n          }\n        });\n        return values;\n      })\n      .default(\"es\"),\n  )\n  .addOption(\n    new InteractiveOption(\n      \"-b, --bucket <type>\",\n      \"File format for your translation files. Must match a supported type such as json, yaml, or android\",\n    )\n      .argParser((value) => {\n        if (!bucketTypes.includes(value as (typeof bucketTypes)[number])) {\n          throwHelpError(\"bucket format\", value);\n        }\n        return value;\n      })\n      .default(\"json\"),\n  )\n  .addOption(\n    new InteractiveOption(\n      \"-p, --paths [path...]\",\n      \"File paths containing translations when using --no-interactive mode. Specify paths with [locale] placeholder, separated by commas or spaces\",\n    )\n      .argParser((value) => {\n        if (!value || value.length === 0) return [];\n        const values = value.includes(\",\")\n          ? value.split(\",\")\n          : value.split(\" \");\n\n        for (const p of values) {\n          try {\n            const dirPath = path.dirname(p);\n            const stats = fs.statSync(dirPath);\n            if (!stats.isDirectory()) {\n              throw new Error(`${dirPath} is not a directory`);\n            }\n          } catch (err) {\n            throw new Error(`Invalid path: ${p}`);\n          }\n        }\n\n        return values;\n      })\n      .prompt(undefined) // make non-interactive\n      .default([]),\n  )\n  .action(async (options) => {\n    const settings = getSettings(undefined);\n    const isInteractive = options.interactive;\n\n    const spinner = Ora().start(\"Initializing Lingo.dev project\");\n\n    let existingConfig = await getConfig(false);\n    if (existingConfig && !options.force) {\n      spinner.fail(\"Lingo.dev project already initialized\");\n      return process.exit(1);\n    }\n\n    const newConfig = _.cloneDeep(defaultConfig);\n\n    newConfig.locale.source = options.source;\n    newConfig.locale.targets = options.targets;\n\n    if (!isInteractive) {\n      newConfig.buckets = {\n        [options.bucket]: {\n          include: options.paths || [],\n        },\n      };\n    } else {\n      let selectedPatterns: string[] = [];\n      const localeFiles = findLocaleFiles(options.bucket);\n\n      if (!localeFiles) {\n        spinner.warn(\n          `Bucket type \"${options.bucket}\" does not supported automatic initialization. Add paths to \"i18n.json\" manually.`,\n        );\n        newConfig.buckets = {\n          [options.bucket]: {\n            include: options.paths || [],\n          },\n        };\n      } else {\n        const { patterns, defaultPatterns } = localeFiles;\n\n        if (patterns.length > 0) {\n          spinner.succeed(\"Found existing locale files:\");\n\n          selectedPatterns = await checkbox({\n            message: \"Select the paths to use\",\n            choices: patterns.map((value) => ({\n              value,\n            })),\n          });\n        } else {\n          spinner.succeed(\"No existing locale files found.\");\n        }\n\n        if (selectedPatterns.length === 0) {\n          const useDefault = await confirm({\n            message: `Use (and create) default path ${defaultPatterns.join(\n              \", \",\n            )}?`,\n          });\n          if (useDefault) {\n            ensurePatterns(defaultPatterns, options.source);\n            selectedPatterns = defaultPatterns;\n          }\n        }\n\n        if (selectedPatterns.length === 0) {\n          const customPaths = await input({\n            message: \"Enter paths to use\",\n          });\n          selectedPatterns = customPaths.includes(\",\")\n            ? customPaths.split(\",\")\n            : customPaths.split(\" \");\n        }\n\n        newConfig.buckets = {\n          [options.bucket]: {\n            include: selectedPatterns || [],\n          },\n        };\n      }\n    }\n\n    await saveConfig(newConfig);\n\n    spinner.succeed(\"Lingo.dev project initialized\");\n\n    if (isInteractive) {\n      await initCICD(spinner);\n\n      const openDocs = await confirm({\n        message: \"Would you like to see our docs?\",\n      });\n      if (openDocs) {\n        openUrl(\"/go/docs\");\n      }\n    }\n\n    const authenticator = createAuthenticator({\n      apiKey: settings.auth.apiKey,\n      apiUrl: settings.auth.apiUrl,\n    });\n    const auth = await authenticator.whoami();\n    if (!auth) {\n      if (isInteractive) {\n        const doAuth = await confirm({\n          message: \"It looks like you are not logged into the CLI. Login now?\",\n        });\n        if (doAuth) {\n          const apiKey = await login(settings.auth.webUrl);\n          settings.auth.apiKey = apiKey;\n          await saveSettings(settings);\n\n          const newAuthenticator = createAuthenticator({\n            apiKey: settings.auth.apiKey,\n            apiUrl: settings.auth.apiUrl,\n          });\n          const auth = await newAuthenticator.whoami();\n          if (auth) {\n            Ora().succeed(`Authenticated as ${auth?.email}`);\n          } else {\n            Ora().fail(\"Authentication failed.\");\n          }\n        }\n      } else {\n        Ora().warn(\n          \"You are not logged in. Run `npx lingo.dev@latest login` to login.\",\n        );\n      }\n    } else {\n      Ora().succeed(`Authenticated as ${auth.email}`);\n    }\n\n    updateGitignore();\n\n    if (!isInteractive) {\n      Ora().info(\"Please see https://lingo.dev/cli\");\n    }\n  });\n","import _ from \"lodash\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { I18nConfig, parseI18nConfig } from \"@lingo.dev/_spec\";\n\nexport function getConfig(resave = true): I18nConfig | null {\n  const configFilePath = _getConfigFilePath();\n\n  const configFileExists = fs.existsSync(configFilePath);\n  if (!configFileExists) {\n    return null;\n  }\n\n  const fileContents = fs.readFileSync(configFilePath, \"utf8\");\n  const rawConfig = JSON.parse(fileContents);\n\n  const result = parseI18nConfig(rawConfig);\n  const didConfigChange = !_.isEqual(rawConfig, result);\n\n  if (resave && didConfigChange) {\n    // Ensure the config is saved with the latest version / schema\n    saveConfig(result);\n  }\n\n  return result;\n}\n\nexport function saveConfig(config: I18nConfig) {\n  const configFilePath = _getConfigFilePath();\n\n  const serialized = JSON.stringify(config, null, 2);\n  fs.writeFileSync(configFilePath, serialized);\n\n  return config;\n}\n\n// Private\n\nfunction _getConfigFilePath() {\n  return path.join(process.cwd(), \"i18n.json\");\n}\n","import fs from \"fs\";\nimport path from \"path\";\nimport { glob } from \"glob\";\nimport _ from \"lodash\";\nimport { LocaleCode, resolveLocaleCode } from \"@lingo.dev/_spec\";\n\nexport default function findLocaleFiles(bucket: string) {\n  switch (bucket) {\n    case \"json\":\n      return findLocaleFilesWithExtension(\".json\");\n    case \"yaml\":\n      return findLocaleFilesWithExtension(\".yml\");\n    case \"flutter\":\n      return findLocaleFilesWithExtension(\".arb\");\n    case \"android\":\n      return findLocaleFilesWithExtension(\".xml\");\n    case \"markdown\":\n      return findLocaleFilesWithExtension(\".md\");\n    case \"php\":\n      return findLocaleFilesWithExtension(\".php\");\n    case \"po\":\n      return findLocaleFilesWithExtension(\".po\");\n    case \"xcode-xcstrings\":\n      return findLocaleFilesForFilename(\"Localizable.xcstrings\");\n    case \"xcode-strings\":\n      return findLocaleFilesForFilename(\"Localizable.strings\");\n    case \"xcode-stringsdict\":\n      return findLocaleFilesForFilename(\"Localizable.stringsdict\");\n    default:\n      return null;\n  }\n}\n\nfunction findLocaleFilesWithExtension(ext: string) {\n  const files = glob.sync(`**/*${ext}`, {\n    ignore: [\"node_modules/**\", \"package*.json\", \"i18n.json\", \"lingo.json\"],\n  });\n\n  const localeFilePattern = new RegExp(`\\/([a-z]{2}(-[A-Z]{2})?)${ext}$`);\n  const localeDirectoryPattern = new RegExp(\n    `\\/([a-z]{2}(-[A-Z]{2})?)\\/[^\\/]+${ext}$`,\n  );\n  const potentialLocaleFiles = files.filter(\n    (file: string) =>\n      localeFilePattern.test(file) || localeDirectoryPattern.test(file),\n  );\n\n  const potantialLocaleFilesAndPatterns = potentialLocaleFiles\n    .map((file: string) => {\n      const matchPotentialLocales = Array.from(\n        file.matchAll(\n          new RegExp(`\\/([a-z]{2}(-[A-Z]{2})?|[^\\/]+)(?=\\/|${ext})`, \"g\"),\n        ),\n      );\n      const potantialLocales = matchPotentialLocales.map((match) => match[1]);\n      return { file, potantialLocales };\n    })\n    .map(({ file, potantialLocales }) => {\n      for (const locale of potantialLocales) {\n        try {\n          resolveLocaleCode(locale as LocaleCode);\n          return { locale, file };\n        } catch (e) {}\n      }\n      return { file, locale: null };\n    })\n    .filter(({ locale }) => locale !== null);\n\n  const localeFilesAndPatterns = potantialLocaleFilesAndPatterns.map(\n    ({ file, locale }) => {\n      const pattern = file\n        .replaceAll(new RegExp(`/${locale}${ext}`, \"g\"), `/[locale]${ext}`)\n        .replaceAll(new RegExp(`/${locale}/`, \"g\"), `/[locale]/`)\n        .replaceAll(new RegExp(`/${locale}/`, \"g\"), `/[locale]/`); // for when there are 2 locales one after another\n      return { pattern, file };\n    },\n  );\n\n  const grouppedFilesAndPatterns = _.groupBy(localeFilesAndPatterns, \"pattern\");\n  const patterns = Object.keys(grouppedFilesAndPatterns);\n  const defaultPatterns = [`i18n/[locale]${ext}`];\n\n  if (patterns.length > 0) {\n    return { patterns, defaultPatterns };\n  }\n\n  return { patterns: [], defaultPatterns };\n}\n\nfunction findLocaleFilesForFilename(fileName: string) {\n  const pattern = fileName;\n  const localeFiles = glob.sync(`**/${fileName}`, {\n    ignore: [\"node_modules/**\", \"package*.json\", \"i18n.json\", \"lingo.json\"],\n  });\n\n  const localeFilesAndPatterns = localeFiles.map((file: string) => ({\n    file,\n    pattern: path.join(path.dirname(file), pattern),\n  }));\n  const grouppedFilesAndPatterns = _.groupBy(localeFilesAndPatterns, \"pattern\");\n  const patterns = Object.keys(grouppedFilesAndPatterns);\n  const defaultPatterns = [fileName];\n\n  if (patterns.length > 0) {\n    return { patterns, defaultPatterns };\n  }\n\n  return { patterns: [], defaultPatterns };\n}\n","import fs from \"fs\";\nimport path from \"path\";\nimport { glob } from \"glob\";\nimport _ from \"lodash\";\nimport { LocaleCode, resolveLocaleCode } from \"@lingo.dev/_spec\";\n\nexport function ensurePatterns(patterns: string[], source: string) {\n  if (patterns.length === 0) {\n    throw new Error(\"No patterns found\");\n  }\n\n  patterns.forEach((pattern) => {\n    const filePath = pattern.replace(\"[locale]\", source);\n    if (!fs.existsSync(filePath)) {\n      const defaultContent = getDefaultContent(path.extname(filePath), source);\n      fs.mkdirSync(path.dirname(filePath), { recursive: true });\n      fs.writeFileSync(filePath, defaultContent);\n    }\n  });\n}\n\nfunction getDefaultContent(ext: string, source: string) {\n  const defaultGreeting = \"Hello from Lingo.dev\";\n  switch (ext) {\n    case \".json\":\n    case \".arb\":\n      return `{\\n\\t\"greeting\": \"${defaultGreeting}\"\\n}`;\n    case \".yml\":\n      return `${source}:\\n\\tgreeting: \"${defaultGreeting}\"`;\n    case \".xml\":\n      return `<resources>\\n\\t<string name=\"greeting\">${defaultGreeting}</string>\\n</resources>`;\n    case \".md\":\n      return `# ${defaultGreeting}`;\n    case \".xcstrings\":\n      return `{\n  \"sourceLanguage\" : \"${source}\",\n  \"strings\" : {\n    \"${defaultGreeting}\" : {\n      \"extractionState\" : \"manual\",\n      \"localizations\" : {\n        \"${source}\" : {\n          \"stringUnit\" : {\n            \"state\" : \"translated\",\n            \"value\" : \"${defaultGreeting}\"\n          }\n        }\n      }\n    }\n  }\n}`;\n    case \".strings\":\n      return `\"greeting\" = \"${defaultGreeting}\";`;\n    case \".stringsdict\":\n      return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>key</key>\n  <dict>\n    <key>NSStringLocalizedFormatKey</key>\n    <string>%#@count@</string>\n    <key>count</key>\n    <dict>\n      <key>NSStringFormatSpecTypeKey</key>\n      <string>NSStringPluralRuleType</string>\n      <key>NSStringFormatValueTypeKey</key>\n      <string>d</string>\n      <key>zero</key>\n      <string>No items</string>\n      <key>one</key>\n      <string>One item</string>\n      <key>other</key>\n      <string>%d items</string>\n    </dict>\n  </dict>\n</dict>\n</plist>`;\n    default:\n      throw new Error(`Unsupported file extension: ${ext}`);\n  }\n}\n","import fs from \"fs\";\nimport path from \"path\";\n\nexport default function updateGitignore() {\n  const cacheFile = \"i18n.cache\";\n  const projectRoot = findCurrentProjectRoot();\n  if (!projectRoot) {\n    return;\n  }\n  const gitignorePath = path.join(projectRoot, \".gitignore\");\n  if (!fs.existsSync(gitignorePath)) {\n    return;\n  }\n\n  const gitignore = fs.readFileSync(gitignorePath, \"utf8\").split(\"\\n\");\n  const cacheIsIgnored = gitignore.includes(cacheFile);\n\n  if (!cacheIsIgnored) {\n    let content = \"\";\n\n    // Ensure there's a trailing newline\n    content = fs.readFileSync(gitignorePath, \"utf8\");\n    if (content !== \"\" && !content.endsWith(\"\\n\")) {\n      content += \"\\n\";\n    }\n\n    content += `${cacheFile}\\n`;\n    fs.writeFileSync(gitignorePath, content);\n  }\n}\n\nfunction findCurrentProjectRoot() {\n  let currentDir = process.cwd();\n  while (currentDir !== path.parse(currentDir).root) {\n    const gitDirPath = path.join(currentDir, \".git\");\n    if (fs.existsSync(gitDirPath) && fs.lstatSync(gitDirPath).isDirectory()) {\n      return currentDir;\n    }\n    currentDir = path.dirname(currentDir);\n  }\n  return null;\n}\n","import { checkbox, confirm } from \"@inquirer/prompts\";\nimport fs from \"fs\";\nimport { Ora } from \"ora\";\nimport path from \"path\";\n\ntype Platform = \"github\" | \"bitbucket\" | \"gitlab\";\n\nconst platforms: Platform[] = [\"github\", \"bitbucket\", \"gitlab\"];\n\nexport default async function initCICD(spinner: Ora) {\n  const initializers = getPlatformInitializers(spinner);\n\n  const init = await confirm({\n    message: \"Would you like to use Lingo.dev in your CI/CD?\",\n  });\n\n  if (!init) {\n    spinner.warn(\n      \"CI/CD not initialized. To set it up later, see docs: https://lingo.dev/ci\",\n    );\n    return;\n  }\n\n  const selectedPlatforms: Platform[] = await checkbox({\n    message: \"Please select CI/CD platform(s) you want to use:\",\n    choices: platforms.map((platform) => ({\n      name: initializers[platform].name,\n      value: platform,\n      checked: initializers[platform].isEnabled(),\n    })),\n  });\n\n  for (const platform of selectedPlatforms) {\n    await initializers[platform].init();\n  }\n}\n\nfunction getPlatformInitializers(spinner: Ora) {\n  return {\n    github: makeGithubInitializer(spinner),\n    bitbucket: makeBitbucketInitializer(spinner),\n    gitlab: makeGitlabInitializer(spinner),\n  };\n}\n\ntype PlatformConfig = {\n  name: string;\n  checkPath: string;\n  ciConfigPath: string;\n  ciConfigContent: string;\n};\n\nfunction makePlatformInitializer(config: PlatformConfig, spinner: Ora) {\n  return {\n    name: config.name,\n    isEnabled: () => {\n      const filePath = path.join(process.cwd(), config.checkPath);\n      return fs.existsSync(filePath);\n    },\n    init: async () => {\n      const filePath = path.join(process.cwd(), config.ciConfigPath);\n      const dirPath = path.dirname(filePath);\n      if (!fs.existsSync(dirPath)) {\n        fs.mkdirSync(dirPath, { recursive: true });\n      }\n      let canWrite = true;\n      if (fs.existsSync(filePath)) {\n        canWrite = await confirm({\n          message: `File ${filePath} already exists. Do you want to overwrite it?`,\n          default: false,\n        });\n      }\n      if (canWrite) {\n        fs.writeFileSync(filePath, config.ciConfigContent);\n        spinner.succeed(`CI/CD initialized for ${config.name}`);\n      } else {\n        spinner.warn(`CI/CD not initialized for ${config.name}`);\n      }\n    },\n  };\n}\n\nfunction makeGithubInitializer(spinner: Ora) {\n  return makePlatformInitializer(\n    {\n      name: \"GitHub Action\",\n      checkPath: \".github\",\n      ciConfigPath: \".github/workflows/i18n.yml\",\n      ciConfigContent: `name: Lingo.dev i18n\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  i18n:\n    name: Run i18n\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: lingodotdev/lingo.dev@main\n        with:\n          api-key: \\${{ secrets.LINGODOTDEV_API_KEY }}\n`,\n    },\n    spinner,\n  );\n}\n\nfunction makeBitbucketInitializer(spinner: Ora) {\n  return makePlatformInitializer(\n    {\n      name: \"Bitbucket Pipeline\",\n      checkPath: \"bitbucket-pipelines.yml\",\n      ciConfigPath: \"bitbucket-pipelines.yml\",\n      ciConfigContent: `pipelines:\n  branches:\n    main:\n      - step:\n          name: Run i18n\n          script:\n            - pipe: lingodotdev/lingo.dev:main`,\n    },\n    spinner,\n  );\n}\n\nfunction makeGitlabInitializer(spinner: Ora) {\n  return makePlatformInitializer(\n    {\n      name: \"Gitlab CI\",\n      checkPath: \".gitlab-ci.yml\",\n      ciConfigPath: \".gitlab-ci.yml\",\n      ciConfigContent: `lingodotdev:\n  image: lingodotdev/ci-action:latest\n  script:\n    - echo \"Done\"\n`,\n    },\n    spinner,\n  );\n}\n","import { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport configCmd from \"./config\";\nimport localeCmd from \"./locale\";\nimport filesCmd from \"./files\";\nimport lockedKeysCmd from \"./locked-keys\";\nimport ignoredKeysCmd from \"./ignored-keys\";\n\nexport default new Command()\n  .command(\"show\")\n  .description(\"Display configuration, locales, and file paths\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .addCommand(configCmd)\n  .addCommand(localeCmd)\n  .addCommand(filesCmd)\n  .addCommand(lockedKeysCmd)\n  .addCommand(ignoredKeysCmd);\n","import { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { defaultConfig } from \"@lingo.dev/_spec\";\n\nexport default new Command()\n  .command(\"config\")\n  .description(\"Print effective i18n.json after merging with defaults\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (options) => {\n    const fileConfig = loadReplexicaFileConfig();\n    const config = _.merge({}, defaultConfig, fileConfig);\n\n    console.log(JSON.stringify(config, null, 2));\n  });\n\nfunction loadReplexicaFileConfig(): any {\n  const replexicaConfigPath = path.resolve(process.cwd(), \"i18n.json\");\n  const fileExists = fs.existsSync(replexicaConfigPath);\n  if (!fileExists) {\n    return undefined;\n  }\n\n  const fileContent = fs.readFileSync(replexicaConfigPath, \"utf-8\");\n  const replexicaFileConfig = JSON.parse(fileContent);\n  return replexicaFileConfig;\n}\n","import { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport Z from \"zod\";\nimport Ora from \"ora\";\nimport { localeCodes } from \"@lingo.dev/_spec\";\nimport { CLIError } from \"../../utils/errors\";\n\nexport default new Command()\n  .command(\"locale\")\n  .description(\"List supported locale codes\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  // argument can be equal either \"sources\" or \"targets\"\n  .argument(\n    \"<type>\",\n    'Type of locales to show: \"sources\" or \"targets\" - both show the full supported locale list',\n  )\n  .action(async (type) => {\n    const ora = Ora();\n    try {\n      switch (type) {\n        default:\n          throw new CLIError({\n            message: `Invalid type: ${type}`,\n            docUrl: \"invalidType\",\n          });\n        case \"sources\":\n          localeCodes.forEach((locale) => console.log(locale));\n          break;\n        case \"targets\":\n          localeCodes.forEach((locale) => console.log(locale));\n          break;\n      }\n    } catch (error: any) {\n      ora.fail(error.message);\n      process.exit(1);\n    }\n  });\n","import { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport Ora from \"ora\";\nimport { getConfig } from \"../../utils/config\";\nimport { CLIError } from \"../../utils/errors\";\nimport { getBuckets } from \"../../utils/buckets\";\nimport { resolveOverriddenLocale } from \"@lingo.dev/_spec\";\n\nexport default new Command()\n  .command(\"files\")\n  .description(\n    \"Expand each bucket's path pattern into concrete source and target file paths\",\n  )\n  .option(\n    \"--source\",\n    \"Only list the source locale variant for each path pattern\",\n  )\n  .option(\n    \"--target\",\n    \"Only list the target locale variants for each configured locale\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (type) => {\n    const ora = Ora();\n    try {\n      try {\n        const i18nConfig = await getConfig();\n\n        if (!i18nConfig) {\n          throw new CLIError({\n            message:\n              \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n            docUrl: \"i18nNotFound\",\n          });\n        }\n\n        const buckets = getBuckets(i18nConfig);\n        for (const bucket of buckets) {\n          for (const bucketConfig of bucket.paths) {\n            const sourceLocale = resolveOverriddenLocale(\n              i18nConfig.locale.source,\n              bucketConfig.delimiter,\n            );\n            const sourcePath = bucketConfig.pathPattern.replace(\n              /\\[locale\\]/g,\n              sourceLocale,\n            );\n            const targetPaths = i18nConfig.locale.targets.map(\n              (_targetLocale) => {\n                const targetLocale = resolveOverriddenLocale(\n                  _targetLocale,\n                  bucketConfig.delimiter,\n                );\n                return bucketConfig.pathPattern.replace(\n                  /\\[locale\\]/g,\n                  targetLocale,\n                );\n              },\n            );\n\n            const result: string[] = [];\n            if (!type.source && !type.target) {\n              result.push(sourcePath, ...targetPaths);\n            } else if (type.source) {\n              result.push(sourcePath);\n            } else if (type.target) {\n              result.push(...targetPaths);\n            }\n\n            result.forEach((path) => {\n              console.log(path);\n            });\n          }\n        }\n      } catch (error: any) {\n        throw new CLIError({\n          message: `Failed to expand placeholdered globs: ${error.message}`,\n          docUrl: \"placeHolderFailed\",\n        });\n      }\n    } catch (error: any) {\n      ora.fail(error.message);\n      process.exit(1);\n    }\n  });\n","import _ from \"lodash\";\nimport path from \"path\";\nimport { glob } from \"glob\";\nimport { CLIError } from \"./errors\";\nimport {\n  I18nConfig,\n  resolveOverriddenLocale,\n  BucketItem,\n  LocaleDelimiter,\n} from \"@lingo.dev/_spec\";\nimport { bucketTypeSchema } from \"@lingo.dev/_spec\";\nimport Z from \"zod\";\n\ntype BucketConfig = {\n  type: Z.infer<typeof bucketTypeSchema>;\n  paths: Array<{ pathPattern: string; delimiter?: LocaleDelimiter }>;\n  injectLocale?: string[];\n  lockedKeys?: string[];\n  lockedPatterns?: string[];\n  ignoredKeys?: string[];\n};\n\nexport function getBuckets(i18nConfig: I18nConfig) {\n  const result = Object.entries(i18nConfig.buckets).map(\n    ([bucketType, bucketEntry]) => {\n      const includeItems = bucketEntry.include.map((item) =>\n        resolveBucketItem(item),\n      );\n      const excludeItems = bucketEntry.exclude?.map((item) =>\n        resolveBucketItem(item),\n      );\n      const config: BucketConfig = {\n        type: bucketType as Z.infer<typeof bucketTypeSchema>,\n        paths: extractPathPatterns(\n          i18nConfig.locale.source,\n          includeItems,\n          excludeItems,\n        ),\n      };\n      if (bucketEntry.injectLocale) {\n        config.injectLocale = bucketEntry.injectLocale;\n      }\n      if (bucketEntry.lockedKeys) {\n        config.lockedKeys = bucketEntry.lockedKeys;\n      }\n      if (bucketEntry.lockedPatterns) {\n        config.lockedPatterns = bucketEntry.lockedPatterns;\n      }\n      if (bucketEntry.ignoredKeys) {\n        config.ignoredKeys = bucketEntry.ignoredKeys;\n      }\n      return config;\n    },\n  );\n\n  return result;\n}\n\nfunction extractPathPatterns(\n  sourceLocale: string,\n  include: BucketItem[],\n  exclude?: BucketItem[],\n) {\n  const includedPatterns = include.flatMap((pattern) =>\n    expandPlaceholderedGlob(\n      pattern.path,\n      resolveOverriddenLocale(sourceLocale, pattern.delimiter),\n    ).map((pathPattern) => ({\n      pathPattern,\n      delimiter: pattern.delimiter,\n    })),\n  );\n  const excludedPatterns = exclude?.flatMap((pattern) =>\n    expandPlaceholderedGlob(\n      pattern.path,\n      resolveOverriddenLocale(sourceLocale, pattern.delimiter),\n    ).map((pathPattern) => ({\n      pathPattern,\n      delimiter: pattern.delimiter,\n    })),\n  );\n  const result = _.differenceBy(\n    includedPatterns,\n    excludedPatterns ?? [],\n    (item) => item.pathPattern,\n  );\n  return result;\n}\n\n// Windows path normalization helper function\nfunction normalizePath(filepath: string): string {\n  const normalized = path.normalize(filepath);\n  // Ensure case consistency on Windows\n  return process.platform === \"win32\" ? normalized.toLowerCase() : normalized;\n}\n\n// Path expansion\nfunction expandPlaceholderedGlob(\n  _pathPattern: string,\n  sourceLocale: string,\n): string[] {\n  const absolutePathPattern = path.resolve(_pathPattern);\n  const pathPattern = normalizePath(\n    path.relative(process.cwd(), absolutePathPattern),\n  );\n  if (pathPattern.startsWith(\"..\")) {\n    throw new CLIError({\n      message: `Invalid path pattern: ${pathPattern}. Path pattern must be within the current working directory.`,\n      docUrl: \"invalidPathPattern\",\n    });\n  }\n\n  // Throw error if pathPattern contains \"**\" ‚Äì we don't support recursive path patterns\n  if (pathPattern.includes(\"**\")) {\n    throw new CLIError({\n      message: `Invalid path pattern: ${pathPattern}. Recursive path patterns are not supported.`,\n      docUrl: \"invalidPathPattern\",\n    });\n  }\n\n  // Break down path pattern into parts\n  const pathPatternChunks = pathPattern.split(path.sep);\n  // Find the index of the segment containing \"[locale]\"\n  const localeSegmentIndexes = pathPatternChunks.reduce(\n    (indexes, segment, index) => {\n      if (segment.includes(\"[locale]\")) {\n        indexes.push(index);\n      }\n      return indexes;\n    },\n    [] as number[],\n  );\n  // substitute [locale] in pathPattern with sourceLocale\n  const sourcePathPattern = pathPattern.replaceAll(/\\[locale\\]/g, sourceLocale);\n  // Convert to Unix-style for Windows compatibility\n  const unixStylePattern = sourcePathPattern.replace(/\\\\/g, \"/\");\n\n  // get all files that match the sourcePathPattern\n  const sourcePaths = glob\n    .sync(unixStylePattern, {\n      follow: true,\n      withFileTypes: true,\n      windowsPathsNoEscape: true, // Windows path support\n    })\n    .filter((file) => file.isFile() || file.isSymbolicLink())\n    .map((file) => file.fullpath())\n    .map((fullpath) => normalizePath(path.relative(process.cwd(), fullpath)));\n\n  // transform each source file path back to [locale] placeholder paths\n  const placeholderedPaths = sourcePaths.map((sourcePath) => {\n    // Normalize path returned by glob for platform compatibility\n    const normalizedSourcePath = normalizePath(\n      sourcePath.replace(/\\//g, path.sep),\n    );\n    const sourcePathChunks = normalizedSourcePath.split(path.sep);\n    localeSegmentIndexes.forEach((localeSegmentIndex) => {\n      // Find the position of the \"[locale]\" placeholder within the segment\n      const pathPatternChunk = pathPatternChunks[localeSegmentIndex];\n      const sourcePathChunk = sourcePathChunks[localeSegmentIndex];\n      const regexp = new RegExp(\n        \"(\" +\n          pathPatternChunk\n            .replaceAll(\".\", \"\\\\.\")\n            .replaceAll(\"*\", \".*\")\n            .replace(\"[locale]\", `)${sourceLocale}(`) +\n          \")\",\n      );\n      const match = sourcePathChunk.match(regexp);\n      if (match) {\n        const [, prefix, suffix] = match;\n        const placeholderedSegment = prefix + \"[locale]\" + suffix;\n        sourcePathChunks[localeSegmentIndex] = placeholderedSegment;\n      }\n    });\n    const placeholderedPath = sourcePathChunks.join(path.sep);\n    return placeholderedPath;\n  });\n  // return the placeholdered paths\n  return placeholderedPaths;\n}\n\nfunction resolveBucketItem(bucketItem: string | BucketItem): BucketItem {\n  if (typeof bucketItem === \"string\") {\n    return { path: bucketItem, delimiter: null };\n  }\n  return bucketItem;\n}\n","import { Command } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport { getConfig } from \"../../utils/config\";\nimport { CLIError } from \"../../utils/errors\";\nimport { getBuckets } from \"../../utils/buckets\";\nimport { executeKeyCommand } from \"./_shared-key-command\";\n\nexport default new Command()\n  .command(\"locked-keys\")\n  .description(\n    \"Show which key-value pairs in source files match lockedKeys patterns\",\n  )\n  .option(\"--bucket <name>\", \"Only show locked keys for a specific bucket\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (options) => {\n    const ora = Ora();\n    try {\n      const i18nConfig = await getConfig();\n\n      if (!i18nConfig) {\n        throw new CLIError({\n          message:\n            \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n          docUrl: \"i18nNotFound\",\n        });\n      }\n\n      const buckets = getBuckets(i18nConfig);\n\n      await executeKeyCommand(i18nConfig, buckets, options, {\n        filterType: \"lockedKeys\",\n        displayName: \"locked\",\n      });\n    } catch (error: any) {\n      ora.fail(error.message);\n      process.exit(1);\n    }\n  });\n","import { resolveOverriddenLocale, I18nConfig } from \"@lingo.dev/_spec\";\nimport createBucketLoader from \"../../loaders\";\nimport {\n  matchesKeyPattern,\n  formatDisplayValue,\n} from \"../../utils/key-matching\";\n\nexport type KeyFilterType = \"lockedKeys\" | \"ignoredKeys\";\n\nexport interface KeyCommandOptions {\n  bucket?: string;\n}\n\nexport interface KeyCommandConfig {\n  filterType: KeyFilterType;\n  displayName: string; // e.g., \"locked\", \"ignored\"\n}\n\nexport async function executeKeyCommand(\n  i18nConfig: I18nConfig,\n  buckets: any[],\n  options: KeyCommandOptions,\n  config: KeyCommandConfig,\n): Promise<void> {\n  let hasAnyKeys = false;\n\n  for (const bucket of buckets) {\n    // Filter by bucket name if specified\n    if (options.bucket && bucket.type !== options.bucket) {\n      continue;\n    }\n\n    // Skip buckets without the specified key patterns\n    const keyPatterns = bucket[config.filterType];\n    if (!keyPatterns || keyPatterns.length === 0) {\n      continue;\n    }\n\n    hasAnyKeys = true;\n\n    console.log(`\\nBucket: ${bucket.type}`);\n    console.log(\n      `${capitalize(config.displayName)} key patterns: ${keyPatterns.join(\", \")}`,\n    );\n\n    for (const bucketConfig of bucket.paths) {\n      const sourceLocale = resolveOverriddenLocale(\n        i18nConfig.locale.source,\n        bucketConfig.delimiter,\n      );\n      const sourcePath = bucketConfig.pathPattern.replace(\n        /\\[locale\\]/g,\n        sourceLocale,\n      );\n\n      try {\n        // Create a loader to read the source file\n        const loader = createBucketLoader(\n          bucket.type,\n          bucketConfig.pathPattern,\n          {\n            defaultLocale: sourceLocale,\n            injectLocale: bucket.injectLocale,\n          },\n          [], // Don't apply any filtering when reading\n          [],\n          [],\n        );\n        loader.setDefaultLocale(sourceLocale);\n\n        // Read the source file content\n        const data = await loader.pull(sourceLocale);\n\n        if (!data || Object.keys(data).length === 0) {\n          continue;\n        }\n\n        // Filter keys that match the patterns\n        const matchedEntries = Object.entries(data).filter(([key]) =>\n          matchesKeyPattern(key, keyPatterns),\n        );\n\n        if (matchedEntries.length > 0) {\n          console.log(`\\nMatches in ${sourcePath}:`);\n          for (const [key, value] of matchedEntries) {\n            const displayValue = formatDisplayValue(value);\n            console.log(`  - ${key}: ${displayValue}`);\n          }\n          console.log(\n            `Total: ${matchedEntries.length} ${config.displayName} key(s)`,\n          );\n        }\n      } catch (error: any) {\n        console.error(`  Error reading ${sourcePath}: ${error.message}`);\n      }\n    }\n  }\n\n  if (!hasAnyKeys) {\n    if (options.bucket) {\n      console.log(\n        `No ${config.displayName} keys configured for bucket: ${options.bucket}`,\n      );\n    } else {\n      console.log(`No ${config.displayName} keys configured in any bucket.`);\n    }\n  }\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import { ILoader, ILoaderDefinition } from \"./_types\";\n\nexport function composeLoaders(\n  ...loaders: ILoader<any, any, any>[]\n): ILoader<any, any> {\n  return {\n    init: async () => {\n      for (const loader of loaders) {\n        await loader.init?.();\n      }\n    },\n    setDefaultLocale(locale: string) {\n      for (const loader of loaders) {\n        loader.setDefaultLocale?.(locale);\n      }\n      return this;\n    },\n    pull: async (locale, input) => {\n      let result: any = input;\n      for (let i = 0; i < loaders.length; i++) {\n        result = await loaders[i].pull(locale, result);\n      }\n      return result;\n    },\n    push: async (locale, data) => {\n      let result: any = data;\n      for (let i = loaders.length - 1; i >= 0; i--) {\n        result = await loaders[i].push(locale, result);\n      }\n      return result;\n    },\n    pullHints: async (originalInput) => {\n      let result: any = originalInput;\n      for (let i = 0; i < loaders.length; i++) {\n        const subResult = await loaders[i].pullHints?.(result);\n        if (subResult) {\n          result = subResult;\n        }\n      }\n      return result;\n    },\n  };\n}\n\nexport function createLoader<I, O, C>(\n  lDefinition: ILoaderDefinition<I, O, C>,\n): ILoader<I, O, C> {\n  const state = {\n    defaultLocale: undefined as string | undefined,\n    originalInput: undefined as I | undefined | null,\n    pullInput: undefined as I | undefined | null,\n    pullOutput: undefined as O | undefined | null,\n    initCtx: undefined as C | undefined,\n  };\n  return {\n    async init() {\n      if (state.initCtx) {\n        return state.initCtx;\n      }\n      state.initCtx = await lDefinition.init?.();\n      return state.initCtx as C;\n    },\n    setDefaultLocale(locale) {\n      if (state.defaultLocale) {\n        throw new Error(\"Default locale already set\");\n      }\n      state.defaultLocale = locale;\n      return this;\n    },\n    async pullHints() {\n      return lDefinition.pullHints?.(state.originalInput!);\n    },\n    async pull(locale, input) {\n      if (!state.defaultLocale) {\n        throw new Error(\"Default locale not set\");\n      }\n      if (state.originalInput === undefined && locale !== state.defaultLocale) {\n        throw new Error(\"The first pull must be for the default locale\");\n      }\n      if (locale === state.defaultLocale) {\n        state.originalInput = input || null;\n      }\n\n      state.pullInput = input;\n      const result = await lDefinition.pull(\n        locale,\n        input,\n        state.initCtx!,\n        state.defaultLocale,\n        state.originalInput!,\n      );\n      state.pullOutput = result;\n\n      return result;\n    },\n    async push(locale, data) {\n      if (!state.defaultLocale) {\n        throw new Error(\"Default locale not set\");\n      }\n      if (state.originalInput === undefined) {\n        throw new Error(\"Cannot push data without pulling first\");\n      }\n\n      const pushResult = await lDefinition.push(\n        locale,\n        data,\n        state.originalInput,\n        state.defaultLocale,\n        state.pullInput!,\n        state.pullOutput!,\n      );\n      return pushResult;\n    },\n  };\n}\n","import { jsonrepair } from \"jsonrepair\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createJsonLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const jsonString = input || \"{}\";\n      let result: Record<string, any>;\n      try {\n        result = JSON.parse(jsonString);\n      } catch (error) {\n        result = JSON.parse(jsonrepair(jsonString));\n      }\n      return result;\n    },\n    push: async (locale, data) => {\n      const serializedData = JSON.stringify(data, null, 2);\n      return serializedData;\n    },\n  });\n}\n","import JSON5 from \"json5\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createJson5Loader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const json5String = input || \"{}\";\n      return JSON5.parse(json5String);\n    },\n    push: async (locale, data) => {\n      const serializedData = JSON5.stringify(data, null, 2);\n      return serializedData;\n    },\n  });\n}\n","import { parse, ParseError } from \"jsonc-parser\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\ninterface CommentInfo {\n  hint?: string;\n  [key: string]: any;\n}\n\nfunction extractCommentsFromJsonc(jsoncString: string): Record<string, any> {\n  const lines = jsoncString.split(\"\\n\");\n  const comments: Record<string, any> = {};\n\n  // Parse to validate structure\n  const errors: ParseError[] = [];\n  const result = parse(jsoncString, errors, {\n    allowTrailingComma: true,\n    disallowComments: false,\n    allowEmptyContent: true,\n  });\n\n  if (errors.length > 0) {\n    return {};\n  }\n\n  // Track nesting context\n  const contextStack: Array<{ key: string; isArray: boolean }> = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) continue;\n\n    // Handle different comment types\n    const commentData = extractCommentFromLine(line, lines, i);\n    if (commentData.hint) {\n      let keyInfo;\n\n      if (commentData.isInline) {\n        // For inline comments, extract key from the same line\n        const keyMatch = line.match(/^\\s*[\"']?([^\"':,\\s]+)[\"']?\\s*:/);\n        if (keyMatch) {\n          const key = keyMatch[1];\n          const path = contextStack.map((ctx) => ctx.key).filter(Boolean);\n          keyInfo = { key, path };\n        }\n      } else {\n        // For standalone comments, find the next key\n        keyInfo = findAssociatedKey(lines, commentData.lineIndex, contextStack);\n      }\n\n      if (keyInfo && keyInfo.key) {\n        setCommentAtPath(comments, keyInfo.path, keyInfo.key, commentData.hint);\n      }\n\n      // Skip processed lines for multi-line comments\n      i = commentData.endIndex;\n      continue;\n    }\n\n    // Update context for object/array nesting\n    updateContext(contextStack, line, result);\n  }\n\n  return comments;\n}\n\nfunction extractCommentFromLine(\n  line: string,\n  lines: string[],\n  lineIndex: number,\n): {\n  hint: string | null;\n  lineIndex: number;\n  endIndex: number;\n  isInline: boolean;\n} {\n  const trimmed = line.trim();\n\n  // Single-line comment (standalone)\n  if (trimmed.startsWith(\"//\")) {\n    const hint = trimmed.replace(/^\\/\\/\\s*/, \"\").trim();\n    return { hint, lineIndex, endIndex: lineIndex, isInline: false };\n  }\n\n  // Block comment (standalone or multi-line)\n  if (trimmed.startsWith(\"/*\")) {\n    const blockResult = extractBlockComment(lines, lineIndex);\n    return { ...blockResult, isInline: false };\n  }\n\n  // Inline comments (after JSON content)\n  // Handle single-line inline comments\n  const singleInlineMatch = line.match(/^(.+?)\\s*\\/\\/\\s*(.+)$/);\n  if (singleInlineMatch && singleInlineMatch[1].includes(\":\")) {\n    const hint = singleInlineMatch[2].trim();\n    return { hint, lineIndex, endIndex: lineIndex, isInline: true };\n  }\n\n  // Handle block inline comments\n  const blockInlineMatch = line.match(/^(.+?)\\s*\\/\\*\\s*(.*?)\\s*\\*\\/.*$/);\n  if (blockInlineMatch && blockInlineMatch[1].includes(\":\")) {\n    const hint = blockInlineMatch[2].trim();\n    return { hint, lineIndex, endIndex: lineIndex, isInline: true };\n  }\n\n  return { hint: null, lineIndex, endIndex: lineIndex, isInline: false };\n}\n\nfunction extractBlockComment(\n  lines: string[],\n  startIndex: number,\n): { hint: string | null; lineIndex: number; endIndex: number } {\n  const startLine = lines[startIndex];\n\n  // Single-line block comment\n  const singleMatch = startLine.match(/\\/\\*\\s*(.*?)\\s*\\*\\//);\n  if (singleMatch) {\n    return {\n      hint: singleMatch[1].trim(),\n      lineIndex: startIndex,\n      endIndex: startIndex,\n    };\n  }\n\n  // Multi-line block comment\n  const commentParts: string[] = [];\n  let endIndex = startIndex;\n\n  // Extract content from first line\n  const firstContent = startLine.replace(/.*?\\/\\*\\s*/, \"\").trim();\n  if (firstContent && !firstContent.includes(\"*/\")) {\n    commentParts.push(firstContent);\n  }\n\n  // Process subsequent lines\n  for (let i = startIndex + 1; i < lines.length; i++) {\n    const line = lines[i];\n    endIndex = i;\n\n    if (line.includes(\"*/\")) {\n      const lastContent = line\n        .replace(/\\*\\/.*$/, \"\")\n        .replace(/^\\s*\\*?\\s*/, \"\")\n        .trim();\n      if (lastContent) {\n        commentParts.push(lastContent);\n      }\n      break;\n    } else {\n      const content = line.replace(/^\\s*\\*?\\s*/, \"\").trim();\n      if (content) {\n        commentParts.push(content);\n      }\n    }\n  }\n\n  return {\n    hint: commentParts.join(\" \").trim() || null,\n    lineIndex: startIndex,\n    endIndex,\n  };\n}\n\nfunction findAssociatedKey(\n  lines: string[],\n  commentLineIndex: number,\n  contextStack: Array<{ key: string; isArray: boolean }>,\n): { key: string | null; path: string[] } {\n  // Look for the next key after the comment\n  for (let i = commentLineIndex + 1; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    if (\n      !line ||\n      line.startsWith(\"//\") ||\n      line.startsWith(\"/*\") ||\n      line === \"{\" ||\n      line === \"}\"\n    ) {\n      continue;\n    }\n\n    // Extract key from line\n    const keyMatch = line.match(/^\\s*[\"']?([^\"':,\\s]+)[\"']?\\s*:/);\n    if (keyMatch) {\n      const key = keyMatch[1];\n      const path = contextStack.map((ctx) => ctx.key).filter(Boolean);\n      return { key, path };\n    }\n  }\n\n  return { key: null, path: [] };\n}\n\nfunction updateContext(\n  contextStack: Array<{ key: string; isArray: boolean }>,\n  line: string,\n  parsedJson: any,\n): void {\n  // This is a simplified context tracking - in a full implementation,\n  // you'd want more sophisticated AST-based tracking\n  const openBraces = (line.match(/\\{/g) || []).length;\n  const closeBraces = (line.match(/\\}/g) || []).length;\n\n  if (openBraces > closeBraces) {\n    // Extract the key that's opening this object\n    const keyMatch = line.match(/^\\s*[\"']?([^\"':,\\s]+)[\"']?\\s*:\\s*\\{/);\n    if (keyMatch) {\n      contextStack.push({ key: keyMatch[1], isArray: false });\n    }\n  } else if (closeBraces > openBraces) {\n    // Pop context when closing braces\n    for (let i = 0; i < closeBraces - openBraces; i++) {\n      contextStack.pop();\n    }\n  }\n}\n\nfunction setCommentAtPath(\n  comments: Record<string, any>,\n  path: string[],\n  key: string,\n  hint: string,\n): void {\n  let current = comments;\n\n  // Navigate to the correct nested location\n  for (const pathKey of path) {\n    if (!current[pathKey]) {\n      current[pathKey] = {};\n    }\n    current = current[pathKey];\n  }\n\n  // Set the hint for the key\n  if (!current[key]) {\n    current[key] = {};\n  }\n\n  if (typeof current[key] === \"object\" && current[key] !== null) {\n    current[key].hint = hint;\n  } else {\n    current[key] = { hint };\n  }\n}\n\nexport default function createJsoncLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const jsoncString = input || \"{}\";\n      const errors: ParseError[] = [];\n      const result = parse(jsoncString, errors, {\n        allowTrailingComma: true,\n        disallowComments: false,\n        allowEmptyContent: true,\n      });\n\n      if (errors.length > 0) {\n        throw new Error(`Failed to parse JSONC: ${errors[0].error}`);\n      }\n\n      return result || {};\n    },\n    push: async (locale, data) => {\n      // JSONC parser's stringify preserves formatting but doesn't add comments\n      // We'll use standard JSON.stringify with pretty formatting for output\n      const serializedData = JSON.stringify(data, null, 2);\n      return serializedData;\n    },\n    pullHints: async (input) => {\n      if (!input || typeof input !== \"string\") {\n        return {};\n      }\n\n      try {\n        return extractCommentsFromJsonc(input);\n      } catch (error) {\n        console.warn(\"Failed to extract comments from JSONC:\", error);\n        return {};\n      }\n    },\n  });\n}\n","import { flatten, unflatten } from \"flat\";\nimport { ILoader } from \"./_types\";\nimport { composeLoaders, createLoader } from \"./_utils\";\nimport _ from \"lodash\";\n\nexport const OBJECT_NUMERIC_KEY_PREFIX = \"__lingodotdev__obj__\";\n\n/**\n * Options for configuring the flat loader behavior\n */\nexport interface FlatLoaderOptions {\n  /**\n   * Optional predicate to determine if an object should be preserved (not flattened)\n   * Use this to prevent flattening of special objects like ICU plurals\n   */\n  shouldPreserveObject?: (value: any) => boolean;\n}\n\n/**\n * Creates a flat loader that flattens nested objects into dot-notation keys\n *\n * @param options - Configuration options for the loader\n * @param options.shouldPreserveObject - Predicate to identify objects that should not be flattened\n */\nexport default function createFlatLoader(options?: FlatLoaderOptions) {\n  const composedLoader = composeLoaders(\n    createDenormalizeLoader(options),\n    createNormalizeLoader(),\n  );\n\n  return {\n    ...composedLoader,\n    pullHints: async (input: Record<string, any>) => {\n      if (!input || typeof input !== \"object\") {\n        return {};\n      }\n      return flattenHints(input);\n    },\n  };\n}\n\ntype DenormalizeResult = {\n  denormalized: Record<string, string>;\n  keysMap: Record<string, string>;\n};\n\nfunction createDenormalizeLoader(\n  options?: FlatLoaderOptions,\n): ILoader<Record<string, any>, DenormalizeResult> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const inputDenormalized = denormalizeObjectKeys(input || {});\n\n      // First pass: extract preserved objects before flattening (if predicate provided)\n      const preservedObjects: Record<string, any> = {};\n      const nonPreservedInput: Record<string, any> = {};\n\n      for (const [key, value] of Object.entries(inputDenormalized)) {\n        if (options?.shouldPreserveObject?.(value)) {\n          preservedObjects[key] = value;\n        } else {\n          nonPreservedInput[key] = value;\n        }\n      }\n\n      // Flatten only non-preserved objects\n      const flattened: Record<string, string> = flatten(nonPreservedInput, {\n        delimiter: \"/\",\n        transformKey(key) {\n          return encodeURIComponent(String(key));\n        },\n      });\n\n      // Merge preserved objects back (they stay as objects, not flattened)\n      // BUT: encode their keys too!\n      const denormalized: Record<string, any> = { ...flattened };\n\n      for (const [key, value] of Object.entries(preservedObjects)) {\n        const encodedKey = encodeURIComponent(String(key));\n        denormalized[encodedKey] = value;\n      }\n\n      const keysMap = buildDenormalizedKeysMap(denormalized);\n      return { denormalized, keysMap };\n    },\n    push: async (locale, { denormalized }) => {\n      const normalized = normalizeObjectKeys(denormalized);\n      return normalized;\n    },\n  });\n}\n\nfunction createNormalizeLoader(): ILoader<\n  DenormalizeResult,\n  Record<string, string>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const normalized = normalizeObjectKeys(input.denormalized);\n      return normalized;\n    },\n    push: async (locale, data, originalInput) => {\n      const keysMap = originalInput?.keysMap ?? {};\n      const input = mapDenormalizedKeys(data, keysMap);\n      const denormalized: Record<string, any> = unflatten(input, {\n        delimiter: \"/\",\n        transformKey(key) {\n          return decodeURIComponent(String(key));\n        },\n      });\n      return { denormalized, keysMap: keysMap || {} };\n    },\n  });\n}\n\nexport function buildDenormalizedKeysMap(obj: Record<string, string>) {\n  if (!obj) return {};\n\n  return Object.keys(obj).reduce(\n    (acc, key) => {\n      if (key) {\n        const normalizedKey = `${key}`.replace(OBJECT_NUMERIC_KEY_PREFIX, \"\");\n        acc[normalizedKey] = key;\n      }\n      return acc;\n    },\n    {} as Record<string, string>,\n  );\n}\n\nexport function mapDenormalizedKeys(\n  obj: Record<string, any>,\n  denormalizedKeysMap: Record<string, string>,\n) {\n  return Object.keys(obj).reduce(\n    (acc, key) => {\n      const denormalizedKey = denormalizedKeysMap[key] ?? key;\n      acc[denormalizedKey] = obj[key];\n      return acc;\n    },\n    {} as Record<string, string>,\n  );\n}\n\nexport function denormalizeObjectKeys(\n  obj: Record<string, any>,\n): Record<string, any> {\n  if (_.isObject(obj) && !_.isArray(obj)) {\n    return _.transform(\n      obj,\n      (result, value, key) => {\n        const newKey = !isNaN(Number(key))\n          ? `${OBJECT_NUMERIC_KEY_PREFIX}${key}`\n          : key;\n        result[newKey] =\n          _.isObject(value) && !_.isDate(value)\n            ? denormalizeObjectKeys(value)\n            : value;\n      },\n      {} as Record<string, any>,\n    );\n  } else {\n    return obj;\n  }\n}\n\nexport function normalizeObjectKeys(\n  obj: Record<string, any>,\n): Record<string, any> {\n  if (_.isObject(obj) && !_.isArray(obj)) {\n    return _.transform(\n      obj,\n      (result, value, key) => {\n        const newKey = `${key}`.replace(OBJECT_NUMERIC_KEY_PREFIX, \"\");\n        result[newKey] =\n          _.isObject(value) && !_.isDate(value)\n            ? normalizeObjectKeys(value)\n            : value;\n      },\n      {} as Record<string, any>,\n    );\n  } else {\n    return obj;\n  }\n}\n\nfunction flattenHints(\n  obj: Record<string, any>,\n  parentHints: string[] = [],\n  parentPath: string = \"\",\n): Record<string, string[]> {\n  const result: Record<string, string[]> = {};\n\n  for (const [key, _value] of Object.entries(obj)) {\n    if (_.isObject(_value) && !_.isArray(_value)) {\n      const value = _value as Record<string, any>;\n      const currentHints = [...parentHints];\n      const currentPath = parentPath ? `${parentPath}/${key}` : key;\n\n      // Add this level's hint if it exists\n      if (value.hint && typeof value.hint === \"string\") {\n        currentHints.push(value.hint);\n      }\n\n      // Process nested objects (excluding the hint property)\n      const nestedObj = _.omit(value, \"hint\");\n\n      // If this is a leaf node (no nested objects), add to result\n      if (Object.keys(nestedObj).length === 0) {\n        if (currentHints.length > 0) {\n          result[currentPath] = currentHints;\n        }\n      } else {\n        // Recursively process nested objects\n        const nestedComments = flattenHints(\n          nestedObj,\n          currentHints,\n          currentPath,\n        );\n        Object.assign(result, nestedComments);\n      }\n    }\n  }\n\n  return result;\n}\n","import fs from \"fs/promises\";\nimport path from \"path\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createTextFileLoader(\n  pathPattern: string,\n): ILoader<void, string> {\n  return createLoader({\n    async pull(locale) {\n      const result = await readFileForLocale(pathPattern, locale);\n      const trimmedResult = result.trim();\n      return trimmedResult;\n    },\n    async push(locale, data, _, originalLocale) {\n      const draftPath = pathPattern.replaceAll(\"[locale]\", locale);\n      const finalPath = path.resolve(draftPath);\n\n      // Create parent directories if needed\n      const dirPath = path.dirname(finalPath);\n      await fs.mkdir(dirPath, { recursive: true });\n\n      const trimmedPayload = data.trim();\n\n      // Add trailing new line if needed\n      const trailingNewLine = await getTrailingNewLine(\n        pathPattern,\n        locale,\n        originalLocale,\n      );\n      let finalPayload = trimmedPayload + trailingNewLine;\n\n      await fs.writeFile(finalPath, finalPayload, {\n        encoding: \"utf-8\",\n        flag: \"w\",\n      });\n    },\n  });\n}\n\nasync function readFileForLocale(pathPattern: string, locale: string) {\n  const draftPath = pathPattern.replaceAll(\"[locale]\", locale);\n  const finalPath = path.resolve(draftPath);\n  const exists = await fs\n    .access(finalPath)\n    .then(() => true)\n    .catch(() => false);\n  if (!exists) {\n    return \"\";\n  }\n  return fs.readFile(finalPath, \"utf-8\");\n}\n\nasync function getTrailingNewLine(\n  pathPattern: string,\n  locale: string,\n  originalLocale: string,\n) {\n  let templateData = await readFileForLocale(pathPattern, locale);\n  if (!templateData) {\n    templateData = await readFileForLocale(pathPattern, originalLocale);\n  }\n\n  if (templateData?.match(/[\\r\\n]$/)) {\n    const ending = templateData?.includes(\"\\r\\n\")\n      ? \"\\r\\n\"\n      : templateData?.includes(\"\\r\")\n        ? \"\\r\"\n        : \"\\n\";\n    return ending;\n  }\n  return \"\";\n}\n","import YAML, { ToStringOptions } from \"yaml\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createYamlLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      return YAML.parse(input) || {};\n    },\n    async push(locale, payload, originalInput) {\n      return YAML.stringify(payload, {\n        lineWidth: -1,\n        defaultKeyType: getKeyType(originalInput),\n        defaultStringType: getStringType(originalInput),\n      });\n    },\n  });\n}\n\n// check if the yaml keys are using double quotes or single quotes\nfunction getKeyType(\n  yamlString: string | null,\n): ToStringOptions[\"defaultKeyType\"] {\n  if (yamlString) {\n    const lines = yamlString.split(\"\\n\");\n    const hasDoubleQuotes = lines.find((line) => {\n      return line.trim().startsWith('\"') && line.trim().match('\":');\n    });\n    if (hasDoubleQuotes) {\n      return \"QUOTE_DOUBLE\";\n    }\n  }\n  return \"PLAIN\";\n}\n\n// check if the yaml string values are using double quotes or single quotes\nfunction getStringType(\n  yamlString: string | null,\n): ToStringOptions[\"defaultStringType\"] {\n  if (yamlString) {\n    const lines = yamlString.split(\"\\n\");\n    const hasDoubleQuotes = lines.find((line) => {\n      const trimmedLine = line.trim();\n      return (\n        (trimmedLine.startsWith('\"') || trimmedLine.match(/:\\s*\"/)) &&\n        (trimmedLine.endsWith('\"') || trimmedLine.endsWith('\",'))\n      );\n    });\n    if (hasDoubleQuotes) {\n      return \"QUOTE_DOUBLE\";\n    }\n  }\n  return \"PLAIN\";\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createRootKeyLoader(\n  replaceAll = false,\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    async pull(locale, input) {\n      const result = input[locale];\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      const result = {\n        ...(replaceAll ? {} : originalInput),\n        [locale]: data,\n      };\n      return result;\n    },\n  });\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createFlutterLoader(): ILoader<\n  Record<string, any>,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      // skip all metadata (keys starting with @)\n      const result = _.pickBy(input, (value, key) => !_isMetadataKey(key));\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      // find all metadata keys in originalInput\n      const metadata = _.pickBy(originalInput, (value, key) =>\n        _isMetadataKey(key),\n      );\n      const result = _.merge({}, metadata, { \"@@locale\": locale }, data);\n      return result;\n    },\n  });\n}\n\nfunction _isMetadataKey(key: string) {\n  return key.startsWith(\"@\");\n}\n","import { createRequire } from \"node:module\";\nimport { parseStringPromise, type XmlDeclarationAttributes } from \"xml2js\";\nimport { ILoader } from \"./_types\";\nimport { CLIError } from \"../utils/errors\";\nimport { createLoader } from \"./_utils\";\n\ninterface SaxParser {\n  onopentag: (node: {\n    name: string;\n    attributes: Record<string, string>;\n  }) => void;\n  onclosetag: (name: string) => void;\n  ontext: (text: string) => void;\n  oncdata: (cdata: string) => void;\n  write(data: string): SaxParser;\n  close(): SaxParser;\n}\n\ninterface SaxModule {\n  parser(\n    strict: boolean,\n    options?: { trim?: boolean; normalize?: boolean; lowercase?: boolean },\n  ): SaxParser;\n}\n\nconst require = createRequire(import.meta.url);\nconst sax: SaxModule = require(\"sax\") as SaxModule;\n\nconst defaultAndroidResourcesXml = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n</resources>`;\n\ntype AndroidResourceType =\n  | \"string\"\n  | \"string-array\"\n  | \"plurals\"\n  | \"bool\"\n  | \"integer\";\n\ntype PrimitiveValue = boolean | number | string;\n\ntype ContentSegment =\n  | { kind: \"text\"; value: string }\n  | { kind: \"cdata\"; value: string };\n\ninterface TextualMeta {\n  segments: ContentSegment[];\n  hasCdata: boolean;\n}\n\ninterface ArrayItemMeta extends TextualMeta {\n  quantity?: string;\n}\n\ninterface StringResourceNode {\n  type: \"string\";\n  name: string;\n  translatable: boolean;\n  node: any;\n  meta: TextualMeta;\n}\n\ninterface StringArrayItemNode {\n  node: any;\n  meta: TextualMeta;\n}\n\ninterface StringArrayResourceNode {\n  type: \"string-array\";\n  name: string;\n  translatable: boolean;\n  node: any;\n  items: StringArrayItemNode[];\n}\n\ninterface PluralsItemNode {\n  node: any;\n  quantity: string;\n  meta: TextualMeta;\n}\n\ninterface PluralsResourceNode {\n  type: \"plurals\";\n  name: string;\n  translatable: boolean;\n  node: any;\n  items: PluralsItemNode[];\n}\n\ninterface BoolResourceNode {\n  type: \"bool\";\n  name: string;\n  translatable: boolean;\n  node: any;\n  meta: TextualMeta;\n}\n\ninterface IntegerResourceNode {\n  type: \"integer\";\n  name: string;\n  translatable: boolean;\n  node: any;\n  meta: TextualMeta;\n}\n\ntype AndroidResourceNode =\n  | StringResourceNode\n  | StringArrayResourceNode\n  | PluralsResourceNode\n  | BoolResourceNode\n  | IntegerResourceNode;\n\ninterface AndroidDocument {\n  resources: any;\n  resourceNodes: AndroidResourceNode[];\n}\n\ninterface XmlDeclarationOptions {\n  xmldec?: XmlDeclarationAttributes;\n  headless: boolean;\n}\n\nexport default function createAndroidLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      try {\n        if (!input) {\n          return {};\n        }\n\n        const document = await parseAndroidDocument(input);\n        return buildPullResult(document);\n      } catch (error) {\n        console.error(\"Error parsing Android resource file:\", error);\n        throw new CLIError({\n          message: \"Failed to parse Android resource file\",\n          docUrl: \"androidResouceError\",\n        });\n      }\n    },\n    async push(\n      locale,\n      payload,\n      originalInput,\n      originalLocale,\n      pullInput,\n      pullOutput,\n    ) {\n      try {\n        const selectedBase = selectBaseXml(\n          locale,\n          originalLocale,\n          pullInput,\n          originalInput,\n        );\n\n        const existingDocument = await parseAndroidDocument(selectedBase);\n        const sourceDocument = await parseAndroidDocument(originalInput);\n        const translatedDocument = buildTranslatedDocument(\n          payload,\n          existingDocument,\n          sourceDocument,\n        );\n\n        const referenceXml =\n          selectedBase || originalInput || defaultAndroidResourcesXml;\n        const declaration = resolveXmlDeclaration(referenceXml);\n\n        return buildAndroidXml(translatedDocument, declaration);\n      } catch (error) {\n        console.error(\"Error generating Android resource file:\", error);\n        throw new CLIError({\n          message: \"Failed to generate Android resource file\",\n          docUrl: \"androidResouceError\",\n        });\n      }\n    },\n  });\n}\n\nfunction resolveXmlDeclaration(xml: string | null): XmlDeclarationOptions {\n  if (!xml) {\n    const xmldec: XmlDeclarationAttributes = {\n      version: \"1.0\",\n      encoding: \"utf-8\",\n    };\n    return {\n      xmldec,\n      headless: false,\n    };\n  }\n\n  const match = xml.match(\n    /<\\?xml\\s+version=\"([^\"]+)\"(?:\\s+encoding=\"([^\"]+)\")?\\s*\\?>/,\n  );\n  if (match) {\n    const version = match[1] && match[1].trim().length > 0 ? match[1] : \"1.0\";\n    const encoding =\n      match[2] && match[2].trim().length > 0 ? match[2] : undefined;\n    const xmldec: XmlDeclarationAttributes = encoding\n      ? { version, encoding }\n      : { version };\n    return {\n      xmldec,\n      headless: false,\n    };\n  }\n\n  return { headless: true };\n}\n\nasync function parseAndroidDocument(\n  input?: string | null,\n): Promise<AndroidDocument> {\n  const xmlToParse =\n    input && input.trim().length > 0 ? input : defaultAndroidResourcesXml;\n\n  const parsed = await parseStringPromise(xmlToParse, {\n    explicitArray: true,\n    explicitChildren: true,\n    preserveChildrenOrder: true,\n    charsAsChildren: true,\n    includeWhiteChars: true,\n    mergeAttrs: false,\n    normalize: false,\n    normalizeTags: false,\n    trim: false,\n    attrkey: \"$\",\n    charkey: \"_\",\n    childkey: \"$$\",\n  });\n\n  if (!parsed || !parsed.resources) {\n    return {\n      resources: { $$: [] },\n      resourceNodes: [],\n    };\n  }\n\n  const resourcesNode = parsed.resources;\n  resourcesNode[\"#name\"] = resourcesNode[\"#name\"] ?? \"resources\";\n  resourcesNode.$$ = resourcesNode.$$ ?? [];\n\n  const metadata = extractResourceMetadata(xmlToParse);\n\n  const resourceNodes: AndroidResourceNode[] = [];\n  let metaIndex = 0;\n\n  for (const child of resourcesNode.$$ as any[]) {\n    const elementName = child?.[\"#name\"];\n    if (!isResourceElementName(elementName)) {\n      continue;\n    }\n\n    const meta = metadata[metaIndex++];\n    if (!meta || meta.type !== elementName) {\n      continue;\n    }\n\n    const name = child?.$?.name ?? meta.name;\n    if (!name) {\n      continue;\n    }\n\n    const translatable =\n      (child?.$?.translatable ?? \"\").toLowerCase() !== \"false\";\n\n    switch (meta.type) {\n      case \"string\": {\n        resourceNodes.push({\n          type: \"string\",\n          name,\n          translatable,\n          node: child,\n          meta: cloneTextMeta(meta.meta),\n        });\n        break;\n      }\n      case \"string-array\": {\n        const itemNodes = (child?.item ?? []) as any[];\n        const items: StringArrayItemNode[] = [];\n        const templateItems = meta.items;\n\n        for (\n          let i = 0;\n          i < Math.max(itemNodes.length, templateItems.length);\n          i++\n        ) {\n          const nodeItem = itemNodes[i];\n          const templateItem =\n            templateItems[i] ?? templateItems[templateItems.length - 1];\n          if (!nodeItem) {\n            continue;\n          }\n          items.push({\n            node: nodeItem,\n            meta: cloneTextMeta(templateItem.meta),\n          });\n        }\n\n        resourceNodes.push({\n          type: \"string-array\",\n          name,\n          translatable,\n          node: child,\n          items,\n        });\n        break;\n      }\n      case \"plurals\": {\n        const itemNodes = (child?.item ?? []) as any[];\n        const templateItems = meta.items;\n        const items: PluralsItemNode[] = [];\n\n        for (const templateItem of templateItems) {\n          const quantity = templateItem.quantity;\n          if (!quantity) {\n            continue;\n          }\n          const nodeItem = itemNodes.find(\n            (item: any) => item?.$?.quantity === quantity,\n          );\n          if (!nodeItem) {\n            continue;\n          }\n          items.push({\n            node: nodeItem,\n            quantity,\n            meta: cloneTextMeta(templateItem.meta),\n          });\n        }\n\n        resourceNodes.push({\n          type: \"plurals\",\n          name,\n          translatable,\n          node: child,\n          items,\n        });\n        break;\n      }\n      case \"bool\": {\n        resourceNodes.push({\n          type: \"bool\",\n          name,\n          translatable,\n          node: child,\n          meta: cloneTextMeta(meta.meta),\n        });\n        break;\n      }\n      case \"integer\": {\n        resourceNodes.push({\n          type: \"integer\",\n          name,\n          translatable,\n          node: child,\n          meta: cloneTextMeta(meta.meta),\n        });\n        break;\n      }\n    }\n  }\n\n  return { resources: resourcesNode, resourceNodes };\n}\n\nfunction buildPullResult(document: AndroidDocument): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  for (const resource of document.resourceNodes) {\n    if (!isTranslatable(resource)) {\n      continue;\n    }\n\n    switch (resource.type) {\n      case \"string\": {\n        result[resource.name] = decodeAndroidText(\n          segmentsToString(resource.meta.segments),\n        );\n        break;\n      }\n      case \"string-array\": {\n        result[resource.name] = resource.items.map((item) =>\n          decodeAndroidText(segmentsToString(item.meta.segments)),\n        );\n        break;\n      }\n      case \"plurals\": {\n        const pluralMap: Record<string, string> = {};\n        for (const item of resource.items) {\n          pluralMap[item.quantity] = decodeAndroidText(\n            segmentsToString(item.meta.segments),\n          );\n        }\n        result[resource.name] = pluralMap;\n        break;\n      }\n      case \"bool\": {\n        const value = segmentsToString(resource.meta.segments).trim();\n        result[resource.name] = value === \"true\";\n        break;\n      }\n      case \"integer\": {\n        const value = parseInt(\n          segmentsToString(resource.meta.segments).trim(),\n          10,\n        );\n        result[resource.name] = Number.isNaN(value) ? 0 : value;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isTranslatable(resource: AndroidResourceNode): boolean {\n  return resource.translatable;\n}\n\nfunction buildTranslatedDocument(\n  payload: Record<string, any>,\n  existingDocument: AndroidDocument,\n  sourceDocument: AndroidDocument,\n): AndroidDocument {\n  const templateDocument = sourceDocument;\n  const finalDocument = cloneDocumentStructure(templateDocument);\n\n  const templateMap = createResourceMap(templateDocument);\n  const existingMap = createResourceMap(existingDocument);\n  const payloadEntries = payload ?? {};\n  const finalMap = createResourceMap(finalDocument);\n\n  for (const resource of finalDocument.resourceNodes) {\n    if (!resource.translatable) {\n      continue;\n    }\n\n    const templateResource = templateMap.get(resource.name);\n    let translationValue: any;\n\n    if (\n      Object.prototype.hasOwnProperty.call(payloadEntries, resource.name) &&\n      payloadEntries[resource.name] !== undefined &&\n      payloadEntries[resource.name] !== null\n    ) {\n      translationValue = payloadEntries[resource.name];\n    } else if (existingMap.has(resource.name)) {\n      translationValue = extractValueFromResource(\n        existingMap.get(resource.name)!,\n      );\n    } else {\n      translationValue = extractValueFromResource(templateResource ?? resource);\n    }\n\n    updateResourceNode(resource, translationValue, templateResource);\n  }\n\n  for (const resource of existingDocument.resourceNodes) {\n    if (finalMap.has(resource.name)) {\n      continue;\n    }\n    if (!isTranslatable(resource)) {\n      continue;\n    }\n    const cloned = cloneResourceNode(resource);\n    appendResourceNode(finalDocument, cloned);\n    finalMap.set(cloned.name, cloned);\n  }\n\n  for (const [name, value] of Object.entries(payloadEntries)) {\n    if (finalMap.has(name)) {\n      continue;\n    }\n    try {\n      const inferred = createResourceNodeFromValue(name, value);\n      appendResourceNode(finalDocument, inferred);\n      finalMap.set(name, inferred);\n    } catch (error) {\n      if (error instanceof CLIError) {\n        throw error;\n      }\n    }\n  }\n\n  return finalDocument;\n}\n\nfunction buildAndroidXml(\n  document: AndroidDocument,\n  declaration: XmlDeclarationOptions,\n): string {\n  const xmlBody = serializeElement(document.resources);\n\n  if (declaration.headless) {\n    return xmlBody;\n  }\n\n  if (declaration.xmldec) {\n    const { version, encoding } = declaration.xmldec;\n    const encodingPart = encoding ? ` encoding=\"${encoding}\"` : \"\";\n    return `<?xml version=\"${version}\"${encodingPart}?>\\n${xmlBody}`;\n  }\n\n  return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n${xmlBody}`;\n}\n\nfunction selectBaseXml(\n  locale: string,\n  originalLocale: string,\n  pullInput: string | null,\n  originalInput: string | null,\n): string | null {\n  if (locale === originalLocale) {\n    return pullInput ?? originalInput;\n  }\n  return pullInput ?? originalInput;\n}\n\nfunction updateResourceNode(\n  target: AndroidResourceNode,\n  rawValue: any,\n  template: AndroidResourceNode | undefined,\n): void {\n  switch (target.type) {\n    case \"string\": {\n      const value = asString(rawValue, target.name);\n      const templateMeta =\n        template && template.type === \"string\" ? template.meta : target.meta;\n      const useCdata = templateMeta.hasCdata;\n      setTextualNodeContent(target.node, value, useCdata);\n      target.meta = makeTextMeta([\n        { kind: useCdata ? \"cdata\" : \"text\", value },\n      ]);\n      break;\n    }\n    case \"string-array\": {\n      const values = asStringArray(rawValue, target.name);\n      const templateItems =\n        template && template.type === \"string-array\"\n          ? template.items\n          : target.items;\n      const maxLength = Math.max(target.items.length, templateItems.length);\n      for (let index = 0; index < maxLength; index++) {\n        const targetItem = target.items[index];\n        const templateItem =\n          templateItems[index] ??\n          templateItems[templateItems.length - 1] ??\n          target.items[index];\n        if (!targetItem || !templateItem) {\n          continue;\n        }\n        const translation =\n          index < values.length\n            ? values[index]\n            : segmentsToString(templateItem.meta.segments);\n        const useCdata = templateItem.meta.hasCdata;\n        setTextualNodeContent(targetItem.node, translation, useCdata);\n        targetItem.meta = makeTextMeta([\n          { kind: useCdata ? \"cdata\" : \"text\", value: translation },\n        ]);\n      }\n      break;\n    }\n    case \"plurals\": {\n      const pluralValues = asPluralMap(rawValue, target.name);\n      const templateItems =\n        template && template.type === \"plurals\" ? template.items : target.items;\n      const templateMap = new Map(\n        templateItems.map((item) => [item.quantity, item]),\n      );\n      for (const item of target.items) {\n        const templateItem =\n          templateMap.get(item.quantity) ?? templateMap.values().next().value;\n        const fallback = templateItem\n          ? segmentsToString(templateItem.meta.segments)\n          : segmentsToString(item.meta.segments);\n        const translation =\n          typeof pluralValues[item.quantity] === \"string\"\n            ? pluralValues[item.quantity]\n            : fallback;\n        const useCdata = templateItem\n          ? templateItem.meta.hasCdata\n          : item.meta.hasCdata;\n        setTextualNodeContent(item.node, translation, useCdata);\n        item.meta = makeTextMeta([\n          { kind: useCdata ? \"cdata\" : \"text\", value: translation },\n        ]);\n      }\n      break;\n    }\n    case \"bool\": {\n      const boolValue = asBoolean(rawValue, target.name);\n      const strValue = boolValue ? \"true\" : \"false\";\n      setTextualNodeContent(target.node, strValue, false);\n      target.meta = makeTextMeta([{ kind: \"text\", value: strValue }]);\n      break;\n    }\n    case \"integer\": {\n      const intValue = asInteger(rawValue, target.name);\n      const strValue = intValue.toString();\n      setTextualNodeContent(target.node, strValue, false);\n      target.meta = makeTextMeta([{ kind: \"text\", value: strValue }]);\n      break;\n    }\n  }\n}\n\nfunction appendResourceNode(\n  document: AndroidDocument,\n  resourceNode: AndroidResourceNode,\n): void {\n  document.resources.$$ = document.resources.$$ ?? [];\n  const children = document.resources.$$ as any[];\n\n  if (\n    children.length === 0 ||\n    (children[children.length - 1][\"#name\"] !== \"__text__\" &&\n      children[children.length - 1][\"#name\"] !== \"__comment__\")\n  ) {\n    children.push({ \"#name\": \"__text__\", _: \"\\n    \" });\n  }\n\n  children.push(resourceNode.node);\n  children.push({ \"#name\": \"__text__\", _: \"\\n\" });\n  document.resourceNodes.push(resourceNode);\n}\n\nfunction setTextualNodeContent(\n  node: any,\n  value: string,\n  useCdata: boolean,\n): void {\n  // CDATA needs apostrophe escaping but not XML entity escaping\n  const escapedValue = useCdata\n    ? escapeApostrophesOnly(value)\n    : escapeAndroidString(value);\n  node._ = escapedValue;\n\n  node.$$ = node.$$ ?? [];\n  let textNode = node.$$.find(\n    (child: any) =>\n      child[\"#name\"] === \"__text__\" || child[\"#name\"] === \"__cdata\",\n  );\n\n  if (!textNode) {\n    textNode = {};\n    node.$$.push(textNode);\n  }\n\n  textNode[\"#name\"] = useCdata ? \"__cdata\" : \"__text__\";\n  textNode._ = escapedValue;\n}\n\nfunction buildResourceNameMap(\n  document: AndroidDocument,\n): Map<string, AndroidResourceNode> {\n  const map = new Map<string, AndroidResourceNode>();\n  for (const node of document.resourceNodes) {\n    if (!map.has(node.name)) {\n      map.set(node.name, node);\n    }\n  }\n  return map;\n}\n\nfunction createResourceMap(\n  document: AndroidDocument,\n): Map<string, AndroidResourceNode> {\n  return buildResourceNameMap(document);\n}\n\nfunction cloneResourceNode(resource: AndroidResourceNode): AndroidResourceNode {\n  switch (resource.type) {\n    case \"string\": {\n      const nodeClone = deepClone(resource.node);\n      return {\n        type: \"string\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node: nodeClone,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n    case \"string-array\": {\n      const nodeClone = deepClone(resource.node);\n      const itemNodes = (nodeClone.item ?? []) as any[];\n      const items: StringArrayItemNode[] = itemNodes.map((itemNode, index) => {\n        const templateMeta =\n          resource.items[index]?.meta ??\n          resource.items[resource.items.length - 1]?.meta ??\n          makeTextMeta([]);\n        return {\n          node: itemNode,\n          meta: cloneTextMeta(templateMeta),\n        };\n      });\n      return {\n        type: \"string-array\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node: nodeClone,\n        items,\n      };\n    }\n    case \"plurals\": {\n      const nodeClone = deepClone(resource.node);\n      const itemNodes = (nodeClone.item ?? []) as any[];\n      const items: PluralsItemNode[] = [];\n      for (const templateItem of resource.items) {\n        const cloneNode = itemNodes.find(\n          (item: any) => item?.$?.quantity === templateItem.quantity,\n        );\n        if (!cloneNode) {\n          continue;\n        }\n        items.push({\n          node: cloneNode,\n          quantity: templateItem.quantity,\n          meta: cloneTextMeta(templateItem.meta),\n        });\n      }\n      return {\n        type: \"plurals\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node: nodeClone,\n        items,\n      };\n    }\n    case \"bool\": {\n      const nodeClone = deepClone(resource.node);\n      return {\n        type: \"bool\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node: nodeClone,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n    case \"integer\": {\n      const nodeClone = deepClone(resource.node);\n      return {\n        type: \"integer\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node: nodeClone,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n  }\n}\n\nfunction cloneTextMeta(meta: TextualMeta): TextualMeta {\n  return {\n    hasCdata: meta.hasCdata,\n    segments: meta.segments.map((segment) => ({ ...segment })),\n  };\n}\n\nfunction asString(value: any, name: string): string {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  throw new CLIError({\n    message: `Expected string value for resource \"${name}\"`,\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction asStringArray(value: any, name: string): string[] {\n  if (Array.isArray(value) && value.every((item) => typeof item === \"string\")) {\n    return value;\n  }\n  throw new CLIError({\n    message: `Expected array of strings for resource \"${name}\"`,\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction asPluralMap(value: any, name: string): Record<string, string> {\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\n    const result: Record<string, string> = {};\n    for (const [quantity, pluralValue] of Object.entries(value)) {\n      if (typeof pluralValue !== \"string\") {\n        throw new CLIError({\n          message: `Expected plural item \"${quantity}\" of \"${name}\" to be a string`,\n          docUrl: \"androidResouceError\",\n        });\n      }\n      result[quantity] = pluralValue;\n    }\n    return result;\n  }\n  throw new CLIError({\n    message: `Expected object value for plurals resource \"${name}\"`,\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction asBoolean(value: any, name: string): boolean {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    if (value === \"true\" || value === \"false\") {\n      return value === \"true\";\n    }\n  }\n  throw new CLIError({\n    message: `Expected boolean value for resource \"${name}\"`,\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction asInteger(value: any, name: string): number {\n  if (typeof value === \"number\" && Number.isInteger(value)) {\n    return value;\n  }\n  throw new CLIError({\n    message: `Expected number value for resource \"${name}\"`,\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction escapeAndroidString(value: string): string {\n  return value\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/(?<!\\\\)'/g, \"\\\\'\");\n}\n\nfunction escapeApostrophesOnly(value: string): string {\n  // Even inside CDATA, apostrophes must be escaped for Android AAPT\n  return value.replace(/(?<!\\\\)'/g, \"\\\\'\");\n}\n\nfunction segmentsToString(segments: ContentSegment[]): string {\n  return segments.map((segment) => segment.value).join(\"\");\n}\n\nfunction makeTextMeta(segments: ContentSegment[]): TextualMeta {\n  return {\n    segments,\n    hasCdata: segments.some((segment) => segment.kind === \"cdata\"),\n  };\n}\n\nfunction createResourceNodeFromValue(\n  name: string,\n  value: any,\n): AndroidResourceNode {\n  const inferredType = inferTypeFromValue(value);\n\n  switch (inferredType) {\n    case \"string\": {\n      const stringValue = asString(value, name);\n      const escaped = escapeAndroidString(stringValue);\n      const node = {\n        \"#name\": \"string\",\n        $: { name },\n        _: escaped,\n        $$: [{ \"#name\": \"__text__\", _: escaped }],\n      };\n      return {\n        type: \"string\",\n        name,\n        translatable: true,\n        node,\n        meta: makeTextMeta([{ kind: \"text\", value: stringValue }]),\n      };\n    }\n    case \"string-array\": {\n      const items = asStringArray(value, name);\n      const node = {\n        \"#name\": \"string-array\",\n        $: { name },\n        $$: [] as any[],\n        item: [] as any[],\n      };\n      const itemNodes: StringArrayItemNode[] = [];\n      for (const itemValue of items) {\n        const escaped = escapeAndroidString(itemValue);\n        const itemNode = {\n          \"#name\": \"item\",\n          _: escaped,\n          $$: [{ \"#name\": \"__text__\", _: escaped }],\n        };\n        node.$$!.push(itemNode);\n        node.item!.push(itemNode);\n        itemNodes.push({\n          node: itemNode,\n          meta: makeTextMeta([{ kind: \"text\", value: itemValue }]),\n        });\n      }\n      return {\n        type: \"string-array\",\n        name,\n        translatable: true,\n        node,\n        items: itemNodes,\n      };\n    }\n    case \"plurals\": {\n      const pluralMap = asPluralMap(value, name);\n      const node = {\n        \"#name\": \"plurals\",\n        $: { name },\n        $$: [] as any[],\n        item: [] as any[],\n      };\n      const items: PluralsItemNode[] = [];\n      for (const [quantity, pluralValue] of Object.entries(pluralMap)) {\n        const escaped = escapeAndroidString(pluralValue);\n        const itemNode = {\n          \"#name\": \"item\",\n          $: { quantity },\n          _: escaped,\n          $$: [{ \"#name\": \"__text__\", _: escaped }],\n        };\n        node.$$!.push(itemNode);\n        node.item!.push(itemNode);\n        items.push({\n          node: itemNode,\n          quantity,\n          meta: makeTextMeta([{ kind: \"text\", value: pluralValue }]),\n        });\n      }\n      return {\n        type: \"plurals\",\n        name,\n        translatable: true,\n        node,\n        items,\n      };\n    }\n    case \"bool\": {\n      const boolValue = asBoolean(value, name);\n      const textValue = boolValue ? \"true\" : \"false\";\n      const node = {\n        \"#name\": \"bool\",\n        $: { name },\n        _: textValue,\n        $$: [{ \"#name\": \"__text__\", _: textValue }],\n      };\n      return {\n        type: \"bool\",\n        name,\n        translatable: true,\n        node,\n        meta: makeTextMeta([{ kind: \"text\", value: textValue }]),\n      };\n    }\n    case \"integer\": {\n      const intValue = asInteger(value, name);\n      const textValue = intValue.toString();\n      const node = {\n        \"#name\": \"integer\",\n        $: { name },\n        _: textValue,\n        $$: [{ \"#name\": \"__text__\", _: textValue }],\n      };\n      return {\n        type: \"integer\",\n        name,\n        translatable: true,\n        node,\n        meta: makeTextMeta([{ kind: \"text\", value: textValue }]),\n      };\n    }\n  }\n}\n\nfunction cloneDocumentStructure(document: AndroidDocument): AndroidDocument {\n  // Filter first - only keep translatable resources\n  const translatableResources = document.resourceNodes.filter(isTranslatable);\n\n  const resourcesClone = deepClone(document.resources);\n  const lookup = buildResourceLookup(resourcesClone);\n  const resourceNodes: AndroidResourceNode[] = [];\n\n  for (const resource of translatableResources) {\n    const cloned = cloneResourceNodeFromLookup(resource, lookup);\n    resourceNodes.push(cloned);\n  }\n\n  // Clean up XML structure - only keep translatable resource nodes\n  if (resourcesClone.$$ && Array.isArray(resourcesClone.$$)) {\n    const includedKeys = new Set(\n      resourceNodes.map((r) => resourceLookupKey(r.type, r.name)),\n    );\n\n    // Filter out non-translatable resources\n    let filtered = resourcesClone.$$.filter((child: any) => {\n      const elementName = child?.[\"#name\"];\n      const name = child?.$?.name;\n      if (!isResourceElementName(elementName) || !name) {\n        return true; // Keep whitespace, comments, etc.\n      }\n      return includedKeys.has(resourceLookupKey(elementName, name));\n    });\n\n    // Remove consecutive whitespace nodes (fixes extra blank lines)\n    const cleaned: any[] = [];\n    let lastWasWhitespace = false;\n\n    for (const child of filtered) {\n      const isWhitespace =\n        child?.[\"#name\"] === \"__text__\" && (!child._ || child._.trim() === \"\");\n\n      if (isWhitespace) {\n        if (!lastWasWhitespace) {\n          cleaned.push(child);\n          lastWasWhitespace = true;\n        }\n        // Skip consecutive whitespace\n      } else {\n        cleaned.push(child);\n        lastWasWhitespace = false;\n      }\n    }\n\n    resourcesClone.$$ = cleaned;\n  }\n\n  return {\n    resources: resourcesClone,\n    resourceNodes,\n  };\n}\n\nfunction buildResourceLookup(resources: any): Map<string, any[]> {\n  const lookup = new Map<string, any[]>();\n  const children = Array.isArray(resources.$$) ? resources.$$ : [];\n  for (const child of children) {\n    const type = child?.[\"#name\"];\n    const name = child?.$?.name;\n    if (!type || !name || !isResourceElementName(type)) {\n      continue;\n    }\n    const key = resourceLookupKey(type, name);\n    if (!lookup.has(key)) {\n      lookup.set(key, []);\n    }\n    lookup.get(key)!.push(child);\n  }\n  return lookup;\n}\n\nfunction cloneResourceNodeFromLookup(\n  resource: AndroidResourceNode,\n  lookup: Map<string, any[]>,\n): AndroidResourceNode {\n  const node = takeResourceNode(lookup, resource.type, resource.name);\n  if (!node) {\n    return cloneResourceNode(resource);\n  }\n\n  switch (resource.type) {\n    case \"string\": {\n      return {\n        type: \"string\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n    case \"string-array\": {\n      const childItems = (Array.isArray(node.$$) ? node.$$ : []).filter(\n        (child: any) => child?.[\"#name\"] === \"item\",\n      );\n      node.item = childItems;\n      if (childItems.length < resource.items.length) {\n        return cloneResourceNode(resource);\n      }\n      const items: StringArrayItemNode[] = resource.items.map((item, index) => {\n        const nodeItem = childItems[index];\n        if (!nodeItem) {\n          return {\n            node: deepClone(item.node),\n            meta: cloneTextMeta(item.meta),\n          };\n        }\n        return {\n          node: nodeItem,\n          meta: cloneTextMeta(item.meta),\n        };\n      });\n      return {\n        type: \"string-array\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node,\n        items,\n      };\n    }\n    case \"plurals\": {\n      const childItems = (Array.isArray(node.$$) ? node.$$ : []).filter(\n        (child: any) => child?.[\"#name\"] === \"item\",\n      );\n      node.item = childItems;\n      const itemMap = new Map<string, any>();\n      for (const item of childItems) {\n        if (item?.$?.quantity) {\n          itemMap.set(item.$.quantity, item);\n        }\n      }\n      const items: PluralsItemNode[] = [];\n      for (const templateItem of resource.items) {\n        const nodeItem = itemMap.get(templateItem.quantity);\n        if (!nodeItem) {\n          return cloneResourceNode(resource);\n        }\n        items.push({\n          node: nodeItem,\n          quantity: templateItem.quantity,\n          meta: cloneTextMeta(templateItem.meta),\n        });\n      }\n      return {\n        type: \"plurals\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node,\n        items,\n      };\n    }\n    case \"bool\": {\n      return {\n        type: \"bool\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n    case \"integer\": {\n      return {\n        type: \"integer\",\n        name: resource.name,\n        translatable: resource.translatable,\n        node,\n        meta: cloneTextMeta(resource.meta),\n      };\n    }\n  }\n}\n\nfunction takeResourceNode(\n  lookup: Map<string, any[]>,\n  type: AndroidResourceType,\n  name: string,\n): any | undefined {\n  const key = resourceLookupKey(type, name);\n  const list = lookup.get(key);\n  if (!list || list.length === 0) {\n    return undefined;\n  }\n  return list.shift();\n}\n\nfunction resourceLookupKey(type: string, name: string): string {\n  return `${type}:${name}`;\n}\n\nfunction extractValueFromResource(resource: AndroidResourceNode): any {\n  switch (resource.type) {\n    case \"string\":\n      return decodeAndroidText(segmentsToString(resource.meta.segments));\n    case \"string-array\":\n      return resource.items.map((item) =>\n        decodeAndroidText(segmentsToString(item.meta.segments)),\n      );\n    case \"plurals\": {\n      const result: Record<string, string> = {};\n      for (const item of resource.items) {\n        result[item.quantity] = decodeAndroidText(\n          segmentsToString(item.meta.segments),\n        );\n      }\n      return result;\n    }\n    case \"bool\": {\n      const value = segmentsToString(resource.meta.segments).trim();\n      return value === \"true\";\n    }\n    case \"integer\": {\n      const value = parseInt(\n        segmentsToString(resource.meta.segments).trim(),\n        10,\n      );\n      return Number.isNaN(value) ? 0 : value;\n    }\n  }\n}\n\nfunction inferTypeFromValue(value: any): AndroidResourceType {\n  if (typeof value === \"string\") {\n    return \"string\";\n  }\n  if (Array.isArray(value)) {\n    return \"string-array\";\n  }\n  if (value && typeof value === \"object\") {\n    return \"plurals\";\n  }\n  if (typeof value === \"boolean\") {\n    return \"bool\";\n  }\n  if (typeof value === \"number\" && Number.isInteger(value)) {\n    return \"integer\";\n  }\n  throw new CLIError({\n    message: \"Unable to infer Android resource type from payload\",\n    docUrl: \"androidResouceError\",\n  });\n}\n\nfunction extractResourceMetadata(xml: string) {\n  interface StackEntry {\n    name: string;\n    rawName: string;\n    attributes: Record<string, string>;\n    segments: ContentSegment[];\n    items: Array<{ quantity?: string; meta: TextualMeta }>;\n  }\n\n  interface StringMeta {\n    type: \"string\";\n    name: string;\n    translatable: boolean;\n    meta: TextualMeta;\n  }\n\n  interface StringArrayMeta {\n    type: \"string-array\";\n    name: string;\n    translatable: boolean;\n    items: Array<{ meta: TextualMeta }>;\n  }\n\n  interface PluralsMeta {\n    type: \"plurals\";\n    name: string;\n    translatable: boolean;\n    items: Array<{ quantity: string; meta: TextualMeta }>;\n  }\n\n  interface BoolMeta {\n    type: \"bool\";\n    name: string;\n    translatable: boolean;\n    meta: TextualMeta;\n  }\n\n  interface IntegerMeta {\n    type: \"integer\";\n    name: string;\n    translatable: boolean;\n    meta: TextualMeta;\n  }\n\n  type ResourceMeta =\n    | StringMeta\n    | StringArrayMeta\n    | PluralsMeta\n    | BoolMeta\n    | IntegerMeta;\n\n  const parser = sax.parser(true, {\n    trim: false,\n    normalize: false,\n    lowercase: false,\n  });\n\n  const stack: StackEntry[] = [];\n  const result: ResourceMeta[] = [];\n\n  parser.onopentag = (node) => {\n    const lowerName = node.name.toLowerCase();\n    const attributes: Record<string, string> = {};\n    for (const [key, value] of Object.entries(node.attributes ?? {})) {\n      attributes[key.toLowerCase()] = String(value);\n    }\n    stack.push({\n      name: lowerName,\n      rawName: node.name,\n      attributes,\n      segments: [],\n      items: [],\n    });\n\n    if (\n      lowerName !== \"resources\" &&\n      lowerName !== \"item\" &&\n      !isResourceElementName(lowerName)\n    ) {\n      const attrString = Object.entries(node.attributes ?? {})\n        .map(\n          ([key, value]) => ` ${key}=\"${escapeAttributeValue(String(value))}\"`,\n        )\n        .join(\"\");\n      appendSegmentToNearestResource(stack, {\n        kind: \"text\",\n        value: `<${node.name}${attrString}>`,\n      });\n    }\n  };\n\n  parser.ontext = (text) => {\n    if (!text) {\n      return;\n    }\n    appendSegmentToNearestResource(stack, { kind: \"text\", value: text });\n  };\n\n  parser.oncdata = (cdata) => {\n    appendSegmentToNearestResource(stack, { kind: \"cdata\", value: cdata });\n  };\n\n  parser.onclosetag = () => {\n    const entry = stack.pop();\n    if (!entry) {\n      return;\n    }\n\n    const parent = stack[stack.length - 1];\n\n    if (entry.name === \"item\" && parent) {\n      const meta = makeTextMeta(entry.segments);\n      parent.items.push({\n        quantity: entry.attributes.quantity,\n        meta,\n      });\n      return;\n    }\n\n    if (\n      entry.name !== \"resources\" &&\n      entry.name !== \"item\" &&\n      !isResourceElementName(entry.name)\n    ) {\n      appendSegmentToNearestResource(stack, {\n        kind: \"text\",\n        value: `</${entry.rawName}>`,\n      });\n      return;\n    }\n\n    if (!isResourceElementName(entry.name)) {\n      return;\n    }\n\n    const name = entry.attributes.name;\n    if (!name) {\n      return;\n    }\n\n    const translatable =\n      (entry.attributes.translatable ?? \"\").toLowerCase() !== \"false\";\n\n    switch (entry.name) {\n      case \"string\": {\n        result.push({\n          type: \"string\",\n          name,\n          translatable,\n          meta: makeTextMeta(entry.segments),\n        });\n        break;\n      }\n      case \"string-array\": {\n        result.push({\n          type: \"string-array\",\n          name,\n          translatable,\n          items: entry.items.map((item) => ({\n            meta: cloneTextMeta(item.meta),\n          })),\n        });\n        break;\n      }\n      case \"plurals\": {\n        const items: Array<{ quantity: string; meta: TextualMeta }> = [];\n        for (const item of entry.items) {\n          if (!item.quantity) {\n            continue;\n          }\n          items.push({\n            quantity: item.quantity,\n            meta: cloneTextMeta(item.meta),\n          });\n        }\n        result.push({\n          type: \"plurals\",\n          name,\n          translatable,\n          items,\n        });\n        break;\n      }\n      case \"bool\": {\n        result.push({\n          type: \"bool\",\n          name,\n          translatable,\n          meta: makeTextMeta(entry.segments),\n        });\n        break;\n      }\n      case \"integer\": {\n        result.push({\n          type: \"integer\",\n          name,\n          translatable,\n          meta: makeTextMeta(entry.segments),\n        });\n        break;\n      }\n    }\n  };\n\n  parser.write(xml).close();\n\n  return result;\n}\n\nfunction appendSegmentToNearestResource(\n  stack: Array<{\n    name: string;\n    segments: ContentSegment[];\n    attributes: Record<string, string>;\n  }>,\n  segment: ContentSegment,\n) {\n  for (let index = stack.length - 1; index >= 0; index--) {\n    const entry = stack[index];\n    if (\n      entry.name === \"string\" ||\n      entry.name === \"item\" ||\n      entry.name === \"bool\" ||\n      entry.name === \"integer\"\n    ) {\n      entry.segments.push(segment);\n      return;\n    }\n  }\n}\n\nfunction isResourceElementName(\n  value: string | undefined,\n): value is AndroidResourceType {\n  return (\n    value === \"string\" ||\n    value === \"string-array\" ||\n    value === \"plurals\" ||\n    value === \"bool\" ||\n    value === \"integer\"\n  );\n}\n\nfunction deepClone<T>(value: T): T {\n  return value === undefined ? value : JSON.parse(JSON.stringify(value));\n}\n\nfunction serializeElement(node: any): string {\n  if (!node) {\n    return \"\";\n  }\n\n  const name = node[\"#name\"] ?? \"resources\";\n\n  if (name === \"__text__\") {\n    return node._ ?? \"\";\n  }\n\n  if (name === \"__cdata\") {\n    return `<![CDATA[${node._ ?? \"\"}]]>`;\n  }\n\n  if (name === \"__comment__\") {\n    return `<!--${node._ ?? \"\"}-->`;\n  }\n\n  const attributes = node.$ ?? {};\n  const attrString = Object.entries(attributes)\n    .map(([key, value]) => ` ${key}=\"${escapeAttributeValue(String(value))}\"`)\n    .join(\"\");\n\n  const children = Array.isArray(node.$$) ? node.$$ : [];\n\n  if (children.length === 0) {\n    const textContent = node._ ?? \"\";\n    return `<${name}${attrString}>${textContent}</${name}>`;\n  }\n\n  const childContent = children.map(serializeElement).join(\"\");\n  return `<${name}${attrString}>${childContent}</${name}>`;\n}\n\nfunction escapeAttributeValue(value: string): string {\n  return value\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/'/g, \"&apos;\");\n}\n\nfunction decodeAndroidText(value: string): string {\n  return value.replace(/\\\\'/g, \"'\");\n}\n","import { parse } from \"csv-parse/sync\";\nimport { stringify } from \"csv-stringify/sync\";\nimport _ from \"lodash\";\nimport { ILoader } from \"./_types\";\nimport { composeLoaders, createLoader } from \"./_utils\";\n\n/**\n * Tries to detect the key column name from a csvString.\n *\n * Current logic: get first cell > 'KEY' fallback if empty\n */\nexport function detectKeyColumnName(csvString: string) {\n  const row: string[] | undefined = parse(csvString)[0];\n  const firstColumn = row?.[0]?.trim();\n  return firstColumn || \"KEY\";\n}\n\nexport default function createCsvLoader() {\n  return composeLoaders(_createCsvLoader(), createPullOutputCleaner());\n}\n\ntype InternalTransferState = {\n  keyColumnName: string;\n  inputParsed: Record<string, any>[];\n  items: Record<string, string>;\n};\n\nfunction _createCsvLoader(): ILoader<string, InternalTransferState> {\n  return createLoader({\n    async pull(locale, input) {\n      const keyColumnName = detectKeyColumnName(\n        input.split(\"\\n\").find((l) => l.length)!,\n      );\n      const inputParsed = parse(input, {\n        columns: true,\n        skip_empty_lines: true,\n        relax_column_count_less: true,\n      }) as Record<string, any>[];\n\n      const items: Record<string, string> = {};\n\n      // Assign keys that already have translation so AI doesn't re-generate it.\n      _.forEach(inputParsed, (row) => {\n        const key = row[keyColumnName];\n        if (key && row[locale] && row[locale].trim() !== \"\") {\n          items[key] = row[locale];\n        }\n      });\n\n      return {\n        inputParsed,\n        keyColumnName,\n        items,\n      };\n    },\n    async push(locale, { inputParsed, keyColumnName, items }) {\n      const columns =\n        inputParsed.length > 0\n          ? Object.keys(inputParsed[0])\n          : [keyColumnName, locale];\n      if (!columns.includes(locale)) {\n        columns.push(locale);\n      }\n\n      const updatedRows = inputParsed.map((row) => ({\n        ...row,\n        [locale]: items[row[keyColumnName]] || row[locale] || \"\",\n      }));\n      const existingKeys = new Set(\n        inputParsed.map((row) => row[keyColumnName]),\n      );\n\n      Object.entries(items).forEach(([key, value]) => {\n        if (!existingKeys.has(key)) {\n          const newRow: Record<string, string> = {\n            [keyColumnName]: key,\n            ...Object.fromEntries(columns.map((column) => [column, \"\"])),\n          };\n          newRow[locale] = value;\n          updatedRows.push(newRow);\n        }\n      });\n\n      return stringify(updatedRows, {\n        header: true,\n        columns,\n      });\n    },\n  });\n}\n\n/**\n * This is a simple extra loader that is used to clean the data written to lockfile\n */\nfunction createPullOutputCleaner(): ILoader<\n  InternalTransferState,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(_locale, input) {\n      return input.items;\n    },\n    async push(_locale, data, _oI, _oL, pullInput) {\n      return { ...pullInput!, items: data };\n    },\n  });\n}\n","import { JSDOM } from \"jsdom\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nfunction normalizeTextContent(text: string, isStandalone: boolean): string {\n  // Remove any leading/trailing whitespace for initial comparison\n  const trimmed = text.trim();\n  if (!trimmed) return \"\";\n\n  // For all text nodes, just return the trimmed content\n  return trimmed;\n}\n\nexport default function createHtmlLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  const LOCALIZABLE_ATTRIBUTES: Record<string, string[]> = {\n    meta: [\"content\"],\n    img: [\"alt\"],\n    input: [\"placeholder\"],\n    a: [\"title\"],\n  };\n  const UNLOCALIZABLE_TAGS = [\"script\", \"style\"];\n\n  return createLoader({\n    async pull(locale, input) {\n      const result: Record<string, any> = {};\n      const dom = new JSDOM(input);\n      const document = dom.window.document;\n\n      const getPath = (node: Node, attribute?: string): string => {\n        const indices: number[] = [];\n        let current = node as ChildNode;\n        let rootParent = \"\";\n\n        while (current) {\n          const parent = current.parentElement as Element;\n          if (!parent) break;\n\n          if (parent === document.documentElement) {\n            rootParent = current.nodeName.toLowerCase();\n            break;\n          }\n\n          // Get index among significant siblings (non-empty text nodes and elements)\n          const siblings = Array.from(parent.childNodes).filter(\n            (n) =>\n              n.nodeType === 1 || (n.nodeType === 3 && n.textContent?.trim()),\n          );\n          const index = siblings.indexOf(current);\n          if (index !== -1) {\n            indices.unshift(index);\n          }\n          current = parent;\n        }\n\n        const basePath = rootParent\n          ? `${rootParent}/${indices.join(\"/\")}`\n          : indices.join(\"/\");\n        return attribute ? `${basePath}#${attribute}` : basePath;\n      };\n\n      const processNode = (node: Node) => {\n        // Check if node is inside an unlocalizable tag\n        let parent = node.parentElement;\n        while (parent) {\n          if (UNLOCALIZABLE_TAGS.includes(parent.tagName.toLowerCase())) {\n            return; // Skip processing this node and its children\n          }\n          parent = parent.parentElement;\n        }\n\n        if (node.nodeType === 3) {\n          // Text node\n          const text = node.textContent || \"\";\n          const normalizedText = normalizeTextContent(text, true);\n          if (normalizedText) {\n            result[getPath(node)] = normalizedText;\n          }\n        } else if (node.nodeType === 1) {\n          // Element node\n          const element = node as Element;\n\n          // Handle localizable attributes\n          const tagName = element.tagName.toLowerCase();\n          const attributes = LOCALIZABLE_ATTRIBUTES[tagName] || [];\n          attributes.forEach((attr) => {\n            const value = element.getAttribute(attr);\n            if (value) {\n              result[getPath(element, attr)] = value;\n            }\n          });\n\n          // Process all child nodes\n          Array.from(element.childNodes)\n            .filter(\n              (n) =>\n                n.nodeType === 1 || (n.nodeType === 3 && n.textContent?.trim()),\n            )\n            .forEach(processNode);\n        }\n      };\n\n      // Process head and body\n      Array.from(document.head.childNodes)\n        .filter(\n          (n) =>\n            n.nodeType === 1 || (n.nodeType === 3 && n.textContent?.trim()),\n        )\n        .forEach(processNode);\n      Array.from(document.body.childNodes)\n        .filter(\n          (n) =>\n            n.nodeType === 1 || (n.nodeType === 3 && n.textContent?.trim()),\n        )\n        .forEach(processNode);\n\n      return result;\n    },\n\n    async push(locale, data, originalInput) {\n      const dom = new JSDOM(\n        originalInput ??\n          \"<!DOCTYPE html><html><head></head><body></body></html>\",\n      );\n      const document = dom.window.document;\n\n      // Set the HTML lang attribute to the current locale\n      const htmlElement = document.documentElement;\n      htmlElement.setAttribute(\"lang\", locale);\n\n      // Sort paths to ensure proper order of creation\n      const paths = Object.keys(data).sort((a, b) => {\n        const aDepth = a.split(\"/\").length;\n        const bDepth = b.split(\"/\").length;\n        return aDepth - bDepth;\n      });\n\n      paths.forEach((path) => {\n        const value = data[path];\n        const [nodePath, attribute] = path.split(\"#\");\n        const [rootTag, ...indices] = nodePath.split(\"/\");\n\n        let parent: Element =\n          rootTag === \"head\" ? document.head : document.body;\n        let current: Node | null = parent;\n\n        // Navigate to the target node\n        for (let i = 0; i < indices.length; i++) {\n          const index = parseInt(indices[i]);\n          const siblings = Array.from(parent.childNodes).filter(\n            (n) =>\n              n.nodeType === 1 || (n.nodeType === 3 && n.textContent?.trim()),\n          );\n\n          if (index >= siblings.length) {\n            // Create missing nodes\n            if (i === indices.length - 1) {\n              // Last index - create text node\n              const textNode = document.createTextNode(\"\");\n              parent.appendChild(textNode);\n              current = textNode;\n            } else {\n              // Create intermediate element\n              const element = document.createElement(\"div\");\n              parent.appendChild(element);\n              current = element;\n              parent = element;\n            }\n          } else {\n            current = siblings[index];\n            if (current.nodeType === 1) {\n              parent = current as Element;\n            }\n          }\n        }\n\n        // Set content\n        if (current) {\n          if (attribute) {\n            (current as Element).setAttribute(attribute, value);\n          } else {\n            current.textContent = value;\n          }\n        }\n      });\n\n      // Preserve formatting by using serialize() with pretty print\n      return dom.serialize();\n    },\n  });\n}\n","import matter from \"gray-matter\";\nimport YAML from \"yaml\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nconst SECTION_REGEX =\n  /^(#{1,6}\\s.*$|[-=*]{3,}$|!\\[.*\\]\\(.*\\)$|\\[.*\\]\\(.*\\)$)/gm;\nconst MD_SECTION_PREFIX = \"md-section-\";\nconst FM_ATTR_PREFIX = \"fm-attr-\";\n\nconst yamlEngine = {\n  parse: (str: string) => YAML.parse(str),\n  stringify: (obj: any) => YAML.stringify(obj, { defaultStringType: \"PLAIN\" }),\n};\n\nexport default function createMarkdownLoader(): ILoader<\n  string,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const { data: frontmatter, content } = matter(input, {\n        engines: {\n          yaml: yamlEngine,\n        },\n      });\n\n      const sections = content\n        .split(SECTION_REGEX)\n        .map((section) => section?.trim() ?? \"\")\n        .filter(Boolean);\n\n      return {\n        ...Object.fromEntries(\n          sections\n            .map((section, index) => [`${MD_SECTION_PREFIX}${index}`, section])\n            .filter(([, section]) => Boolean(section)),\n        ),\n        ...Object.fromEntries(\n          Object.entries(frontmatter).map(([key, value]) => [\n            `${FM_ATTR_PREFIX}${key}`,\n            value,\n          ]),\n        ),\n      };\n    },\n    async push(locale, data: Record<string, string>) {\n      const frontmatter = Object.fromEntries(\n        Object.entries(data)\n          .filter(([key]) => key.startsWith(FM_ATTR_PREFIX))\n          .map(([key, value]) => [key.replace(FM_ATTR_PREFIX, \"\"), value]),\n      );\n\n      let content = Object.entries(data)\n        .filter(([key]) => key.startsWith(MD_SECTION_PREFIX))\n        .sort(\n          ([a], [b]) => Number(a.split(\"-\").pop()) - Number(b.split(\"-\").pop()),\n        )\n        .map(([, value]) => value?.trim() ?? \"\")\n        .filter(Boolean)\n        .join(\"\\n\\n\");\n\n      if (Object.keys(frontmatter).length > 0) {\n        content = `\\n${content}`;\n      }\n\n      return matter.stringify(content, frontmatter, {\n        engines: {\n          yaml: yamlEngine,\n        },\n      });\n    },\n  });\n}\n","import Markdoc from \"@markdoc/markdoc\";\nimport YAML from \"yaml\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\ntype MarkdocNode = {\n  $$mdtype?: string;\n  type: string;\n  tag?: string;\n  attributes?: Record<string, any>;\n  children?: MarkdocNode[];\n  [key: string]: any;\n};\n\ntype NodeCounter = {\n  [nodeType: string]: number;\n};\n\ntype NodePathMap = {\n  [semanticKey: string]: string; // maps semantic key to AST path\n};\n\nconst FM_ATTR_PREFIX = \"fm-attr-\";\n\nexport default function createMarkdocLoader(): ILoader<\n  string,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const ast = Markdoc.parse(input) as unknown as MarkdocNode;\n      const result: Record<string, string> = {};\n      const counters: NodeCounter = {};\n\n      // Traverse the AST and extract text content with semantic keys\n      traverseAndExtract(ast, \"\", result, counters);\n\n      // Extract frontmatter if present\n      if (ast.attributes?.frontmatter) {\n        const frontmatter = YAML.parse(ast.attributes.frontmatter);\n        Object.entries(frontmatter).forEach(([key, value]) => {\n          if (typeof value === \"string\") {\n            result[`${FM_ATTR_PREFIX}${key}`] = value;\n          }\n        });\n      }\n\n      return result;\n    },\n\n    async push(locale, data, originalInput) {\n      if (!originalInput) {\n        throw new Error(\"Original input is required for push\");\n      }\n\n      const ast = Markdoc.parse(originalInput) as unknown as MarkdocNode;\n      const counters: NodeCounter = {};\n      const pathMap: NodePathMap = {};\n\n      // Build path map from semantic keys to AST paths\n      buildPathMap(ast, \"\", counters, pathMap);\n\n      // Extract frontmatter from data\n      const frontmatterEntries = Object.entries(data)\n        .filter(([key]) => key.startsWith(FM_ATTR_PREFIX))\n        .map(([key, value]) => [key.replace(FM_ATTR_PREFIX, \"\"), value]);\n\n      // Update frontmatter in AST if present\n      if (frontmatterEntries.length > 0 && ast.attributes) {\n        const frontmatter = Object.fromEntries(frontmatterEntries);\n        ast.attributes.frontmatter = YAML.stringify(frontmatter, {\n          defaultStringType: \"PLAIN\",\n        }).trim();\n      }\n\n      // Filter out frontmatter keys from translation data\n      const contentData = Object.fromEntries(\n        Object.entries(data).filter(([key]) => !key.startsWith(FM_ATTR_PREFIX)),\n      );\n\n      // Apply translations using the path map\n      applyTranslations(ast, \"\", contentData, pathMap);\n\n      // Format back to string\n      return Markdoc.format(ast);\n    },\n  });\n}\n\nfunction getSemanticNodeType(node: MarkdocNode): string | null {\n  // For custom tags, use the tag name instead of \"tag\"\n  if (node.type === \"tag\") return node.tag || \"tag\";\n  return node.type;\n}\n\nfunction traverseAndExtract(\n  node: MarkdocNode,\n  path: string,\n  result: Record<string, string>,\n  counters: NodeCounter,\n  parentType?: string,\n) {\n  if (!node || typeof node !== \"object\") {\n    return;\n  }\n\n  // Determine the semantic type for this node\n  let semanticType = parentType;\n  const nodeSemanticType = getSemanticNodeType(node);\n\n  // Use node's own semantic type for structural elements\n  if (\n    nodeSemanticType &&\n    ![\"text\", \"strong\", \"em\", \"inline\", \"link\"].includes(nodeSemanticType)\n  ) {\n    semanticType = nodeSemanticType;\n  }\n\n  // If this is a text node, extract its content only if it's a string\n  // Skip interpolation nodes (where content is a Variable or Function object)\n  if (node.type === \"text\" && node.attributes?.content) {\n    const content = node.attributes.content;\n\n    // Only extract if content is a string (not interpolation)\n    if (typeof content === \"string\" && content.trim()) {\n      if (semanticType) {\n        const index = counters[semanticType] || 0;\n        counters[semanticType] = index + 1;\n        const semanticKey = `${semanticType}-${index}`;\n        result[semanticKey] = content;\n      }\n    }\n  }\n\n  // If the node has children, traverse them\n  if (Array.isArray(node.children)) {\n    node.children.forEach((child, index) => {\n      const childPath = path\n        ? `${path}/children/${index}`\n        : `children/${index}`;\n      traverseAndExtract(child, childPath, result, counters, semanticType);\n    });\n  }\n}\n\nfunction buildPathMap(\n  node: MarkdocNode,\n  path: string,\n  counters: NodeCounter,\n  pathMap: NodePathMap,\n  parentType?: string,\n) {\n  if (!node || typeof node !== \"object\") {\n    return;\n  }\n\n  // Determine the semantic type for this node\n  let semanticType = parentType;\n  const nodeSemanticType = getSemanticNodeType(node);\n\n  // Use node's own semantic type for structural elements\n  if (\n    nodeSemanticType &&\n    ![\"text\", \"strong\", \"em\", \"inline\", \"link\"].includes(nodeSemanticType)\n  ) {\n    semanticType = nodeSemanticType;\n  }\n\n  // Build the map from semantic keys to AST paths\n  if (node.type === \"text\" && node.attributes?.content) {\n    const content = node.attributes.content;\n\n    if (typeof content === \"string\" && content.trim()) {\n      if (semanticType) {\n        const index = counters[semanticType] || 0;\n        counters[semanticType] = index + 1;\n        const semanticKey = `${semanticType}-${index}`;\n        const contentPath = path\n          ? `${path}/attributes/content`\n          : \"attributes/content\";\n        pathMap[semanticKey] = contentPath;\n      }\n    }\n  }\n\n  // Recursively build map for children\n  if (Array.isArray(node.children)) {\n    node.children.forEach((child, index) => {\n      const childPath = path\n        ? `${path}/children/${index}`\n        : `children/${index}`;\n      buildPathMap(child, childPath, counters, pathMap, semanticType);\n    });\n  }\n}\n\nfunction applyTranslations(\n  node: MarkdocNode,\n  path: string,\n  data: Record<string, string>,\n  pathMap: NodePathMap,\n) {\n  if (!node || typeof node !== \"object\") {\n    return;\n  }\n\n  // Check if we have a translation for this node's text content\n  // Only apply translations to string content (not interpolation)\n  if (node.type === \"text\" && node.attributes?.content) {\n    const content = node.attributes.content;\n\n    // Only apply translation if content is currently a string\n    if (typeof content === \"string\") {\n      const contentPath = path\n        ? `${path}/attributes/content`\n        : \"attributes/content\";\n\n      // Find the semantic key for this path\n      const semanticKey = Object.keys(pathMap).find(\n        (key) => pathMap[key] === contentPath,\n      );\n\n      if (semanticKey && data[semanticKey] !== undefined) {\n        node.attributes.content = data[semanticKey];\n      }\n    }\n    // If content is an object (Variable/Function), leave it unchanged\n  }\n\n  // Recursively apply translations to children\n  if (Array.isArray(node.children)) {\n    node.children.forEach((child, index) => {\n      const childPath = path\n        ? `${path}/children/${index}`\n        : `children/${index}`;\n      applyTranslations(child, childPath, data, pathMap);\n    });\n  }\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createPropertiesLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, text) {\n      const result: Record<string, string> = {};\n      const lines = text.split(\"\\n\");\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n\n        // Skip empty lines and comments\n        if (isSkippableLine(trimmed)) {\n          continue;\n        }\n\n        const { key, value } = parsePropertyLine(trimmed);\n        if (key) {\n          result[key] = value;\n        }\n      }\n\n      return result;\n    },\n    async push(locale, payload) {\n      const result = Object.entries(payload)\n        .filter(([_, value]) => value != null)\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\"\\n\");\n\n      return result;\n    },\n  });\n}\n\nfunction isSkippableLine(line: string): boolean {\n  return !line || line.startsWith(\"#\");\n}\n\nfunction parsePropertyLine(line: string): { key: string; value: string } {\n  const [key, ...valueParts] = line.split(\"=\");\n  return {\n    key: key?.trim() || \"\",\n    value: valueParts.join(\"=\").trim(),\n  };\n}\n","import { Token, TokenType, Position } from \"./types\";\n\nexport class Tokenizer {\n  private input: string;\n  private pos: number;\n  private line: number;\n  private column: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.pos = 0;\n    this.line = 1;\n    this.column = 1;\n  }\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (this.pos < this.input.length) {\n      const char = this.current();\n\n      // Skip whitespace\n      if (this.isWhitespace(char)) {\n        this.advance();\n        continue;\n      }\n\n      // Handle comments\n      if (char === \"/\" && this.peek() === \"/\") {\n        tokens.push(this.scanSingleLineComment());\n        continue;\n      }\n\n      if (char === \"/\" && this.peek() === \"*\") {\n        tokens.push(this.scanMultiLineComment());\n        continue;\n      }\n\n      // Handle strings\n      if (char === '\"') {\n        tokens.push(this.scanString());\n        continue;\n      }\n\n      // Handle operators\n      if (char === \"=\") {\n        tokens.push(this.makeToken(TokenType.EQUALS, \"=\"));\n        this.advance();\n        continue;\n      }\n\n      if (char === \";\") {\n        tokens.push(this.makeToken(TokenType.SEMICOLON, \";\"));\n        this.advance();\n        continue;\n      }\n\n      // Unexpected character - skip it\n      // (More forgiving than throwing error)\n      this.advance();\n    }\n\n    tokens.push(this.makeToken(TokenType.EOF, \"\"));\n    return tokens;\n  }\n\n  private scanString(): Token {\n    const start = this.getPosition();\n    let value = \"\";\n\n    this.advance(); // Skip opening \"\n\n    while (this.pos < this.input.length) {\n      const char = this.current();\n\n      if (char === \"\\\\\") {\n        // Escape sequence - preserve both \\ and next char\n        this.advance();\n        if (this.pos < this.input.length) {\n          const nextChar = this.current();\n          value += \"\\\\\" + nextChar;\n          this.advance();\n        }\n        continue;\n      }\n\n      if (char === '\"') {\n        // End of string\n        this.advance(); // Skip closing \"\n        return {\n          type: TokenType.STRING,\n          value,\n          ...start,\n        };\n      }\n\n      // Regular character (including actual newlines)\n      value += char;\n      this.advance();\n    }\n\n    // Unterminated string - return what we have\n    return {\n      type: TokenType.STRING,\n      value,\n      ...start,\n    };\n  }\n\n  private scanSingleLineComment(): Token {\n    const start = this.getPosition();\n    let value = \"\";\n\n    this.advance(); // Skip first '/'\n    this.advance(); // Skip second '/'\n\n    while (this.pos < this.input.length && this.current() !== \"\\n\") {\n      value += this.current();\n      this.advance();\n    }\n\n    return {\n      type: TokenType.COMMENT_SINGLE,\n      value,\n      ...start,\n    };\n  }\n\n  private scanMultiLineComment(): Token {\n    const start = this.getPosition();\n    let value = \"\";\n\n    this.advance(); // Skip '/'\n    this.advance(); // Skip '*'\n\n    while (this.pos < this.input.length) {\n      if (this.current() === \"*\" && this.peek() === \"/\") {\n        this.advance(); // Skip '*'\n        this.advance(); // Skip '/'\n        return {\n          type: TokenType.COMMENT_MULTI,\n          value,\n          ...start,\n        };\n      }\n\n      value += this.current();\n      this.advance();\n    }\n\n    // Unterminated comment - return what we have\n    return {\n      type: TokenType.COMMENT_MULTI,\n      value,\n      ...start,\n    };\n  }\n\n  private current(): string {\n    return this.input[this.pos];\n  }\n\n  private peek(): string | null {\n    if (this.pos + 1 < this.input.length) {\n      return this.input[this.pos + 1];\n    }\n    return null;\n  }\n\n  private advance(): void {\n    if (this.pos < this.input.length) {\n      if (this.current() === \"\\n\") {\n        this.line++;\n        this.column = 1;\n      } else {\n        this.column++;\n      }\n      this.pos++;\n    }\n  }\n\n  private isWhitespace(char: string): boolean {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n  }\n\n  private getPosition(): Position {\n    return {\n      line: this.line,\n      column: this.column,\n    };\n  }\n\n  private makeToken(type: TokenType, value: string): Token {\n    return {\n      type,\n      value,\n      ...this.getPosition(),\n    };\n  }\n}\n","/**\n * Unescape a string value from .strings file format\n * Handles: \\\", \\\\, \\n, \\t, etc.\n */\nexport function unescapeString(raw: string): string {\n  let result = \"\";\n  let i = 0;\n\n  while (i < raw.length) {\n    if (raw[i] === \"\\\\\" && i + 1 < raw.length) {\n      const nextChar = raw[i + 1];\n      switch (nextChar) {\n        case '\"':\n          result += '\"';\n          i += 2;\n          break;\n        case \"\\\\\":\n          result += \"\\\\\";\n          i += 2;\n          break;\n        case \"n\":\n          result += \"\\n\";\n          i += 2;\n          break;\n        case \"t\":\n          result += \"\\t\";\n          i += 2;\n          break;\n        case \"r\":\n          result += \"\\r\";\n          i += 2;\n          break;\n        default:\n          // Unknown escape - keep as-is\n          result += raw[i];\n          i++;\n          break;\n      }\n    } else {\n      result += raw[i];\n      i++;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Escape a string value for .strings file format\n * Escapes: \\, \", newlines to \\n\n */\nexport function escapeString(str: string): string {\n  if (str == null) {\n    return \"\";\n  }\n\n  let result = \"\";\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    switch (char) {\n      case \"\\\\\":\n        result += \"\\\\\\\\\";\n        break;\n      case '\"':\n        result += '\\\\\"';\n        break;\n      case \"\\n\":\n        result += \"\\\\n\";\n        break;\n      case \"\\r\":\n        result += \"\\\\r\";\n        break;\n      case \"\\t\":\n        result += \"\\\\t\";\n        break;\n      default:\n        result += char;\n        break;\n    }\n  }\n\n  return result;\n}\n","import { Token, TokenType } from \"./types\";\nimport { unescapeString } from \"./escape\";\n\nexport class Parser {\n  private tokens: Token[];\n  private pos: number;\n\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n    this.pos = 0;\n  }\n\n  parse(): Record<string, string> {\n    const result: Record<string, string> = {};\n\n    while (this.pos < this.tokens.length) {\n      const token = this.current();\n\n      // Skip comments\n      if (\n        token.type === TokenType.COMMENT_SINGLE ||\n        token.type === TokenType.COMMENT_MULTI\n      ) {\n        this.advance();\n        continue;\n      }\n\n      // End of file\n      if (token.type === TokenType.EOF) {\n        break;\n      }\n\n      // Expect entry: STRING \"=\" STRING \";\"\n      if (token.type === TokenType.STRING) {\n        const entry = this.parseEntry();\n        if (entry) {\n          result[entry.key] = entry.value;\n        }\n        continue;\n      }\n\n      // Skip unexpected tokens gracefully\n      this.advance();\n    }\n\n    return result;\n  }\n\n  private parseEntry(): { key: string; value: string } | null {\n    // Current token should be STRING (key)\n    const keyToken = this.current();\n    if (keyToken.type !== TokenType.STRING) {\n      return null;\n    }\n    const key = keyToken.value;\n    this.advance();\n\n    // Expect '='\n    if (!this.expect(TokenType.EQUALS)) {\n      // Missing '=' - skip this entry\n      return null;\n    }\n\n    // Expect STRING (value)\n    const valueToken = this.current();\n    if (valueToken.type !== TokenType.STRING) {\n      // Missing value - skip this entry\n      return null;\n    }\n    const rawValue = valueToken.value;\n    this.advance();\n\n    // Expect ';'\n    if (!this.expect(TokenType.SEMICOLON)) {\n      // Missing ';' - but still process the entry\n      // (more forgiving)\n    }\n\n    // Unescape the value\n    const value = unescapeString(rawValue);\n\n    return { key, value };\n  }\n\n  private current(): Token {\n    return this.tokens[this.pos];\n  }\n\n  private advance(): void {\n    if (this.pos < this.tokens.length) {\n      this.pos++;\n    }\n  }\n\n  private expect(type: TokenType): boolean {\n    if (this.current()?.type === type) {\n      this.advance();\n      return true;\n    }\n    return false;\n  }\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { Tokenizer } from \"./xcode-strings/tokenizer\";\nimport { Parser } from \"./xcode-strings/parser\";\nimport { escapeString } from \"./xcode-strings/escape\";\n\nexport default function createXcodeStringsLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      // Tokenize the input\n      const tokenizer = new Tokenizer(input);\n      const tokens = tokenizer.tokenize();\n\n      // Parse tokens into key-value pairs\n      const parser = new Parser(tokens);\n      const result = parser.parse();\n\n      return result;\n    },\n\n    async push(locale, payload) {\n      const lines = Object.entries(payload)\n        .filter(([_, value]) => value != null)\n        .map(([key, value]) => {\n          const escapedValue = escapeString(value);\n          return `\"${key}\" = \"${escapedValue}\";`;\n        });\n\n      return lines.join(\"\\n\");\n    },\n  });\n}\n","import plist from \"plist\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { CLIError } from \"../utils/errors\";\n\nconst emptyData = [\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n  '<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">',\n  '<plist version=\"1.0\">',\n  \"<dict/>\",\n  \"</plist>\",\n].join(\"\\n\");\n\nexport default function createXcodeStringsdictLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      try {\n        const parsed = plist.parse(input || emptyData);\n        if (typeof parsed !== \"object\" || parsed === null) {\n          throw new CLIError({\n            message: \"Invalid .stringsdict format\",\n            docUrl: \"invalidStringDict\",\n          });\n        }\n        return parsed as Record<string, any>;\n      } catch (error: any) {\n        throw new CLIError({\n          message: `Invalid .stringsdict format: ${error.message}`,\n          docUrl: \"invalidStringDict\",\n        });\n      }\n    },\n    async push(locale, payload) {\n      const plistContent = plist.build(payload);\n      return plistContent;\n    },\n  });\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport _ from \"lodash\";\n\nexport default function createXcodeXcstringsLoader(\n  defaultLocale: string,\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    async pull(locale, input, initCtx) {\n      const resultData: Record<string, any> = {};\n      const isSourceLanguage = locale === defaultLocale;\n\n      for (const [translationKey, _translationEntity] of Object.entries(\n        (input as any).strings,\n      )) {\n        const rootTranslationEntity = _translationEntity as any;\n\n        if (rootTranslationEntity.shouldTranslate === false) {\n          continue;\n        }\n\n        const langTranslationEntity =\n          rootTranslationEntity?.localizations?.[locale];\n\n        if (langTranslationEntity) {\n          if (\"stringUnit\" in langTranslationEntity) {\n            resultData[translationKey] = langTranslationEntity.stringUnit.value;\n          } else if (\"variations\" in langTranslationEntity) {\n            if (\"plural\" in langTranslationEntity.variations) {\n              resultData[translationKey] = {};\n              const pluralForms = langTranslationEntity.variations.plural;\n              for (const form in pluralForms) {\n                if (pluralForms[form]?.stringUnit?.value) {\n                  resultData[translationKey][form] =\n                    pluralForms[form].stringUnit.value;\n                }\n              }\n            }\n          }\n        } else if (isSourceLanguage) {\n          resultData[translationKey] = translationKey;\n        }\n      }\n\n      return resultData;\n    },\n    async push(locale, payload, originalInput) {\n      const langDataToMerge: any = {};\n      langDataToMerge.strings = {};\n\n      const input = _.cloneDeep(originalInput) || {\n        sourceLanguage: locale,\n        strings: {},\n      };\n\n      for (const [key, value] of Object.entries(payload)) {\n        if (value === null || value === undefined) {\n          continue;\n        }\n\n        const hasDoNotTranslateFlag =\n          originalInput &&\n          (originalInput as any).strings &&\n          (originalInput as any).strings[key] &&\n          (originalInput as any).strings[key].shouldTranslate === false;\n\n        if (typeof value === \"string\") {\n          langDataToMerge.strings[key] = {\n            extractionState: originalInput?.strings?.[key]?.extractionState,\n            localizations: {\n              [locale]: {\n                stringUnit: {\n                  state: \"translated\",\n                  value,\n                },\n              },\n            },\n          };\n\n          if (hasDoNotTranslateFlag) {\n            langDataToMerge.strings[key].shouldTranslate = false;\n          }\n        } else {\n          const updatedVariations: any = {};\n\n          for (const form in value) {\n            updatedVariations[form] = {\n              stringUnit: {\n                state: \"translated\",\n                value: value[form],\n              },\n            };\n          }\n\n          langDataToMerge.strings[key] = {\n            extractionState: \"manual\",\n            localizations: {\n              [locale]: {\n                variations: {\n                  plural: updatedVariations,\n                },\n              },\n            },\n          };\n\n          if (hasDoNotTranslateFlag) {\n            langDataToMerge.strings[key].shouldTranslate = false;\n          }\n        }\n      }\n\n      const originalInputWithoutLocale = originalInput\n        ? _removeLocale(originalInput, locale)\n        : {};\n\n      const result = _.merge({}, originalInputWithoutLocale, langDataToMerge);\n      return result;\n    },\n    async pullHints(originalInput) {\n      if (!originalInput || !originalInput.strings) {\n        return {};\n      }\n\n      const hints: Record<string, any> = {};\n\n      for (const [translationKey, translationEntity] of Object.entries(\n        originalInput.strings,\n      )) {\n        const entity = translationEntity as any;\n\n        // Extract comment field if it exists\n        if (entity.comment && typeof entity.comment === \"string\") {\n          hints[translationKey] = { hint: entity.comment };\n        }\n\n        // For plural forms, we might want to include the base comment for all variants\n        if (entity.localizations) {\n          for (const [locale, localization] of Object.entries(\n            entity.localizations,\n          )) {\n            if ((localization as any).variations?.plural) {\n              const pluralForms = (localization as any).variations.plural;\n              for (const form in pluralForms) {\n                const pluralKey = `${translationKey}/${form}`;\n                if (entity.comment && typeof entity.comment === \"string\") {\n                  hints[pluralKey] = { hint: entity.comment };\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return hints;\n    },\n  });\n}\n\nexport function _removeLocale(input: Record<string, any>, locale: string) {\n  const { strings } = input;\n  const newStrings = _.cloneDeep(strings);\n  for (const [key, value] of Object.entries(newStrings)) {\n    if ((value as any).localizations?.[locale]) {\n      delete (value as any).localizations[locale];\n    }\n  }\n  return { ...input, strings: newStrings };\n}\n","/**\n * ICU MessageFormat conversion utilities for xcstrings pluralization\n *\n * This module handles converting between xcstrings plural format and ICU MessageFormat,\n * preserving format specifier precision and supporting multiple variables.\n */\n\n/**\n * Type guard marker to distinguish ICU objects from user data\n * Using a symbol ensures no collision with user data\n */\nconst ICU_TYPE_MARKER = Symbol.for(\"@lingo.dev/icu-plural-object\");\n\nexport interface PluralWithMetadata {\n  icu: string;\n  _meta?: {\n    variables: {\n      [varName: string]: {\n        format: string;\n        role: \"plural\" | \"other\";\n      };\n    };\n  };\n  // Type marker for robust detection\n  [ICU_TYPE_MARKER]?: true;\n}\n\n/**\n * CLDR plural categories as defined by Unicode\n * https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/language_plural_rules.html\n */\nconst CLDR_PLURAL_CATEGORIES = new Set([\n  \"zero\",\n  \"one\",\n  \"two\",\n  \"few\",\n  \"many\",\n  \"other\",\n]);\n\n/**\n * Type guard to check if a value is a valid ICU object with metadata\n * This is more robust than simple key checking\n */\nexport function isICUPluralObject(value: any): value is PluralWithMetadata {\n  if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n    return false;\n  }\n\n  // Check for type marker (most reliable)\n  if (ICU_TYPE_MARKER in value) {\n    return true;\n  }\n\n  // Fallback: validate structure thoroughly\n  if (!(\"icu\" in value) || typeof value.icu !== \"string\") {\n    return false;\n  }\n\n  // Must match ICU plural format pattern\n  const icuPluralPattern = /^\\{[\\w]+,\\s*plural,\\s*.+\\}$/;\n  if (!icuPluralPattern.test(value.icu)) {\n    return false;\n  }\n\n  // If _meta exists, validate its structure\n  if (value._meta !== undefined) {\n    if (\n      typeof value._meta !== \"object\" ||\n      !value._meta.variables ||\n      typeof value._meta.variables !== \"object\"\n    ) {\n      return false;\n    }\n\n    // Validate each variable entry\n    for (const [varName, varMeta] of Object.entries(value._meta.variables)) {\n      if (\n        !varMeta ||\n        typeof varMeta !== \"object\" ||\n        typeof (varMeta as any).format !== \"string\" ||\n        ((varMeta as any).role !== \"plural\" &&\n          (varMeta as any).role !== \"other\")\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Type guard to check if an object is a valid plural forms object\n * Ensures ALL keys are CLDR categories to avoid false positives\n */\nexport function isPluralFormsObject(\n  value: any,\n): value is Record<string, string> {\n  if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n    return false;\n  }\n\n  const keys = Object.keys(value);\n\n  // Must have at least one key\n  if (keys.length === 0) {\n    return false;\n  }\n\n  // Check if ALL keys are CLDR plural categories\n  const allKeysAreCldr = keys.every((key) => CLDR_PLURAL_CATEGORIES.has(key));\n\n  if (!allKeysAreCldr) {\n    return false;\n  }\n\n  // Check if all values are strings\n  const allValuesAreStrings = keys.every(\n    (key) => typeof value[key] === \"string\",\n  );\n\n  if (!allValuesAreStrings) {\n    return false;\n  }\n\n  // Must have at least \"other\" form (required in all locales)\n  if (!(\"other\" in value)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Get required CLDR plural categories for a locale\n *\n * @throws {Error} If locale is invalid and cannot be resolved\n */\nfunction getRequiredPluralCategories(locale: string): string[] {\n  try {\n    const pluralRules = new Intl.PluralRules(locale);\n    const categories = pluralRules.resolvedOptions().pluralCategories;\n\n    if (!categories || categories.length === 0) {\n      throw new Error(`No plural categories found for locale: ${locale}`);\n    }\n\n    return categories;\n  } catch (error) {\n    // Log warning but use safe fallback\n    console.warn(\n      `[xcode-xcstrings-icu] Failed to resolve plural categories for locale \"${locale}\". ` +\n        `Using fallback [\"one\", \"other\"]. Error: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    return [\"one\", \"other\"];\n  }\n}\n\n/**\n * Map CLDR category names to their numeric values for exact match conversion\n */\nconst CLDR_CATEGORY_TO_NUMBER: Record<string, number> = {\n  zero: 0,\n  one: 1,\n  two: 2,\n};\n\n/**\n * Map numeric values back to CLDR category names\n */\nconst NUMBER_TO_CLDR_CATEGORY: Record<number, string> = {\n  0: \"zero\",\n  1: \"one\",\n  2: \"two\",\n};\n\n/**\n * Convert xcstrings plural forms to ICU MessageFormat with metadata\n *\n * @param pluralForms - Record of plural forms (e.g., { one: \"1 item\", other: \"%d items\" })\n * @param sourceLocale - Source language locale (e.g., \"en\", \"ru\") to determine required vs optional forms\n * @returns ICU string with metadata for format preservation\n *\n * @example\n * xcstringsToPluralWithMeta({ one: \"1 mile\", other: \"%.1f miles\" }, \"en\")\n * // Returns:\n * // {\n * //   icu: \"{count, plural, one {1 mile} other {# miles}}\",\n * //   _meta: { variables: { count: { format: \"%.1f\", role: \"plural\" } } }\n * // }\n *\n * @example\n * xcstringsToPluralWithMeta({ zero: \"No items\", one: \"1 item\", other: \"%d items\" }, \"en\")\n * // Returns:\n * // {\n * //   icu: \"{count, plural, =0 {No items} one {1 item} other {# items}}\",\n * //   _meta: { variables: { count: { format: \"%d\", role: \"plural\" } } }\n * // }\n */\nexport function xcstringsToPluralWithMeta(\n  pluralForms: Record<string, string>,\n  sourceLocale: string = \"en\",\n): PluralWithMetadata {\n  if (!pluralForms || Object.keys(pluralForms).length === 0) {\n    throw new Error(\"pluralForms cannot be empty\");\n  }\n\n  // Get required CLDR categories for this locale\n  const requiredCategories = getRequiredPluralCategories(sourceLocale);\n\n  const variables: Record<\n    string,\n    { format: string; role: \"plural\" | \"other\" }\n  > = {};\n\n  // Regex to match format specifiers:\n  // %[position$][flags][width][.precision][length]specifier\n  // Examples: %d, %lld, %.2f, %@, %1$@, %2$lld\n  const formatRegex =\n    /(%(?:(\\d+)\\$)?(?:[+-])?(?:\\d+)?(?:\\.(\\d+))?([lhqLzjt]*)([diuoxXfFeEgGaAcspn@]))/g;\n\n  // Analyze ALL forms to find the one with most variables (typically \"other\")\n  let maxMatches: RegExpMatchArray[] = [];\n  let maxMatchText = \"\";\n  for (const [form, text] of Object.entries(pluralForms)) {\n    // Skip if text is not a string\n    if (typeof text !== \"string\") {\n      console.warn(\n        `Warning: Plural form \"${form}\" has non-string value:`,\n        text,\n      );\n      continue;\n    }\n    const matches = [...text.matchAll(formatRegex)];\n    if (matches.length > maxMatches.length) {\n      maxMatches = matches;\n      maxMatchText = text;\n    }\n  }\n\n  let lastNumericIndex = -1;\n\n  // Find which variable is the plural one (heuristic: last numeric format)\n  maxMatches.forEach((match, idx) => {\n    const specifier = match[5];\n    // Numeric specifiers that could be plural counts\n    if (/[diuoxXfFeE]/.test(specifier)) {\n      lastNumericIndex = idx;\n    }\n  });\n\n  // Build variable metadata\n  let nonPluralCounter = 0;\n  maxMatches.forEach((match, idx) => {\n    const fullFormat = match[1]; // e.g., \"%.2f\", \"%lld\", \"%@\"\n    const position = match[2]; // e.g., \"1\" from \"%1$@\"\n    const precision = match[3]; // e.g., \"2\" from \"%.2f\"\n    const lengthMod = match[4]; // e.g., \"ll\" from \"%lld\"\n    const specifier = match[5]; // e.g., \"f\", \"d\", \"@\"\n\n    const isPluralVar = idx === lastNumericIndex;\n    const varName = isPluralVar ? \"count\" : `var${nonPluralCounter++}`;\n\n    variables[varName] = {\n      format: fullFormat,\n      role: isPluralVar ? \"plural\" : \"other\",\n    };\n  });\n\n  // Build ICU string for each plural form\n  const variableKeys = Object.keys(variables);\n  const icuForms = Object.entries(pluralForms)\n    .filter(([form, text]) => {\n      // Skip non-string values\n      if (typeof text !== \"string\") {\n        return false;\n      }\n      return true;\n    })\n    .map(([form, text]) => {\n      let processed = text as string;\n      let vIdx = 0;\n\n      // Replace format specifiers with ICU equivalents\n      processed = processed.replace(formatRegex, () => {\n        if (vIdx >= variableKeys.length) {\n          // Shouldn't happen, but fallback\n          vIdx++;\n          return \"#\";\n        }\n\n        const varName = variableKeys[vIdx];\n        const varMeta = variables[varName];\n        vIdx++;\n\n        if (varMeta.role === \"plural\") {\n          // Plural variable uses # in ICU\n          return \"#\";\n        } else {\n          // Non-plural variables use {varName}\n          return `{${varName}}`;\n        }\n      });\n\n      // Determine if this form is required or optional\n      const isRequired = requiredCategories.includes(form);\n      const formKey =\n        !isRequired && form in CLDR_CATEGORY_TO_NUMBER\n          ? `=${CLDR_CATEGORY_TO_NUMBER[form]}` // Convert optional forms to exact matches\n          : form; // Keep required forms as CLDR keywords\n\n      return `${formKey} {${processed}}`;\n    })\n    .join(\" \");\n\n  // Find plural variable name\n  const pluralVarName =\n    Object.keys(variables).find((name) => variables[name].role === \"plural\") ||\n    \"count\";\n\n  const icu = `{${pluralVarName}, plural, ${icuForms}}`;\n\n  const result: PluralWithMetadata = {\n    icu,\n    _meta: Object.keys(variables).length > 0 ? { variables } : undefined,\n    [ICU_TYPE_MARKER]: true, // Add type marker for robust detection\n  };\n\n  return result;\n}\n\n/**\n * Convert ICU MessageFormat with metadata back to xcstrings plural forms\n *\n * Uses metadata to restore original format specifiers with full precision.\n *\n * @param data - ICU string with metadata\n * @returns Record of plural forms suitable for xcstrings\n *\n * @example\n * pluralWithMetaToXcstrings({\n *   icu: \"{count, plural, one {# –∫–∏–ª–æ–º–µ—Ç—Ä} other {# –∫–∏–ª–æ–º–µ—Ç—Ä–æ–≤}}\",\n *   _meta: { variables: { count: { format: \"%.1f\", role: \"plural\" } } }\n * })\n * // Returns: { one: \"%.1f –∫–∏–ª–æ–º–µ—Ç—Ä\", other: \"%.1f –∫–∏–ª–æ–º–µ—Ç—Ä–æ–≤\" }\n */\nexport function pluralWithMetaToXcstrings(\n  data: PluralWithMetadata,\n): Record<string, string> {\n  if (!data.icu) {\n    throw new Error(\"ICU string is required\");\n  }\n\n  // Parse ICU MessageFormat string\n  const ast = parseICU(data.icu);\n\n  if (!ast || ast.length === 0) {\n    throw new Error(\"Invalid ICU format\");\n  }\n\n  // Find the plural node\n  const pluralNode = ast.find((node) => node.type === \"plural\");\n\n  if (!pluralNode) {\n    throw new Error(\"No plural found in ICU format\");\n  }\n\n  const forms: Record<string, string> = {};\n\n  // Convert each plural form back to xcstrings format\n  for (const [form, option] of Object.entries(pluralNode.options)) {\n    let text = \"\";\n\n    const optionValue = (option as any).value;\n    for (const element of optionValue) {\n      if (element.type === \"literal\") {\n        // Plain text\n        text += element.value;\n      } else if (element.type === \"pound\") {\n        // # ‚Üí look up plural variable format in metadata\n        const pluralVar = Object.entries(data._meta?.variables || {}).find(\n          ([_, meta]) => meta.role === \"plural\",\n        );\n\n        text += pluralVar?.[1].format || \"%lld\";\n      } else if (element.type === \"argument\") {\n        // {varName} ‚Üí look up variable format by name\n        const varName = element.value;\n        const varMeta = data._meta?.variables?.[varName];\n\n        text += varMeta?.format || \"%@\";\n      }\n    }\n\n    // Convert exact matches (=0, =1) back to CLDR category names\n    let xcstringsFormName = form;\n    if (form.startsWith(\"=\")) {\n      const numValue = parseInt(form.substring(1), 10);\n      xcstringsFormName = NUMBER_TO_CLDR_CATEGORY[numValue] || form;\n    }\n\n    forms[xcstringsFormName] = text;\n  }\n\n  return forms;\n}\n\n/**\n * Simple ICU MessageFormat parser\n *\n * This is a lightweight parser for our specific use case.\n * For production, consider using @formatjs/icu-messageformat-parser\n */\nfunction parseICU(icu: string): any[] {\n  // Remove outer braces and split by \"plural,\"\n  const match = icu.match(/\\{(\\w+),\\s*plural,\\s*(.+)\\}$/);\n\n  if (!match) {\n    throw new Error(\"Invalid ICU plural format\");\n  }\n\n  const varName = match[1];\n  const formsText = match[2];\n\n  // Parse plural forms manually to handle nested braces\n  const options: Record<string, any> = {};\n\n  let i = 0;\n  while (i < formsText.length) {\n    // Skip whitespace\n    while (i < formsText.length && /\\s/.test(formsText[i])) {\n      i++;\n    }\n\n    if (i >= formsText.length) break;\n\n    // Read form name (e.g., \"one\", \"other\", \"few\", \"=0\", \"=1\")\n    let formName = \"\";\n\n    // Check for exact match syntax (=0, =1, etc.)\n    if (formsText[i] === \"=\") {\n      formName += formsText[i];\n      i++;\n      // Read the number\n      while (i < formsText.length && /\\d/.test(formsText[i])) {\n        formName += formsText[i];\n        i++;\n      }\n    } else {\n      // Read word form name\n      while (i < formsText.length && /\\w/.test(formsText[i])) {\n        formName += formsText[i];\n        i++;\n      }\n    }\n\n    if (!formName) break;\n\n    // Skip whitespace and find opening brace\n    while (i < formsText.length && /\\s/.test(formsText[i])) {\n      i++;\n    }\n\n    if (i >= formsText.length || formsText[i] !== \"{\") {\n      throw new Error(`Expected '{' after form name '${formName}'`);\n    }\n\n    // Find matching closing brace\n    i++; // skip opening brace\n    let braceCount = 1;\n    let formText = \"\";\n\n    while (i < formsText.length && braceCount > 0) {\n      if (formsText[i] === \"{\") {\n        braceCount++;\n        formText += formsText[i];\n      } else if (formsText[i] === \"}\") {\n        braceCount--;\n        if (braceCount > 0) {\n          formText += formsText[i];\n        }\n      } else {\n        formText += formsText[i];\n      }\n      i++;\n    }\n\n    if (braceCount !== 0) {\n      // Provide detailed error with context\n      const preview = formsText.substring(\n        Math.max(0, i - 50),\n        Math.min(formsText.length, i + 50),\n      );\n      throw new Error(\n        `Unclosed brace for form '${formName}' in ICU MessageFormat.\\n` +\n          `Expected ${braceCount} more closing brace(s).\\n` +\n          `Context: ...${preview}...\\n` +\n          `Full ICU: {${varName}, plural, ${formsText}}`,\n      );\n    }\n\n    // Parse the form text to extract elements\n    const elements = parseFormText(formText);\n\n    options[formName] = {\n      value: elements,\n    };\n  }\n\n  return [\n    {\n      type: \"plural\",\n      value: varName,\n      options,\n    },\n  ];\n}\n\n/**\n * Parse form text into elements (literals, pounds, arguments)\n */\nfunction parseFormText(text: string): any[] {\n  const elements: any[] = [];\n  let currentText = \"\";\n  let i = 0;\n\n  while (i < text.length) {\n    if (text[i] === \"#\") {\n      // Add accumulated text as literal\n      if (currentText) {\n        elements.push({ type: \"literal\", value: currentText });\n        currentText = \"\";\n      }\n      // Add pound element\n      elements.push({ type: \"pound\" });\n      i++;\n    } else if (text[i] === \"{\") {\n      // Variable reference - need to handle nested braces\n      // Add accumulated text as literal\n      if (currentText) {\n        elements.push({ type: \"literal\", value: currentText });\n        currentText = \"\";\n      }\n\n      // Find matching closing brace (handle nesting)\n      let braceCount = 1;\n      let j = i + 1;\n      while (j < text.length && braceCount > 0) {\n        if (text[j] === \"{\") {\n          braceCount++;\n        } else if (text[j] === \"}\") {\n          braceCount--;\n        }\n        j++;\n      }\n\n      if (braceCount !== 0) {\n        throw new Error(\"Unclosed variable reference\");\n      }\n\n      // j is now positioned after the closing brace\n      const varName = text.slice(i + 1, j - 1);\n      elements.push({ type: \"argument\", value: varName });\n\n      i = j;\n    } else {\n      currentText += text[i];\n      i++;\n    }\n  }\n\n  // Add remaining text\n  if (currentText) {\n    elements.push({ type: \"literal\", value: currentText });\n  }\n\n  return elements;\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport {\n  xcstringsToPluralWithMeta,\n  pluralWithMetaToXcstrings,\n  isPluralFormsObject,\n  isICUPluralObject,\n} from \"./xcode-xcstrings-icu\";\n\n/**\n * Loader for xcode-xcstrings-v2 bucket type with ICU MessageFormat support.\n *\n * This should be placed AFTER xcode-xcstrings loader and BEFORE flat loader.\n *\n * Input:  {items: {zero: \"No items\", one: \"1 item\", other: \"%d items\"}}\n * Output: {items: {icu: \"{count, plural, =0 {No items} one {1 item} other {# items}}\", _meta: {...}}}\n *\n * Lock files will contain checksums of ICU format (new format for pluralization support).\n */\nexport default function createXcodeXcstringsV2Loader(\n  defaultLocale: string = \"en\",\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    async pull(locale, input) {\n      const result: Record<string, any> = {};\n\n      for (const [key, value] of Object.entries(input)) {\n        if (isPluralFormsObject(value)) {\n          try {\n            result[key] = xcstringsToPluralWithMeta(value, locale);\n          } catch (error) {\n            console.error(\n              `\\n[xcode-xcstrings-icu] Failed to convert plural forms for key \"${key}\":`,\n              `\\nError: ${error instanceof Error ? error.message : String(error)}`,\n              `\\nLocale: ${locale}\\n`,\n            );\n            result[key] = value;\n          }\n        } else {\n          result[key] = value;\n        }\n      }\n\n      return result;\n    },\n\n    async push(locale, payload) {\n      const result: Record<string, any> = {};\n\n      for (const [key, value] of Object.entries(payload)) {\n        if (isICUPluralObject(value)) {\n          try {\n            const pluralForms = pluralWithMetaToXcstrings(value);\n            result[key] = pluralForms;\n          } catch (error) {\n            throw new Error(\n              `Failed to write plural translation for key \"${key}\" (locale: ${locale}).\\n` +\n                `${error instanceof Error ? error.message : String(error)}`,\n            );\n          }\n        } else {\n          result[key] = value;\n        }\n      }\n\n      return result;\n    },\n  });\n}\n","import _ from \"lodash\";\nimport _isUrl from \"is-url\";\nimport { isValid, parseISO } from \"date-fns\";\n\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createUnlocalizableLoader(\n  returnUnlocalizedKeys: boolean = false,\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    async pull(locale, input) {\n      const unlocalizableKeys = _getUnlocalizableKeys(input);\n\n      const result = _.omitBy(input, (_, key) =>\n        unlocalizableKeys.includes(key),\n      );\n\n      if (returnUnlocalizedKeys) {\n        result.unlocalizable = _.omitBy(\n          input,\n          (_, key) => !unlocalizableKeys.includes(key),\n        );\n      }\n\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      const unlocalizableKeys = _getUnlocalizableKeys(originalInput);\n\n      const result = _.merge(\n        {},\n        data,\n        _.omitBy(originalInput, (_, key) => !unlocalizableKeys.includes(key)),\n      );\n\n      return result;\n    },\n  });\n}\n\nfunction _isSystemId(v: string) {\n  return /^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)[A-Za-z0-9]{22}$/.test(v);\n}\n\nfunction _isIsoDate(v: string) {\n  return isValid(parseISO(v));\n}\n\nfunction _getUnlocalizableKeys(input?: Record<string, any> | null) {\n  const rules = {\n    isEmpty: (v: any) => _.isEmpty(v),\n    isNumber: (v: any) => typeof v === \"number\" || /^[0-9]+$/.test(v),\n    isBoolean: (v: any) => _.isBoolean(v),\n    isIsoDate: (v: any) => _.isString(v) && _isIsoDate(v),\n    isSystemId: (v: any) => _.isString(v) && _isSystemId(v),\n    isUrl: (v: any) => _.isString(v) && _isUrl(v),\n  };\n\n  if (!input) {\n    return [];\n  }\n\n  return Object.entries(input)\n    .filter(([key, value]) => {\n      for (const [ruleName, rule] of Object.entries(rules)) {\n        if (rule(value)) {\n          return true;\n        }\n      }\n      return false;\n    })\n    .map(([key, _]) => key);\n}\n","import prettier, { Options } from \"prettier\";\nimport { ILoader } from \"../_types\";\nimport { createBaseFormatterLoader } from \"./_base\";\n\nexport type PrettierLoaderOptions = {\n  parser: Options[\"parser\"];\n  bucketPathPattern: string;\n  stage?: \"pull\" | \"push\" | \"both\";\n  alwaysFormat?: boolean;\n};\n\nexport default function createPrettierLoader(\n  options: PrettierLoaderOptions,\n): ILoader<string, string> {\n  return createBaseFormatterLoader(options, async (data, filePath) => {\n    return await formatDataWithPrettier(data, filePath, options);\n  });\n}\n\nasync function loadPrettierConfig(filePath: string) {\n  try {\n    const config = await prettier.resolveConfig(filePath);\n    return config;\n  } catch (error) {\n    return {};\n  }\n}\n\nasync function formatDataWithPrettier(\n  data: string,\n  filePath: string,\n  options: PrettierLoaderOptions,\n): Promise<string> {\n  const prettierConfig = await loadPrettierConfig(filePath);\n\n  // Skip formatting if no config found and alwaysFormat is not enabled\n  if (!prettierConfig && !options.alwaysFormat) {\n    return data;\n  }\n\n  const config: Options = {\n    ...(prettierConfig || { printWidth: 2500, bracketSameLine: false }),\n    parser: options.parser,\n    // For HTML parser, preserve comments and quotes\n    ...(options.parser === \"html\"\n      ? {\n          htmlWhitespaceSensitivity: \"ignore\",\n          singleQuote: false,\n          embeddedLanguageFormatting: \"off\",\n        }\n      : {}),\n  };\n\n  try {\n    // format with prettier\n    return await prettier.format(data, config);\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.startsWith(\"Cannot find package\")\n    ) {\n      console.log();\n      console.log(\n        \"‚ö†Ô∏è  Prettier plugins are not installed. Formatting without plugins.\",\n      );\n      console.log(\n        \"‚ö†Ô∏è  To use prettier plugins install project dependencies before running Lingo.dev.\",\n      );\n\n      config.plugins = [];\n\n      // clear file system structure cache\n      await prettier.clearConfigCache();\n\n      // format again without plugins\n      return await prettier.format(data, config);\n    }\n\n    throw error;\n  }\n}\n","import path from \"path\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\n\nexport type BaseFormatterOptions = {\n  bucketPathPattern: string;\n  stage?: \"pull\" | \"push\" | \"both\";\n  alwaysFormat?: boolean;\n};\n\nexport function createBaseFormatterLoader(\n  options: BaseFormatterOptions,\n  formatFn: (data: string, filePath: string) => Promise<string>,\n): ILoader<string, string> {\n  const stage = options.stage || \"both\";\n\n  const formatData = async (locale: string, data: string) => {\n    const draftPath = options.bucketPathPattern.replaceAll(\"[locale]\", locale);\n    const finalPath = path.resolve(draftPath);\n    return await formatFn(data, finalPath);\n  };\n\n  return createLoader({\n    async pull(locale, data) {\n      if (![\"pull\", \"both\"].includes(stage)) {\n        return data;\n      }\n      return await formatData(locale, data);\n    },\n    async push(locale, data) {\n      if (![\"push\", \"both\"].includes(stage)) {\n        return data;\n      }\n      return await formatData(locale, data);\n    },\n  });\n}\n","import path from \"path\";\nimport fs from \"fs/promises\";\nimport { Biome, Distribution } from \"@biomejs/js-api\";\nimport { parse as parseJsonc } from \"jsonc-parser\";\nimport { ILoader } from \"../_types\";\nimport { createBaseFormatterLoader } from \"./_base\";\n\nexport type BiomeLoaderOptions = {\n  bucketPathPattern: string;\n  stage?: \"pull\" | \"push\" | \"both\";\n  alwaysFormat?: boolean;\n};\n\nexport default function createBiomeLoader(\n  options: BiomeLoaderOptions,\n): ILoader<string, string> {\n  return createBaseFormatterLoader(options, async (data, filePath) => {\n    return await formatDataWithBiome(data, filePath, options);\n  });\n}\n\nasync function findBiomeConfig(startPath: string): Promise<string | null> {\n  let currentDir = path.dirname(startPath);\n  const root = path.parse(currentDir).root;\n\n  while (currentDir !== root) {\n    for (const configName of [\"biome.json\", \"biome.jsonc\"]) {\n      const configPath = path.join(currentDir, configName);\n      try {\n        await fs.access(configPath);\n        return configPath;\n      } catch {\n        // Config file doesn't exist, continue searching\n      }\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) break;\n    currentDir = parentDir;\n  }\n\n  return null;\n}\n\nasync function formatDataWithBiome(\n  data: string,\n  filePath: string,\n  options: BiomeLoaderOptions,\n): Promise<string> {\n  let configPath: string | null = null;\n\n  try {\n    const biome = await Biome.create({\n      distribution: Distribution.NODE,\n    });\n\n    // Open a project (required in v3.0.0+)\n    const openResult = biome.openProject(\".\");\n    const projectKey = openResult.projectKey;\n\n    // Load config from biome.json/biome.jsonc if exists\n    configPath = await findBiomeConfig(filePath);\n    if (!configPath && !options.alwaysFormat) {\n      console.log();\n      console.log(\n        `‚ö†Ô∏è  Biome config not found for ${path.basename(filePath)} - skipping formatting`,\n      );\n      return data;\n    }\n\n    if (configPath) {\n      const configContent = await fs.readFile(configPath, \"utf-8\");\n      try {\n        // Parse JSONC (JSON with comments) properly using jsonc-parser\n        const config = parseJsonc(configContent);\n\n        // WORKAROUND: Biome JS API v3 has a bug where applying the full config\n        // causes formatter settings to be ignored. Apply only relevant sections.\n        // Specifically, exclude $schema, vcs, and files from the config.\n        const { $schema, vcs, files, ...relevantConfig } = config;\n\n        biome.applyConfiguration(projectKey, relevantConfig);\n      } catch (parseError) {\n        throw new Error(\n          `Invalid Biome configuration in ${configPath}: ${parseError instanceof Error ? parseError.message : \"JSON parse error\"}`,\n        );\n      }\n    }\n\n    const formatted = biome.formatContent(projectKey, data, {\n      filePath,\n    });\n\n    return formatted.content;\n  } catch (error) {\n    // Extract error message from Biome\n    const errorMessage =\n      error instanceof Error\n        ? error.message || (error as any).stackTrace?.toString().split(\"\\n\")[0]\n        : \"\";\n\n    if (errorMessage?.includes(\"does not exist in the workspace\")) {\n      // Biome says \"file does not exist in workspace\" for unsupported formats - skip\n    } else {\n      console.log(`‚ö†Ô∏è  Biome skipped ${path.basename(filePath)}`);\n      if (errorMessage) {\n        console.log(`   ${errorMessage}`);\n      }\n    }\n\n    return data; // Fallback to unformatted\n  }\n}\n","import createPrettierLoader, { PrettierLoaderOptions } from \"./prettier\";\nimport createBiomeLoader from \"./biome\";\nimport { ILoader } from \"../_types\";\nimport { Options } from \"prettier\";\n\nexport type FormatterType = \"prettier\" | \"biome\" | undefined;\nexport type ParserType = Options[\"parser\"];\n\nexport function createFormatterLoader(\n  formatterType: FormatterType,\n  parser: ParserType,\n  bucketPathPattern: string,\n): ILoader<string, string> {\n  // If explicitly set to undefined, auto-detect (prefer prettier for backward compatibility)\n  if (formatterType === undefined) {\n    return createPrettierLoader({ parser, bucketPathPattern });\n  }\n\n  if (formatterType === \"prettier\") {\n    return createPrettierLoader({ parser, bucketPathPattern });\n  }\n\n  if (formatterType === \"biome\") {\n    return createBiomeLoader({ bucketPathPattern });\n  }\n\n  throw new Error(`Unknown formatter: ${formatterType}`);\n}\n\n// Re-export for direct access if needed\nexport { createPrettierLoader, createBiomeLoader };\nexport type { PrettierLoaderOptions };\nexport type { BiomeLoaderOptions } from \"./biome\";\n","import _ from \"lodash\";\nimport gettextParser from \"gettext-parser\";\nimport { GetTextTranslations } from \"gettext-parser\";\nimport { ILoader } from \"../_types\";\nimport { composeLoaders, createLoader } from \"../_utils\";\n\nexport type PoTranslationEntry = GetTextTranslations[\"translations\"][\"\"];\nexport type PoTranslationValue = { singular: string; plural: string | null };\n\nexport type PoLoaderParams = {\n  multiline: boolean;\n};\n\nexport default function createPoLoader(\n  params: PoLoaderParams = { multiline: false },\n): ILoader<string, Record<string, PoTranslationValue>> {\n  return composeLoaders(createPoDataLoader(params), createPoContentLoader());\n}\n\nexport function createPoDataLoader(\n  params: PoLoaderParams,\n): ILoader<string, PoTranslationEntry> {\n  return createLoader({\n    async pull(locale, input) {\n      const parsedPo = gettextParser.po.parse(input);\n      const result: PoTranslationEntry = {};\n      const sections = input.split(\"\\n\\n\").filter(Boolean);\n      for (const section of sections) {\n        const sectionPo = gettextParser.po.parse(section);\n        // skip section with no translations (some sections might have only obsolete entries)\n        if (Object.keys(sectionPo.translations).length === 0) {\n          continue;\n        }\n\n        const contextKey = _.keys(sectionPo.translations)[0];\n        const entries = sectionPo.translations[contextKey];\n        Object.entries(entries).forEach(([msgid, entry]) => {\n          if (msgid && entry.msgid) {\n            const context = entry.msgctxt || \"\";\n            const fullEntry = parsedPo.translations[context]?.[msgid];\n            if (fullEntry) {\n              result[msgid] = fullEntry;\n            }\n          }\n        });\n      }\n      return result;\n    },\n\n    async push(locale, data, originalInput, originalLocale, pullInput) {\n      // Parse each section to maintain structure\n      const currentSections = pullInput?.split(\"\\n\\n\").filter(Boolean) || [];\n      const originalSections =\n        originalInput?.split(\"\\n\\n\").filter(Boolean) || [];\n      const result = originalSections\n        .map((section) => {\n          const sectionPo = gettextParser.po.parse(section);\n          // skip section with no translations (some sections might have only obsolete entries)\n          if (Object.keys(sectionPo.translations).length === 0) {\n            return null;\n          }\n\n          const contextKey = _.keys(sectionPo.translations)[0];\n          const entries = sectionPo.translations[contextKey];\n          const msgid = Object.keys(entries).find((key) => entries[key].msgid);\n          if (!msgid) {\n            // If the section is empty, try to find it in the current sections\n            const currentSection = currentSections.find((cs) => {\n              const csPo = gettextParser.po.parse(cs);\n              const csContextKey = _.keys(csPo.translations)[0];\n              const csEntries = csPo.translations[csContextKey];\n              const csMsgid = Object.keys(csEntries).find(\n                (key) => csEntries[key].msgid,\n              );\n              return csMsgid === msgid;\n            });\n\n            if (currentSection) {\n              return currentSection;\n            }\n            return section;\n          }\n          if (data[msgid]) {\n            const updatedPo = _.merge({}, sectionPo, {\n              translations: {\n                [contextKey]: {\n                  [msgid]: {\n                    msgstr: data[msgid].msgstr,\n                  },\n                },\n              },\n            });\n            const updatedSection = gettextParser.po\n              .compile(updatedPo, { foldLength: params.multiline ? 76 : false })\n              .toString()\n              .replace(\n                [`msgid \"\"`, `msgstr \"Content-Type: text/plain\\\\n\"`].join(\"\\n\"),\n                \"\",\n              )\n              .trim();\n            return preserveCommentOrder(updatedSection, section);\n          }\n          return section.trim();\n        })\n        .filter(Boolean)\n        .join(\"\\n\\n\");\n      return result;\n    },\n  });\n}\n\nexport function createPoContentLoader(): ILoader<\n  PoTranslationEntry,\n  Record<string, PoTranslationEntry>\n> {\n  return createLoader({\n    async pull(locale, input, initCtx, originalLocale) {\n      const result = _.chain(input)\n        .entries()\n        .filter(([, entry]) => !!entry.msgid)\n        .map(([, entry]) => {\n          const singularFallback =\n            locale === originalLocale ? entry.msgid : null;\n          const pluralFallback =\n            locale === originalLocale\n              ? entry.msgid_plural || entry.msgid\n              : null;\n          const hasPlural = entry.msgstr.length > 1;\n          return [\n            entry.msgid,\n            {\n              singular: entry.msgstr[0] || singularFallback,\n              plural: hasPlural\n                ? ((entry.msgstr[1] || pluralFallback) as string | null)\n                : null,\n            },\n          ];\n        })\n        .fromPairs()\n        .value();\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      const result = _.chain(originalInput)\n        .entries()\n        .map(([, entry]) => [\n          entry.msgid,\n          {\n            ...entry,\n            msgstr: [\n              data[entry.msgid]?.singular,\n              data[entry.msgid]?.plural || null,\n            ].filter(Boolean),\n          },\n        ])\n        .fromPairs()\n        .value();\n\n      return result;\n    },\n  });\n}\n\nfunction preserveCommentOrder(section: string, originalSection: string) {\n  // Split both sections into lines\n  const sectionLines = section.split(/\\r?\\n/);\n  const originalLines = originalSection.split(/\\r?\\n/);\n\n  // Helper: is a comment line\n  const isComment = (line: string) => line.trim().startsWith(\"#\");\n\n  // Extract comment lines and their indices\n  const sectionComments = sectionLines.filter(isComment);\n  const nonCommentLines = sectionLines.filter((line) => !isComment(line));\n\n  // If there are no comments in the section, return the section as is\n  if (sectionComments.length <= 1) {\n    return section;\n  }\n\n  // Extract the order of comment lines from the original section\n  const originalCommentOrder = originalLines.filter(isComment);\n\n  // Build a map from comment content (trimmed) to the actual comment line in the new section\n  const commentMap = new Map<string, string>();\n  for (const line of sectionComments) {\n    commentMap.set(line.trim(), line);\n  }\n\n  // Reorder comments to match the original order, using the new section's comment lines\n  const reorderedComments: string[] = [];\n  for (const orig of originalCommentOrder) {\n    const trimmed = orig.trim();\n    if (commentMap.has(trimmed)) {\n      reorderedComments.push(commentMap.get(trimmed)!);\n      commentMap.delete(trimmed);\n    }\n  }\n  // Add any new comments from the new section that weren't in the original, preserving their order\n  for (const line of sectionComments) {\n    if (!originalCommentOrder.some((orig) => orig.trim() === line.trim())) {\n      reorderedComments.push(line);\n    }\n  }\n\n  // Reconstruct the section: comments (in order) + non-comment lines (in order)\n  return [...reorderedComments, ...nonCommentLines]\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { JSDOM } from \"jsdom\";\n\n/**\n * Creates a comprehensive XLIFF loader supporting versions 1.2 and 2.0\n * with deterministic key generation and structure preservation\n */\nexport default function createXliffLoader(): ILoader<\n  string,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(locale, input, _ctx, originalLocale) {\n      const trimmedInput = (input ?? \"\").trim();\n\n      if (!trimmedInput) {\n        return createEmptyResult(originalLocale, locale);\n      }\n\n      try {\n        const dom = new JSDOM(trimmedInput, { contentType: \"text/xml\" });\n        const document = dom.window.document;\n\n        // Check for parsing errors\n        const parserError = document.querySelector(\"parsererror\");\n        if (parserError) {\n          throw new Error(`XML parsing failed: ${parserError.textContent}`);\n        }\n\n        const xliffElement = document.documentElement;\n        if (!xliffElement || xliffElement.tagName !== \"xliff\") {\n          throw new Error(\"Invalid XLIFF: missing root <xliff> element\");\n        }\n\n        const version = xliffElement.getAttribute(\"version\") || \"1.2\";\n        const isV2 = version === \"2.0\";\n\n        if (isV2) {\n          return pullV2(xliffElement, locale, originalLocale);\n        } else {\n          return pullV1(xliffElement, locale, originalLocale);\n        }\n      } catch (error: any) {\n        throw new Error(`Failed to parse XLIFF file: ${error.message}`);\n      }\n    },\n\n    async push(locale, translations, originalInput, originalLocale, pullInput) {\n      if (!originalInput) {\n        // Create new file from scratch\n        return pushNewFile(locale, translations, originalLocale);\n      }\n\n      try {\n        const dom = new JSDOM(originalInput, { contentType: \"text/xml\" });\n        const document = dom.window.document;\n        const xliffElement = document.documentElement;\n        const version = xliffElement.getAttribute(\"version\") || \"1.2\";\n        const isV2 = version === \"2.0\";\n\n        if (isV2) {\n          return pushV2(\n            dom,\n            xliffElement,\n            locale,\n            translations,\n            originalLocale,\n            originalInput,\n          );\n        } else {\n          return pushV1(\n            dom,\n            xliffElement,\n            locale,\n            translations,\n            originalLocale,\n            originalInput,\n          );\n        }\n      } catch (error: any) {\n        throw new Error(`Failed to update XLIFF file: ${error.message}`);\n      }\n    },\n  });\n}\n\n/* -------------------------------------------------------------------------- */\n/*                            Version 1.2 Support                            */\n/* -------------------------------------------------------------------------- */\n\nfunction pullV1(\n  xliffElement: Element,\n  locale: string,\n  originalLocale: string,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  const fileElement = xliffElement.querySelector(\"file\");\n\n  if (!fileElement) {\n    return result;\n  }\n\n  const sourceLanguage =\n    fileElement.getAttribute(\"source-language\") || originalLocale;\n  const isSourceLocale = sourceLanguage === locale;\n  const bodyElement = fileElement.querySelector(\"body\");\n\n  if (!bodyElement) {\n    return result;\n  }\n\n  const transUnits = bodyElement.querySelectorAll(\"trans-unit\");\n  const seenKeys = new Set<string>();\n\n  transUnits.forEach((unit) => {\n    let key = getTransUnitKey(unit as Element);\n    if (!key) return;\n\n    // Handle duplicates deterministically\n    if (seenKeys.has(key)) {\n      const id = (unit as Element).getAttribute(\"id\")?.trim();\n      if (id) {\n        key = `${key}#${id}`;\n      } else {\n        let counter = 1;\n        let newKey = `${key}__${counter}`;\n        while (seenKeys.has(newKey)) {\n          counter++;\n          newKey = `${key}__${counter}`;\n        }\n        key = newKey;\n      }\n    }\n    seenKeys.add(key);\n\n    const elementName = isSourceLocale ? \"source\" : \"target\";\n    const textElement = (unit as Element).querySelector(elementName);\n\n    if (textElement) {\n      result[key] = extractTextContent(textElement);\n    } else if (isSourceLocale) {\n      result[key] = key; // fallback for source\n    } else {\n      result[key] = \"\"; // empty for missing target\n    }\n  });\n\n  return result;\n}\n\nfunction pushV1(\n  dom: JSDOM,\n  xliffElement: Element,\n  locale: string,\n  translations: Record<string, string>,\n  originalLocale: string,\n  originalInput?: string,\n): string {\n  const document = dom.window.document;\n  const fileElement = xliffElement.querySelector(\"file\");\n\n  if (!fileElement) {\n    throw new Error(\"Invalid XLIFF 1.2: missing <file> element\");\n  }\n\n  // Update language attributes\n  const sourceLanguage =\n    fileElement.getAttribute(\"source-language\") || originalLocale;\n  const isSourceLocale = sourceLanguage === locale;\n\n  if (!isSourceLocale) {\n    fileElement.setAttribute(\"target-language\", locale);\n  }\n\n  let bodyElement = fileElement.querySelector(\"body\");\n  if (!bodyElement) {\n    bodyElement = document.createElement(\"body\");\n    fileElement.appendChild(bodyElement);\n  }\n\n  // Build current index\n  const existingUnits = new Map<string, Element>();\n  const seenKeys = new Set<string>();\n\n  bodyElement.querySelectorAll(\"trans-unit\").forEach((unit) => {\n    let key = getTransUnitKey(unit as Element);\n    if (!key) return;\n\n    if (seenKeys.has(key)) {\n      const id = (unit as Element).getAttribute(\"id\")?.trim();\n      if (id) {\n        key = `${key}#${id}`;\n      } else {\n        let counter = 1;\n        let newKey = `${key}__${counter}`;\n        while (seenKeys.has(newKey)) {\n          counter++;\n          newKey = `${key}__${counter}`;\n        }\n        key = newKey;\n      }\n    }\n    seenKeys.add(key);\n    existingUnits.set(key, unit as Element);\n  });\n\n  // Update/create translation units\n  Object.entries(translations).forEach(([key, value]) => {\n    let unit = existingUnits.get(key);\n\n    if (!unit) {\n      unit = document.createElement(\"trans-unit\");\n      unit.setAttribute(\"id\", key);\n      unit.setAttribute(\"resname\", key);\n      unit.setAttribute(\"restype\", \"string\");\n      unit.setAttribute(\"datatype\", \"plaintext\");\n\n      const sourceElement = document.createElement(\"source\");\n      setTextContent(sourceElement, isSourceLocale ? value : key);\n      unit.appendChild(sourceElement);\n\n      if (!isSourceLocale) {\n        const targetElement = document.createElement(\"target\");\n        targetElement.setAttribute(\"state\", value ? \"translated\" : \"new\");\n        setTextContent(targetElement, value);\n        unit.appendChild(targetElement);\n      }\n\n      bodyElement.appendChild(unit);\n      existingUnits.set(key, unit);\n    } else {\n      updateTransUnitV1(unit, key, value, isSourceLocale);\n    }\n  });\n\n  // Remove orphaned units\n  const translationKeys = new Set(Object.keys(translations));\n  existingUnits.forEach((unit, key) => {\n    if (!translationKeys.has(key)) {\n      unit.parentNode?.removeChild(unit);\n    }\n  });\n\n  return serializeWithDeclaration(\n    dom,\n    extractXmlDeclaration(originalInput || \"\"),\n  );\n}\n\nfunction updateTransUnitV1(\n  unit: Element,\n  key: string,\n  value: string,\n  isSourceLocale: boolean,\n): void {\n  const document = unit.ownerDocument!;\n\n  if (isSourceLocale) {\n    let sourceElement = unit.querySelector(\"source\");\n    if (!sourceElement) {\n      sourceElement = document.createElement(\"source\");\n      unit.appendChild(sourceElement);\n    }\n    setTextContent(sourceElement, value);\n  } else {\n    let targetElement = unit.querySelector(\"target\");\n    if (!targetElement) {\n      targetElement = document.createElement(\"target\");\n      unit.appendChild(targetElement);\n    }\n\n    setTextContent(targetElement, value);\n    targetElement.setAttribute(\"state\", value.trim() ? \"translated\" : \"new\");\n  }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                            Version 2.0 Support                            */\n/* -------------------------------------------------------------------------- */\n\nfunction pullV2(\n  xliffElement: Element,\n  locale: string,\n  originalLocale: string,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  // Add source language metadata\n  const srcLang = xliffElement.getAttribute(\"srcLang\") || originalLocale;\n  result.sourceLanguage = srcLang;\n\n  const fileElements = xliffElement.querySelectorAll(\"file\");\n\n  fileElements.forEach((fileElement) => {\n    const fileId = fileElement.getAttribute(\"id\");\n    if (!fileId) return;\n\n    traverseUnitsV2(fileElement, fileId, \"\", result);\n  });\n\n  return result;\n}\n\nfunction traverseUnitsV2(\n  container: Element,\n  fileId: string,\n  currentPath: string,\n  result: Record<string, string>,\n): void {\n  Array.from(container.children).forEach((child) => {\n    const tagName = child.tagName;\n\n    if (tagName === \"unit\") {\n      const unitId = child.getAttribute(\"id\")?.trim();\n      if (!unitId) return;\n\n      const key = `resources/${fileId}/${currentPath}${unitId}/source`;\n      const segment = child.querySelector(\"segment\");\n      const source = segment?.querySelector(\"source\");\n\n      if (source) {\n        result[key] = extractTextContent(source);\n      } else {\n        result[key] = unitId; // fallback\n      }\n    } else if (tagName === \"group\") {\n      const groupId = child.getAttribute(\"id\")?.trim();\n      const newPath = groupId\n        ? `${currentPath}${groupId}/groupUnits/`\n        : currentPath;\n      traverseUnitsV2(child, fileId, newPath, result);\n    }\n  });\n}\n\nfunction pushV2(\n  dom: JSDOM,\n  xliffElement: Element,\n  locale: string,\n  translations: Record<string, string>,\n  originalLocale: string,\n  originalInput?: string,\n): string {\n  const document = dom.window.document;\n\n  // Handle sourceLanguage metadata\n  if (translations.sourceLanguage) {\n    xliffElement.setAttribute(\"srcLang\", translations.sourceLanguage);\n    delete translations.sourceLanguage; // Don't process as regular translation\n  }\n\n  // Build index of existing units\n  const existingUnits = new Map<string, Element>();\n  const fileElements = xliffElement.querySelectorAll(\"file\");\n\n  fileElements.forEach((fileElement) => {\n    const fileId = fileElement.getAttribute(\"id\");\n    if (!fileId) return;\n\n    indexUnitsV2(fileElement, fileId, \"\", existingUnits);\n  });\n\n  // Update existing units\n  Object.entries(translations).forEach(([key, value]) => {\n    const unit = existingUnits.get(key);\n    if (unit) {\n      updateUnitV2(unit, value);\n    } else {\n      // For new units, we'd need to create the structure\n      // This is complex in V2 due to the hierarchical nature\n      console.warn(`Cannot create new unit for key: ${key} in XLIFF 2.0`);\n    }\n  });\n\n  return serializeWithDeclaration(\n    dom,\n    extractXmlDeclaration(originalInput || \"\"),\n  );\n}\n\nfunction indexUnitsV2(\n  container: Element,\n  fileId: string,\n  currentPath: string,\n  index: Map<string, Element>,\n): void {\n  Array.from(container.children).forEach((child) => {\n    const tagName = child.tagName;\n\n    if (tagName === \"unit\") {\n      const unitId = child.getAttribute(\"id\")?.trim();\n      if (!unitId) return;\n\n      const key = `resources/${fileId}/${currentPath}${unitId}/source`;\n      index.set(key, child);\n    } else if (tagName === \"group\") {\n      const groupId = child.getAttribute(\"id\")?.trim();\n      const newPath = groupId\n        ? `${currentPath}${groupId}/groupUnits/`\n        : currentPath;\n      indexUnitsV2(child, fileId, newPath, index);\n    }\n  });\n}\n\nfunction updateUnitV2(unit: Element, value: string): void {\n  const document = unit.ownerDocument!;\n\n  let segment = unit.querySelector(\"segment\");\n  if (!segment) {\n    segment = document.createElement(\"segment\");\n    unit.appendChild(segment);\n  }\n\n  let source = segment.querySelector(\"source\");\n  if (!source) {\n    source = document.createElement(\"source\");\n    segment.appendChild(source);\n  }\n\n  setTextContent(source, value);\n}\n\n/* -------------------------------------------------------------------------- */\n/*                              Utilities                                     */\n/* -------------------------------------------------------------------------- */\n\nfunction getTransUnitKey(transUnit: Element): string {\n  const resname = transUnit.getAttribute(\"resname\")?.trim();\n  if (resname) return resname;\n\n  const id = transUnit.getAttribute(\"id\")?.trim();\n  if (id) return id;\n\n  const sourceElement = transUnit.querySelector(\"source\");\n  if (sourceElement) {\n    const sourceText = extractTextContent(sourceElement).trim();\n    if (sourceText) return sourceText;\n  }\n\n  return \"\";\n}\n\nfunction extractTextContent(element: Element): string {\n  // Handle CDATA sections\n  const cdataNode = Array.from(element.childNodes).find(\n    (node) => node.nodeType === element.CDATA_SECTION_NODE,\n  );\n\n  if (cdataNode) {\n    return cdataNode.nodeValue || \"\";\n  }\n\n  return element.textContent || \"\";\n}\n\nfunction setTextContent(element: Element, content: string): void {\n  const document = element.ownerDocument!;\n\n  // Clear existing content\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n\n  // Use CDATA if content contains XML-sensitive characters\n  if (/[<>&\"']/.test(content)) {\n    const cdataSection = document.createCDATASection(content);\n    element.appendChild(cdataSection);\n  } else {\n    element.textContent = content;\n  }\n}\n\nfunction extractXmlDeclaration(xmlContent: string): string {\n  const match = xmlContent.match(/^<\\?xml[^>]*\\?>/);\n  return match ? match[0] : \"\";\n}\n\nfunction serializeWithDeclaration(dom: JSDOM, declaration: string): string {\n  let serialized = dom.serialize();\n\n  // Add proper indentation for readability\n  serialized = formatXml(serialized);\n\n  if (declaration) {\n    serialized = `${declaration}\\n${serialized}`;\n  }\n\n  return serialized;\n}\n\nfunction formatXml(xml: string): string {\n  // Parse and reformat XML with proper indentation using JSDOM\n  const dom = new JSDOM(xml, { contentType: \"text/xml\" });\n  const doc = dom.window.document;\n\n  function formatElement(element: Element, depth: number = 0): string {\n    const indent = \"  \".repeat(depth);\n    const tagName = element.tagName;\n    const attributes = Array.from(element.attributes)\n      .map((attr) => `${attr.name}=\"${attr.value}\"`)\n      .join(\" \");\n\n    const openTag = attributes ? `<${tagName} ${attributes}>` : `<${tagName}>`;\n\n    // Check for CDATA sections first\n    const cdataNode = Array.from(element.childNodes).find(\n      (node) => node.nodeType === element.CDATA_SECTION_NODE,\n    );\n\n    if (cdataNode) {\n      return `${indent}${openTag}<![CDATA[${cdataNode.nodeValue}]]></${tagName}>`;\n    }\n\n    // Check if element has only text content\n    const textContent = element.textContent?.trim() || \"\";\n    const hasOnlyText =\n      element.childNodes.length === 1 && element.childNodes[0].nodeType === 3;\n\n    if (hasOnlyText && textContent) {\n      return `${indent}${openTag}${textContent}</${tagName}>`;\n    }\n\n    // Element has child elements\n    const children = Array.from(element.children);\n    if (children.length === 0) {\n      return `${indent}${openTag}</${tagName}>`;\n    }\n\n    let result = `${indent}${openTag}\\n`;\n    for (const child of children) {\n      result += formatElement(child, depth + 1) + \"\\n\";\n    }\n    result += `${indent}</${tagName}>`;\n\n    return result;\n  }\n\n  return formatElement(doc.documentElement);\n}\n\nfunction createEmptyResult(\n  originalLocale: string,\n  locale: string,\n): Record<string, string> {\n  return {};\n}\n\nfunction pushNewFile(\n  locale: string,\n  translations: Record<string, string>,\n  originalLocale: string,\n): string {\n  const skeleton = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xliff xmlns=\"urn:oasis:names:tc:xliff:document:1.2\" version=\"1.2\">\n  <file original=\"\" source-language=\"${originalLocale}\" target-language=\"${locale}\" datatype=\"plaintext\">\n    <header></header>\n    <body></body>\n  </file>\n</xliff>`;\n\n  const dom = new JSDOM(skeleton, { contentType: \"text/xml\" });\n  const document = dom.window.document;\n  const bodyElement = document.querySelector(\"body\")!;\n\n  Object.entries(translations).forEach(([key, value]) => {\n    const unit = document.createElement(\"trans-unit\");\n    unit.setAttribute(\"id\", key);\n    unit.setAttribute(\"resname\", key);\n    unit.setAttribute(\"restype\", \"string\");\n    unit.setAttribute(\"datatype\", \"plaintext\");\n\n    const sourceElement = document.createElement(\"source\");\n    setTextContent(sourceElement, key);\n    unit.appendChild(sourceElement);\n\n    const targetElement = document.createElement(\"target\");\n    targetElement.setAttribute(\"state\", value ? \"translated\" : \"new\");\n    setTextContent(targetElement, value);\n    unit.appendChild(targetElement);\n\n    bodyElement.appendChild(unit);\n  });\n\n  return serializeWithDeclaration(\n    dom,\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>',\n  );\n}\n","import { parseStringPromise, Builder } from \"xml2js\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nfunction normalizeXMLString(xmlString: string): string {\n  return xmlString\n    .replace(/\\s+/g, \" \")\n    .replace(/>\\s+</g, \"><\")\n    .replace(\"\\n\", \"\")\n    .trim();\n}\n\nexport default function createXmlLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      let result: Record<string, any> = {};\n\n      try {\n        const parsed = await parseStringPromise(input, {\n          explicitArray: false,\n          mergeAttrs: false,\n          normalize: true,\n          preserveChildrenOrder: true,\n          normalizeTags: true,\n          includeWhiteChars: true,\n          trim: true,\n        });\n        result = parsed;\n      } catch (error) {\n        console.error(\"Failed to parse XML:\", error);\n        result = {};\n      }\n\n      return result;\n    },\n\n    async push(locale, data) {\n      try {\n        const builder = new Builder({ headless: true });\n        const xmlOutput = builder.buildObject(data);\n        const expectedOutput = normalizeXMLString(xmlOutput);\n        return expectedOutput;\n      } catch (error) {\n        console.error(\"Failed to build XML:\", error);\n        return \"\";\n      }\n    },\n  });\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport srtParser from \"srt-parser-2\";\n\nexport default function createSrtLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  const parser = new srtParser();\n  return createLoader({\n    async pull(locale, input) {\n      const parsed = parser.fromSrt(input) || [];\n      const result: Record<string, string> = {};\n\n      parsed.forEach((entry) => {\n        const key = `${entry.id}#${entry.startTime}-${entry.endTime}`;\n        result[key] = entry.text;\n      });\n\n      return result;\n    },\n\n    async push(locale, payload) {\n      const output = Object.entries(payload).map(([key, text]) => {\n        const [id, timeRange] = key.split(\"#\");\n        const [startTime, endTime] = timeRange.split(\"-\");\n\n        return {\n          id: id,\n          startTime: startTime,\n          startSeconds: 0,\n          endTime: endTime,\n          endSeconds: 0,\n          text: text,\n        };\n      });\n\n      const srtContent = parser.toSrt(output).trim().replace(/\\r?\\n/g, \"\\n\");\n      return srtContent;\n    },\n  });\n}\n","import fs from \"fs\";\nimport JSON5 from \"json5\";\nimport { composeLoaders } from \"../_utils\";\nimport { datoConfigSchema } from \"./_base\";\nimport createDatoFilterLoader from \"./filter\";\nimport createDatoApiLoader from \"./api\";\nimport createDatoExtractLoader from \"./extract\";\n\nexport default function createDatoLoader(configFilePath: string) {\n  try {\n    const configContent = fs.readFileSync(configFilePath, \"utf-8\");\n    const datoConfig = datoConfigSchema.parse(JSON5.parse(configContent));\n\n    return composeLoaders(\n      createDatoApiLoader(datoConfig, (updatedConfig) =>\n        fs.writeFileSync(\n          configFilePath,\n          JSON5.stringify(updatedConfig, null, 2),\n        ),\n      ),\n      createDatoFilterLoader(),\n      createDatoExtractLoader(),\n    );\n  } catch (error: any) {\n    throw new Error(\n      [`Failed to parse DatoCMS config file.`, `Error: ${error.message}`].join(\n        \"\\n\\n\",\n      ),\n    );\n  }\n}\n","import Z from \"zod\";\n\n// DatoCMS config\nexport const datoConfigSchema = Z.object({\n  project: Z.string(),\n  models: Z.record(\n    Z.string(),\n    Z.object({\n      records: Z.array(Z.string()).optional(),\n      fields: Z.array(Z.string()).optional(),\n    }),\n  ),\n});\n\nexport type DatoConfig = Z.infer<typeof datoConfigSchema>;\n\n// DatoCMS settings\nexport const datoSettingsSchema = Z.object({\n  auth: Z.object({\n    apiKey: Z.string(),\n  }),\n});\n\nexport type DatoSettings = Z.infer<typeof datoSettingsSchema>;\n\nexport const DEFAULT_LOCALE = \"en\";\n\n//\n\nexport type DatoRecordPayload = {\n  [field: string]: {\n    [locale: string]: DatoValue;\n  };\n};\n\nexport type DatoValue = DatoSimpleValue | DatoComplexValue;\nexport type DatoSimpleValue = DatoPrimitive | DastDocument;\nexport type DatoComplexValue = DatoBlock | DatoBlock[];\n\nexport type DatoPrimitive = null | string | boolean | number;\n\nexport type DastDocument = {\n  schema: \"dast\";\n  document: DastDocumentNode;\n};\n\nexport type DastDocumentNode = {\n  type: \"root\" | \"span\" | \"paragraph\";\n  value?: DatoPrimitive;\n  children?: DastDocumentNode[];\n};\n\nexport type DatoBlock = {\n  id?: string;\n  type: \"item\";\n  attributes: Record<string, DatoSimpleValue>;\n  relationships: any;\n};\n","import _ from \"lodash\";\nimport fs from \"fs\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { DatoApiLoaderOutput } from \"./api\";\n\nexport type DatoFilterLoaderOutput = {\n  [modelId: string]: {\n    [recordId: string]: {\n      [fieldName: string]: any;\n    };\n  };\n};\n\nexport default function createDatoFilterLoader(): ILoader<\n  DatoApiLoaderOutput,\n  DatoFilterLoaderOutput\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const result: DatoFilterLoaderOutput = {};\n\n      for (const [modelId, modelInfo] of _.entries(input)) {\n        result[modelId] = {};\n        for (const record of modelInfo.records) {\n          result[modelId][record.id] = _.chain(modelInfo.fields)\n            .mapKeys((field) => field.api_key)\n            .mapValues((field) => _.get(record, [field.api_key, locale]))\n            .value();\n        }\n      }\n\n      return result;\n    },\n    async push(locale, data, originalInput, originalLocale) {\n      const result = _.cloneDeep(originalInput || {});\n\n      for (const [modelId, modelInfo] of _.entries(result)) {\n        for (const record of modelInfo.records) {\n          for (const [fieldId, fieldValue] of _.entries(record)) {\n            const fieldInfo = modelInfo.fields.find(\n              (field) => field.api_key === fieldId,\n            );\n            if (fieldInfo) {\n              const sourceFieldValue = _.get(fieldValue, [originalLocale]);\n              const targetFieldValue = _.get(data, [\n                modelId,\n                record.id,\n                fieldId,\n              ]);\n              if (targetFieldValue) {\n                _.set(record, [fieldId, locale], targetFieldValue);\n              } else {\n                _.set(record, [fieldId, locale], sourceFieldValue);\n              }\n\n              _.chain(fieldValue)\n                .keys()\n                .reject((loc) => loc === locale || loc === originalLocale)\n                .filter((loc) => _.isEmpty(_.get(fieldValue, [loc])))\n                .forEach((loc) =>\n                  _.set(record, [fieldId, loc], sourceFieldValue),\n                )\n                .value();\n            }\n          }\n        }\n      }\n\n      return result;\n    },\n  });\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport createDatoClient, { DatoClient } from \"./_utils\";\nimport { SimpleSchemaTypes } from \"@datocms/cma-client-node\";\nimport { DatoConfig } from \"./_base\";\nimport inquirer from \"inquirer\";\n\nexport type DatoApiLoaderOutput = {\n  [modelId: string]: {\n    fields: SimpleSchemaTypes.Field[];\n    records: SimpleSchemaTypes.Item[];\n  };\n};\n\nexport type DatoApiLoaderCtx = {\n  models: {\n    [modelId: string]: {\n      fields: SimpleSchemaTypes.Field[];\n      records: SimpleSchemaTypes.Item[];\n    };\n  };\n};\n\nexport default function createDatoApiLoader(\n  config: DatoConfig,\n  onConfigUpdate: (config: DatoConfig) => void,\n): ILoader<void, DatoApiLoaderOutput, DatoApiLoaderCtx> {\n  const dato = createDatoClient({\n    apiKey: process.env.DATO_API_TOKEN || \"\",\n    projectId: config.project,\n  });\n  return createLoader({\n    init: async () => {\n      const result: DatoApiLoaderCtx = {\n        models: {},\n      };\n      const updatedConfig = _.cloneDeep(config);\n      console.log(`Initializing DatoCMS loader...`);\n\n      const project = await dato.findProject();\n      const modelChoices = await getModelChoices(dato, config);\n      const selectedModels = await promptModelSelection(modelChoices);\n\n      for (const modelId of selectedModels) {\n        if (!updatedConfig.models[modelId]) {\n          updatedConfig.models[modelId] = {\n            fields: [],\n            records: [],\n          };\n        }\n      }\n\n      for (const modelId of Object.keys(updatedConfig.models)) {\n        if (!selectedModels.includes(modelId)) {\n          delete updatedConfig.models[modelId];\n        }\n      }\n\n      for (const modelId of _.keys(updatedConfig.models)) {\n        const { modelName, fields } = await getModelFields(dato, modelId);\n\n        if (fields.length > 0) {\n          result.models[modelId] = { fields: [], records: [] };\n\n          const fieldInfos = await getFieldDetails(dato, fields);\n          const fieldChoices = createFieldChoices(fieldInfos);\n          const selectedFields = await promptFieldSelection(\n            modelName,\n            fieldChoices,\n          );\n\n          for (const fieldInfo of fieldInfos) {\n            const isLocalized = await updateFieldLocalization(\n              dato,\n              fieldInfo,\n              selectedFields.includes(fieldInfo.id),\n            );\n            if (isLocalized) {\n              result.models[modelId].fields.push(fieldInfo);\n              updatedConfig.models[modelId].fields = _.uniq([\n                ...(updatedConfig.models[modelId].fields || []),\n                fieldInfo.api_key,\n              ]);\n            }\n          }\n\n          const records = await dato.findRecordsForModel(modelId);\n          const recordChoices = createRecordChoices(\n            records,\n            config.models[modelId]?.records || [],\n            project,\n          );\n          const selectedRecords = await promptRecordSelection(\n            modelName,\n            recordChoices,\n          );\n\n          result.models[modelId].records = records.filter((record) =>\n            selectedRecords.includes(record.id),\n          );\n          updatedConfig.models[modelId].records = selectedRecords;\n        }\n      }\n      console.log(`DatoCMS loader initialized.`);\n      onConfigUpdate(updatedConfig);\n      return result;\n    },\n    async pull(locale, input, initCtx) {\n      const result: DatoApiLoaderOutput = {};\n\n      for (const modelId of _.keys(initCtx?.models || {})) {\n        let records = initCtx?.models[modelId].records || [];\n        const recordIds = records.map((record) => record.id);\n        records = await dato.findRecords(recordIds);\n        console.log(`Fetched ${records.length} records for model ${modelId}`);\n\n        if (records.length > 0) {\n          result[modelId] = {\n            fields: initCtx?.models?.[modelId]?.fields || [],\n            records: records,\n          };\n        }\n      }\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      for (const modelId of _.keys(data)) {\n        for (let i = 0; i < data[modelId].records.length; i++) {\n          const record = data[modelId].records[i];\n          console.log(\n            `Updating record ${i + 1}/${\n              data[modelId].records.length\n            } for model ${modelId}...`,\n          );\n          await dato.updateRecord(record.id, record);\n        }\n      }\n    },\n  });\n}\n\nexport async function getModelFields(dato: any, modelId: string) {\n  const modelInfo = await dato.findModel(modelId);\n  return {\n    modelName: modelInfo.name,\n    fields: _.filter(modelInfo.fields, (field) => field.type === \"field\"),\n  };\n}\n\nexport async function getFieldDetails(\n  dato: DatoClient,\n  fields: SimpleSchemaTypes.Field[],\n) {\n  return Promise.all(fields.map((field) => dato.findField(field.id)));\n}\n\nexport function createFieldChoices(fieldInfos: SimpleSchemaTypes.Field[]) {\n  return fieldInfos.map((field) => ({\n    name: field.label,\n    value: field.id,\n    checked: field.localized,\n  }));\n}\n\nexport async function promptFieldSelection(modelName: string, choices: any[]) {\n  const { selectedFields } = await inquirer.prompt([\n    {\n      type: \"checkbox\",\n      name: \"selectedFields\",\n      message: `Select fields to enable localization for model \"${modelName}\":`,\n      choices,\n      pageSize: process.stdout.rows - 4, // Subtract some rows for prompt text and margins\n    },\n  ]);\n  return selectedFields;\n}\n\nexport async function updateFieldLocalization(\n  dato: any,\n  fieldInfo: SimpleSchemaTypes.Field,\n  shouldBeLocalized: boolean,\n) {\n  if (shouldBeLocalized !== fieldInfo.localized) {\n    console.log(\n      `${shouldBeLocalized ? \"Enabling\" : \"Disabling\"} localization for ${\n        fieldInfo.label\n      }...`,\n    );\n    await dato.updateField(fieldInfo.id, { localized: shouldBeLocalized });\n  }\n  return shouldBeLocalized;\n}\n\nexport function createRecordChoices(\n  records: SimpleSchemaTypes.Item[],\n  selectedIds: string[] = [],\n  project: SimpleSchemaTypes.Site,\n) {\n  return records.map((record) => ({\n    name: `${record.id} - https://${project.internal_domain}/editor/item_types/${record.item_type.id}/items/${record.id}`,\n    value: record.id,\n    checked: selectedIds?.includes(record.id),\n  }));\n}\n\nexport async function promptRecordSelection(modelName: string, choices: any[]) {\n  const { selectedRecords } = await inquirer.prompt([\n    {\n      type: \"checkbox\",\n      name: \"selectedRecords\",\n      message: `Select records to include for model \"${modelName}\":`,\n      choices,\n      pageSize: process.stdout.rows - 4, // Subtract some rows for prompt text and margins\n    },\n  ]);\n  return selectedRecords;\n}\n\nexport async function getModelChoices(dato: DatoClient, config: DatoConfig) {\n  const models = await dato.findModels();\n  return models.map((model) => ({\n    name: `${model.name} (${model.api_key})`,\n    value: model.id,\n    checked: config.models[model.id] !== undefined,\n    pageSize: process.stdout.rows - 4, // Subtract some rows for prompt text and margins\n  }));\n}\n\nexport async function promptModelSelection(choices: any[]) {\n  const { selectedModels } = await inquirer.prompt([\n    {\n      type: \"checkbox\",\n      name: \"selectedModels\",\n      message: \"Select models to include:\",\n      choices,\n      pageSize: process.stdout.rows - 4, // Subtract some rows for prompt text and margins\n    },\n  ]);\n  return selectedModels;\n}\n","import _ from \"lodash\";\nimport { buildClient, SimpleSchemaTypes } from \"@datocms/cma-client-node\";\nimport { DastDocument, DatoBlock, DatoSimpleValue, DatoValue } from \"./_base\";\nimport { DastDocumentNode } from \"./_base\";\n\ntype DatoClientParams = {\n  apiKey: string;\n  projectId: string;\n};\n\nexport type DatoClient = ReturnType<typeof createDatoClient>;\n\nexport default function createDatoClient(params: DatoClientParams) {\n  if (!params.apiKey) {\n    throw new Error(\n      \"Missing required environment variable: DATO_API_TOKEN. Please set this variable and try again.\",\n    );\n  }\n  const dato = buildClient({\n    apiToken: params.apiKey,\n    extraHeaders: {\n      \"X-Exclude-Invalid\": \"true\",\n    },\n  });\n\n  return {\n    findProject: async (): Promise<SimpleSchemaTypes.Site> => {\n      const project = await dato.site.find();\n      return project;\n    },\n    updateField: async (\n      fieldId: string,\n      payload: SimpleSchemaTypes.FieldUpdateSchema,\n    ): Promise<void> => {\n      try {\n        await dato.fields.update(fieldId, payload);\n      } catch (_error: any) {\n        throw new Error(\n          [\n            `Failed to update field in DatoCMS.`,\n            `Field ID: ${fieldId}`,\n            `Payload: ${JSON.stringify(payload, null, 2)}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    findField: async (fieldId: string): Promise<SimpleSchemaTypes.Field> => {\n      try {\n        const field = await dato.fields.find(fieldId);\n        if (!field) {\n          throw new Error(`Field ${fieldId} not found`);\n        }\n        return field;\n      } catch (_error: any) {\n        throw new Error(\n          [\n            `Failed to find field in DatoCMS.`,\n            `Field ID: ${fieldId}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    findModels: async (): Promise<SimpleSchemaTypes.ItemType[]> => {\n      try {\n        const models = await dato.itemTypes.list();\n        const modelsWithoutBlocks = models.filter(\n          (model) => !model.modular_block,\n        );\n        return modelsWithoutBlocks;\n      } catch (_error: any) {\n        throw new Error(\n          [\n            `Failed to find models in DatoCMS.`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    findModel: async (modelId: string): Promise<SimpleSchemaTypes.ItemType> => {\n      try {\n        const model = await dato.itemTypes.find(modelId);\n        if (!model) {\n          throw new Error(`Model ${modelId} not found`);\n        }\n        return model;\n      } catch (_error: any) {\n        throw new Error(\n          [\n            `Failed to find model in DatoCMS.`,\n            `Model ID: ${modelId}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    findRecords: async (\n      records: string[],\n      limit: number = 100,\n    ): Promise<SimpleSchemaTypes.Item[]> => {\n      return dato.items\n        .list({\n          nested: true,\n          version: \"current\",\n          limit,\n          filter: {\n            projectId: params.projectId,\n            only_valid: \"true\",\n            ids: !records.length ? undefined : records.join(\",\"),\n          },\n        })\n        .catch((error: any) =>\n          Promise.reject(error?.response?.body?.data?.[0] || error),\n        );\n    },\n    findRecordsForModel: async (\n      modelId: string,\n      records?: string[],\n    ): Promise<SimpleSchemaTypes.Item[]> => {\n      try {\n        const result = await dato.items\n          .list({\n            nested: true,\n            version: \"current\",\n            filter: {\n              type: modelId,\n              only_valid: \"true\",\n              ids: !records?.length ? undefined : records.join(\",\"),\n            },\n          })\n          .catch((error: any) =>\n            Promise.reject(error?.response?.body?.data?.[0] || error),\n          );\n        return result;\n      } catch (_error: any) {\n        throw new Error(\n          [\n            `Failed to find records for model in DatoCMS.`,\n            `Model ID: ${modelId}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    updateRecord: async (id: string, payload: any): Promise<void> => {\n      try {\n        await dato.items\n          .update(id, payload)\n          .catch((error: any) =>\n            Promise.reject(error?.response?.body?.data?.[0] || error),\n          );\n      } catch (_error: any) {\n        if (_error?.attributes?.details?.message) {\n          throw new Error(\n            [\n              `${_error.attributes.details.message}`,\n              `Payload: ${JSON.stringify(payload, null, 2)}`,\n              `Error: ${JSON.stringify(_error, null, 2)}`,\n            ].join(\"\\n\\n\"),\n          );\n        }\n\n        throw new Error(\n          [\n            `Failed to update record in DatoCMS.`,\n            `Record ID: ${id}`,\n            `Payload: ${JSON.stringify(payload, null, 2)}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n    enableFieldLocalization: async (args: {\n      modelId: string;\n      fieldId: string;\n    }): Promise<void> => {\n      try {\n        await dato.fields\n          .update(`${args.modelId}::${args.fieldId}`, { localized: true })\n          .catch((error: any) =>\n            Promise.reject(error?.response?.body?.data?.[0] || error),\n          );\n      } catch (_error: any) {\n        if (_error?.attributes?.code === \"NOT_FOUND\") {\n          throw new Error(\n            [\n              `Field \"${args.fieldId}\" not found in model \"${args.modelId}\".`,\n              `Error: ${JSON.stringify(_error, null, 2)}`,\n            ].join(\"\\n\\n\"),\n          );\n        }\n\n        if (_error?.attributes?.details?.message) {\n          throw new Error(\n            [\n              `${_error.attributes.details.message}`,\n              `Error: ${JSON.stringify(_error, null, 2)}`,\n            ].join(\"\\n\\n\"),\n          );\n        }\n\n        throw new Error(\n          [\n            `Failed to enable field localization in DatoCMS.`,\n            `Field ID: ${args.fieldId}`,\n            `Model ID: ${args.modelId}`,\n            `Error: ${JSON.stringify(_error, null, 2)}`,\n          ].join(\"\\n\\n\"),\n        );\n      }\n    },\n  };\n}\n\ntype TraverseDatoCallbackMap = {\n  onValue?: (\n    path: string[],\n    value: DatoSimpleValue,\n    setValue: (value: DatoSimpleValue) => void,\n  ) => void;\n  onBlock?: (path: string[], value: DatoBlock) => void;\n};\n\nexport function traverseDatoPayload(\n  payload: Record<string, DatoValue>,\n  callbackMap: TraverseDatoCallbackMap,\n  path: string[] = [],\n) {\n  for (const fieldName of Object.keys(payload)) {\n    const fieldValue = payload[fieldName];\n    traverseDatoValue(payload, fieldValue, callbackMap, [...path, fieldName]);\n  }\n}\n\nexport function traverseDatoValue(\n  parent: Record<string, DatoValue>,\n  value: DatoValue,\n  callbackMap: TraverseDatoCallbackMap,\n  path: string[] = [],\n) {\n  if (_.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverseDatoValue(parent, value[i], callbackMap, [...path, i.toString()]);\n    }\n  } else if (_.isObject(value)) {\n    if (\"schema\" in value && value.schema === \"dast\") {\n      traverseDastDocument(value, callbackMap, [...path]);\n    } else if (\"type\" in value && value.type === \"item\") {\n      traverseDatoBlock(value, callbackMap, [...path]);\n    } else {\n      throw new Error(\n        [\n          \"Unsupported dato object value type:\",\n          JSON.stringify(value, null, 2),\n        ].join(\"\\n\\n\"),\n      );\n    }\n  } else {\n    callbackMap.onValue?.(path, value, (value) => {\n      _.set(parent, path[path.length - 1], value);\n    });\n  }\n}\n\nexport function traverseDastDocument(\n  dast: DastDocument,\n  callbackMap: TraverseDatoCallbackMap,\n  path: string[] = [],\n) {\n  traverseDastNode(dast.document, callbackMap, [...path, \"document\"]);\n}\n\nexport function traverseDatoBlock(\n  block: DatoBlock,\n  callbackMap: TraverseDatoCallbackMap,\n  path: string[] = [],\n) {\n  callbackMap.onBlock?.(path, block);\n  traverseDatoPayload(block.attributes, callbackMap, [...path, \"attributes\"]);\n}\n\nexport function traverseDastNode(\n  node: DastDocumentNode,\n  callbackMap: TraverseDatoCallbackMap,\n  path: string[] = [],\n) {\n  if (node.value) {\n    callbackMap.onValue?.(path, node.value, (value) => {\n      _.set(node, \"value\", value);\n    });\n  }\n  if (node.children?.length) {\n    for (let i = 0; i < node.children.length; i++) {\n      traverseDastNode(node.children[i], callbackMap, [...path, i.toString()]);\n    }\n  }\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { DatoFilterLoaderOutput } from \"./filter\";\nimport fs from \"fs\";\nimport Z from \"zod\";\n\nexport type DatoExtractLoaderOutput = {\n  [modelId: string]: {\n    [recordId: string]: {\n      [fieldName: string]: string | Record<string, object>;\n    };\n  };\n};\n\nexport default function createDatoExtractLoader(): ILoader<\n  DatoFilterLoaderOutput,\n  DatoExtractLoaderOutput\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const result: DatoExtractLoaderOutput = {};\n\n      for (const [modelId, modelInfo] of _.entries(input)) {\n        for (const [recordId, record] of _.entries(modelInfo)) {\n          for (const [fieldName, fieldValue] of _.entries(record)) {\n            const parsedValue = createParsedDatoValue(fieldValue);\n            if (parsedValue) {\n              _.set(result, [modelId, `_${recordId}`, fieldName], parsedValue);\n            }\n          }\n        }\n      }\n\n      return result;\n    },\n    async push(locale, data, originalInput) {\n      const result = _.cloneDeep(originalInput || {});\n\n      for (const [modelId, modelInfo] of _.entries(data)) {\n        for (const [virtualRecordId, record] of _.entries(modelInfo)) {\n          for (const [fieldName, fieldValue] of _.entries(record)) {\n            const [, recordId] = virtualRecordId.split(\"_\");\n            const originalFieldValue = _.get(originalInput, [\n              modelId,\n              recordId,\n              fieldName,\n            ]);\n            const rawValue = createRawDatoValue(\n              fieldValue,\n              originalFieldValue,\n              true,\n            );\n            _.set(\n              result,\n              [modelId, recordId, fieldName],\n              rawValue || originalFieldValue,\n            );\n          }\n        }\n      }\n\n      return result;\n    },\n  });\n}\n\nexport type DatoValueRaw = any;\nexport type DatoValueParsed = any;\n\nexport function detectDatoFieldType(rawDatoValue: DatoValueRaw): string | null {\n  if (\n    _.has(rawDatoValue, \"document\") &&\n    _.get(rawDatoValue, \"schema\") === \"dast\"\n  ) {\n    return \"structured_text\";\n  } else if (\n    _.has(rawDatoValue, \"no_index\") ||\n    _.has(rawDatoValue, \"twitter_card\")\n  ) {\n    return \"seo\";\n  } else if (_.get(rawDatoValue, \"type\") === \"item\") {\n    return \"single_block\";\n  } else if (\n    _.isArray(rawDatoValue) &&\n    _.every(rawDatoValue, (item) => _.get(item, \"type\") === \"item\")\n  ) {\n    return \"rich_text\";\n  } else if (_isFile(rawDatoValue)) {\n    return \"file\";\n  } else if (\n    _.isArray(rawDatoValue) &&\n    _.every(rawDatoValue, (item) => _isFile(item))\n  ) {\n    return \"gallery\";\n  } else if (_isJson(rawDatoValue)) {\n    return \"json\";\n  } else if (_.isString(rawDatoValue)) {\n    return \"string\";\n  } else if (_isVideo(rawDatoValue)) {\n    return \"video\";\n  } else if (\n    _.isArray(rawDatoValue) &&\n    _.every(rawDatoValue, (item) => _.isString(item))\n  ) {\n    return \"ref_list\";\n  } else {\n    return null;\n  }\n}\n\nexport function createParsedDatoValue(\n  rawDatoValue: DatoValueRaw,\n): DatoValueParsed {\n  const fieldType = detectDatoFieldType(rawDatoValue);\n  switch (fieldType) {\n    default:\n      return rawDatoValue;\n    case \"structured_text\":\n      return serializeStructuredText(rawDatoValue);\n    case \"seo\":\n      return serializeSeo(rawDatoValue);\n    case \"single_block\":\n      return serializeBlock(rawDatoValue);\n    case \"rich_text\":\n      return serializeBlockList(rawDatoValue);\n    case \"json\":\n      return JSON.parse(rawDatoValue);\n    case \"video\":\n      return serializeVideo(rawDatoValue);\n    case \"file\":\n      return serializeFile(rawDatoValue);\n    case \"gallery\":\n      return serializeGallery(rawDatoValue);\n    case \"ref_list\":\n      return null;\n  }\n}\n\nexport function createRawDatoValue(\n  parsedDatoValue: DatoValueParsed,\n  originalRawDatoValue: any,\n  isClean = false,\n): DatoValueRaw {\n  const fieldType = detectDatoFieldType(originalRawDatoValue);\n  switch (fieldType) {\n    default:\n      return parsedDatoValue;\n    case \"structured_text\":\n      return deserializeStructuredText(parsedDatoValue, originalRawDatoValue);\n    case \"seo\":\n      return deserializeSeo(parsedDatoValue, originalRawDatoValue);\n    case \"single_block\":\n      return deserializeBlock(parsedDatoValue, originalRawDatoValue, isClean);\n    case \"rich_text\":\n      return deserializeBlockList(\n        parsedDatoValue,\n        originalRawDatoValue,\n        isClean,\n      );\n    case \"json\":\n      return JSON.stringify(parsedDatoValue, null, 2);\n    case \"video\":\n      return deserializeVideo(parsedDatoValue, originalRawDatoValue);\n    case \"file\":\n      return deserializeFile(parsedDatoValue, originalRawDatoValue);\n    case \"gallery\":\n      return deserializeGallery(parsedDatoValue, originalRawDatoValue);\n    case \"ref_list\":\n      return originalRawDatoValue;\n  }\n}\n\nfunction serializeStructuredText(rawStructuredText: any) {\n  return serializeStructuredTextNode(rawStructuredText);\n  // Encapsulates helper function args\n  function serializeStructuredTextNode(\n    node: any,\n    path: string[] = [],\n    acc: Record<string, any> = {},\n  ) {\n    if (\"document\" in node) {\n      return serializeStructuredTextNode(\n        node.document,\n        [...path, \"document\"],\n        acc,\n      );\n    }\n\n    if (!_.isNil(node.value)) {\n      acc[[...path, \"value\"].join(\".\")] = node.value;\n    } else if (_.get(node, \"type\") === \"block\") {\n      acc[[...path, \"item\"].join(\".\")] = serializeBlock(node.item);\n    }\n\n    if (node.children) {\n      for (let i = 0; i < node.children.length; i++) {\n        serializeStructuredTextNode(\n          node.children[i],\n          [...path, i.toString()],\n          acc,\n        );\n      }\n    }\n\n    return acc;\n  }\n}\n\nfunction serializeSeo(rawSeo: any) {\n  return _.chain(rawSeo).pick([\"title\", \"description\"]).value();\n}\n\nfunction serializeBlock(rawBlock: any) {\n  if (_.get(rawBlock, \"type\") === \"item\" && _.has(rawBlock, \"id\")) {\n    return serializeBlock(rawBlock.attributes);\n  }\n\n  const result: Record<string, any> = {};\n  for (const [attributeName, attributeValue] of _.entries(rawBlock)) {\n    result[attributeName] = createParsedDatoValue(attributeValue);\n  }\n\n  return result;\n}\n\nfunction serializeBlockList(rawBlockList: any) {\n  return _.chain(rawBlockList)\n    .map((block) => serializeBlock(block))\n    .value();\n}\n\nfunction serializeVideo(rawVideo: any) {\n  return _.chain(rawVideo).pick([\"title\"]).value();\n}\n\nfunction serializeFile(rawFile: any) {\n  return _.chain(rawFile).pick([\"alt\", \"title\"]).value();\n}\n\nfunction serializeGallery(rawGallery: any) {\n  return _.chain(rawGallery)\n    .map((item) => serializeFile(item))\n    .value();\n}\n\nfunction deserializeFile(parsedFile: any, originalRawFile: any) {\n  return _.chain(parsedFile).defaults(originalRawFile).value();\n}\n\nfunction deserializeGallery(parsedGallery: any, originalRawGallery: any) {\n  return _.chain(parsedGallery)\n    .map((item, i) => deserializeFile(item, originalRawGallery[i]))\n    .value();\n}\n\nfunction deserializeVideo(parsedVideo: any, originalRawVideo: any) {\n  return _.chain(parsedVideo).defaults(originalRawVideo).value();\n}\n\nfunction deserializeBlock(payload: any, rawNode: any, isClean = false) {\n  const result = _.cloneDeep(rawNode);\n\n  for (const [attributeName, attributeValue] of _.entries(rawNode.attributes)) {\n    const rawValue = createRawDatoValue(\n      payload[attributeName],\n      attributeValue,\n      isClean,\n    );\n    _.set(result, [\"attributes\", attributeName], rawValue);\n  }\n\n  if (isClean) {\n    delete result[\"id\"];\n  }\n\n  return result;\n}\n\nfunction deserializeSeo(parsedSeo: any, originalRawSeo: any) {\n  return _.chain(parsedSeo)\n    .pick([\"title\", \"description\"])\n    .defaults(originalRawSeo)\n    .value();\n}\n\nfunction deserializeBlockList(\n  parsedBlockList: any,\n  originalRawBlockList: any,\n  isClean = false,\n) {\n  return _.chain(parsedBlockList)\n    .map((block, i) =>\n      deserializeBlock(block, originalRawBlockList[i], isClean),\n    )\n    .value();\n}\n\nfunction deserializeStructuredText(\n  parsedStructuredText: Record<string, string>,\n  originalRawStructuredText: any,\n) {\n  const result = _.cloneDeep(originalRawStructuredText);\n\n  for (const [path, value] of _.entries(parsedStructuredText)) {\n    const realPath = _.chain(path.split(\".\"))\n      .flatMap((s) => (!_.isNaN(_.toNumber(s)) ? [\"children\", s] : s))\n      .value();\n    const deserializedValue = createRawDatoValue(\n      value,\n      _.get(originalRawStructuredText, realPath),\n      true,\n    );\n    _.set(result, realPath, deserializedValue);\n  }\n\n  return result;\n}\n\nfunction _isJson(rawDatoValue: DatoValueRaw): boolean {\n  try {\n    return (\n      _.isString(rawDatoValue) &&\n      rawDatoValue.startsWith(\"{\") &&\n      rawDatoValue.endsWith(\"}\") &&\n      !!JSON.parse(rawDatoValue)\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _isFile(rawDatoValue: DatoValueRaw): boolean {\n  return (\n    _.isObject(rawDatoValue) &&\n    [\"alt\", \"title\", \"custom_data\", \"focal_point\", \"upload_id\"].every((key) =>\n      _.has(rawDatoValue, key),\n    )\n  );\n}\n\nfunction _isVideo(rawDatoValue: DatoValueRaw): boolean {\n  return (\n    _.isObject(rawDatoValue) &&\n    [\n      \"url\",\n      \"title\",\n      \"width\",\n      \"height\",\n      \"provider\",\n      \"provider_uid\",\n      \"thumbnail_url\",\n    ].every((key) => _.has(rawDatoValue, key))\n  );\n}\n","import webvtt from \"node-webvtt\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createVttLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      if (!input) {\n        return \"\"; // if VTT file does not exist yet we can not parse it - return empty string\n      }\n      const vtt = webvtt.parse(input)?.cues;\n      if (Object.keys(vtt).length === 0) {\n        return {};\n      } else {\n        return vtt.reduce((result: any, cue: any, index: number) => {\n          const key = `${index}#${cue.start}-${cue.end}#${cue.identifier}`;\n          result[key] = cue.text;\n          return result;\n        }, {});\n      }\n    },\n    async push(locale, payload) {\n      const output = Object.entries(payload).map(([key, text]) => {\n        const [id, timeRange, identifier] = key.split(\"#\");\n        const [startTime, endTime] = timeRange.split(\"-\");\n\n        return {\n          end: Number(endTime),\n          identifier: identifier,\n          start: Number(startTime),\n          styles: \"\",\n          text: text,\n        };\n      });\n\n      const input = {\n        valid: true,\n        strict: true,\n        cues: output,\n      };\n\n      return webvtt.compile(input);\n    },\n  });\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"../_types\";\nimport { composeLoaders, createLoader } from \"../_utils\";\nimport { isICUPluralObject } from \"../xcode-xcstrings-icu\";\n\nexport type VariableLoaderParams = {\n  type: \"ieee\" | \"python\";\n};\n\nexport default function createVariableLoader(\n  params: VariableLoaderParams,\n): ILoader<Record<string, any>, Record<string, string>> {\n  return composeLoaders(variableExtractLoader(params), variableContentLoader());\n}\n\ntype VariableExtractionPayload = {\n  variables: string[];\n  value: string | any; // Can be string or ICU object\n};\n\nfunction variableExtractLoader(\n  params: VariableLoaderParams,\n): ILoader<Record<string, any>, Record<string, VariableExtractionPayload>> {\n  const specifierPattern = getFormatSpecifierPattern(params.type);\n  return createLoader({\n    pull: async (locale, input, initXtx, originalLocale, originalInput) => {\n      const result: Record<string, VariableExtractionPayload> = {};\n      const inputValues = _.omitBy(input, _.isEmpty);\n      for (const [key, value] of Object.entries(inputValues)) {\n        const originalValue = originalInput[key];\n\n        // Handle ICU objects: strip metadata before sending to backend\n        if (isICUPluralObject(originalValue)) {\n          // ICU objects have metadata, but backend only needs the ICU string\n          // Strip _meta and pass through only the ICU string\n          const icuValue = isICUPluralObject(value)\n            ? { icu: value.icu }\n            : value;\n\n          result[key] = {\n            value: icuValue,\n            variables: [], // Metadata stored separately, not in variables\n          };\n          continue;\n        }\n\n        // Handle regular strings\n        const matches = originalValue.match(specifierPattern) || [];\n        result[key] = result[key] || {\n          value,\n          variables: [],\n        };\n        for (let i = 0; i < matches.length; i++) {\n          const match = matches[i];\n          const currentValue = result[key].value;\n          const newValue = currentValue?.replace(match, `{variable:${i}}`);\n\n          result[key].value = newValue;\n          result[key].variables[i] = match;\n        }\n      }\n      return result;\n    },\n    push: async (\n      locale,\n      data,\n      originalInput,\n      originalDefaultLocale,\n      pullInput,\n      pullOutput,\n    ) => {\n      const result: Record<string, any> = {};\n      for (const [key, valueObj] of Object.entries(data)) {\n        result[key] = valueObj.value;\n\n        // Restore metadata for ICU objects\n        const resultValue = result[key];\n        if (isICUPluralObject(resultValue)) {\n          const originalValue = originalInput?.[key];\n          if (isICUPluralObject(originalValue) && originalValue._meta) {\n            // Restore the _meta and type marker from original input\n            (resultValue as any)._meta = originalValue._meta;\n            (resultValue as any)[Symbol.for(\"@lingo.dev/icu-plural-object\")] =\n              true;\n          }\n        }\n\n        // Restore variables for regular strings\n        for (let i = 0; i < valueObj.variables.length; i++) {\n          const variable = valueObj.variables[i];\n          const currentValue = result[key];\n          if (typeof currentValue === \"string\") {\n            const newValue = currentValue?.replace(`{variable:${i}}`, variable);\n            result[key] = newValue;\n          }\n        }\n      }\n      return result;\n    },\n  });\n}\n\nfunction variableContentLoader(): ILoader<\n  Record<string, VariableExtractionPayload>,\n  Record<string, string>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const result = _.mapValues(input, (payload) => payload.value);\n      return result;\n    },\n    push: async (locale, data, originalInput, defaultLocale, pullInput) => {\n      const result: Record<string, VariableExtractionPayload> = _.cloneDeep(\n        originalInput || {},\n      );\n      for (const [key, originalValueObj] of Object.entries(result)) {\n        result[key] = {\n          ...originalValueObj,\n          value: data[key],\n        };\n      }\n      return result;\n    },\n  });\n}\n\nfunction getFormatSpecifierPattern(type: VariableLoaderParams[\"type\"]): RegExp {\n  switch (type) {\n    case \"ieee\":\n      return /%(?:\\d+\\$)?[+-]?(?:[ 0]|'.)?-?\\d*(?:\\.\\d+)?(?:[hljztL]|ll|hh)?[@diuoxXfFeEgGaAcspn%]/g;\n    case \"python\":\n      return /%\\([^)]+\\)[diouxXeEfFgGcrs%]/g;\n    default:\n      throw new Error(`Unsupported variable format type: ${type}`);\n  }\n}\n","import _ from \"lodash\";\n\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createSyncLoader(): ILoader<\n  Record<string, string>,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(locale, input, initCtx, originalLocale, originalInput) {\n      if (!originalInput) {\n        return input;\n      }\n\n      return _.chain(originalInput)\n        .mapValues((value, key) => input[key])\n        .value() as Record<string, string>;\n    },\n    async push(locale, data, originalInput) {\n      if (!originalInput) {\n        return data;\n      }\n\n      return _.chain(originalInput || {})\n        .mapValues((value, key) => data[key])\n        .value();\n    },\n  });\n}\n","export function formatPlutilStyle(\n  jsonData: any,\n  existingJson?: string,\n): string {\n  // Detect indentation from existing JSON if provided\n  const indent = existingJson ? detectIndentation(existingJson) : \"  \";\n\n  function format(data: any, level = 0): string {\n    const currentIndent = indent.repeat(level);\n    const nextIndent = indent.repeat(level + 1);\n\n    if (typeof data !== \"object\" || data === null) {\n      return JSON.stringify(data);\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length === 0) return \"[]\";\n      const items = data.map(\n        (item) => `${nextIndent}${format(item, level + 1)}`,\n      );\n      return `[\\n${items.join(\",\\n\")}\\n${currentIndent}]`;\n    }\n\n    const keys = Object.keys(data);\n    if (keys.length === 0) {\n      return `{\\n\\n${currentIndent}}`; // Empty object with proper indentation\n    }\n\n    // Sort keys to ensure whitespace keys come first\n    const sortedKeys = keys.sort((a, b) => {\n      // If both keys are whitespace or both are non-whitespace, maintain stable order\n      const aIsWhitespace = /^\\s*$/.test(a);\n      const bIsWhitespace = /^\\s*$/.test(b);\n\n      if (aIsWhitespace && !bIsWhitespace) return -1;\n      if (!aIsWhitespace && bIsWhitespace) return 1;\n      return a.localeCompare(b, undefined, { numeric: true });\n    });\n\n    const items = sortedKeys.map((key) => {\n      const value = data[key];\n      return `${nextIndent}${JSON.stringify(key)} : ${format(\n        value,\n        level + 1,\n      )}`;\n    });\n\n    return `{\\n${items.join(\",\\n\")}\\n${currentIndent}}`;\n  }\n\n  const result = format(jsonData);\n  return result;\n}\n\nfunction detectIndentation(jsonStr: string): string {\n  // Find the first indented line\n  const match = jsonStr.match(/\\n(\\s+)/);\n  return match ? match[1] : \"    \"; // fallback to 4 spaces if no indentation found\n}\n","import { formatPlutilStyle } from \"../utils/plutil-formatter\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createPlutilJsonTextLoader(): ILoader<string, string> {\n  return createLoader({\n    async pull(locale, data) {\n      return data;\n    },\n    async push(locale, data, originalInput) {\n      const jsonData = JSON.parse(data);\n      const result = formatPlutilStyle(jsonData, originalInput || \"\");\n\n      return result;\n    },\n  });\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { fromString } from \"php-array-reader\";\n\nexport default function createPhpLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      try {\n        const output = fromString(input);\n        return output;\n      } catch (error) {\n        throw new Error(`Error parsing PHP file for locale ${locale}`);\n      }\n    },\n    push: async (locale, data, originalInput) => {\n      const output = toPhpString(data, originalInput);\n      return output;\n    },\n  });\n}\n\nfunction toPhpString(\n  data: Record<string, any>,\n  originalPhpString: string | null,\n) {\n  const defaultFilePrefix = \"<?php\\n\\n\";\n  if (originalPhpString) {\n    const [filePrefix = defaultFilePrefix] = originalPhpString.split(\"return \");\n    const shortArraySyntax = !originalPhpString.includes(\"array(\");\n    const output = `${filePrefix}return ${toPhpArray(data, shortArraySyntax)};`;\n    return output;\n  }\n  return `${defaultFilePrefix}return ${toPhpArray(data)};`;\n}\n\nfunction toPhpArray(data: any, shortSyntax = true, indentLevel = 1): string {\n  if (data === null || data === undefined) {\n    return \"null\";\n  }\n  if (typeof data === \"string\") {\n    return `'${escapePhpString(data)}'`;\n  }\n  if (typeof data === \"number\") {\n    return data.toString();\n  }\n  if (typeof data === \"boolean\") {\n    return data ? \"true\" : \"false\";\n  }\n\n  const arrayStart = shortSyntax ? \"[\" : \"array(\";\n  const arrayEnd = shortSyntax ? \"]\" : \")\";\n\n  if (Array.isArray(data)) {\n    return `${arrayStart}\\n${data\n      .map(\n        (value) =>\n          `${indent(indentLevel)}${toPhpArray(\n            value,\n            shortSyntax,\n            indentLevel + 1,\n          )}`,\n      )\n      .join(\",\\n\")}\\n${indent(indentLevel - 1)}${arrayEnd}`;\n  }\n\n  const output = `${arrayStart}\\n${Object.entries(data)\n    .map(\n      ([key, value]) =>\n        `${indent(indentLevel)}'${key}' => ${toPhpArray(\n          value,\n          shortSyntax,\n          indentLevel + 1,\n        )}`,\n    )\n    .join(\",\\n\")}\\n${indent(indentLevel - 1)}${arrayEnd}`;\n  return output;\n}\n\nfunction indent(level: number) {\n  return \"  \".repeat(level);\n}\n\nfunction escapePhpString(str: string) {\n  return str\n    .replaceAll(\"\\\\\", \"\\\\\\\\\")\n    .replaceAll(\"'\", \"\\\\'\")\n    .replaceAll(\"\\r\", \"\\\\r\")\n    .replaceAll(\"\\n\", \"\\\\n\")\n    .replaceAll(\"\\t\", \"\\\\t\");\n}\n","import { jsonrepair } from \"jsonrepair\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createVueJsonLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input, ctx) => {\n      const parsed = parseVueFile(input);\n      return parsed?.i18n?.[locale] ?? {};\n    },\n    push: async (locale, data, originalInput) => {\n      const parsed = parseVueFile(originalInput ?? \"\");\n      if (!parsed) {\n        return originalInput ?? \"\";\n      }\n\n      parsed.i18n[locale] = data;\n      return `${parsed.before}<i18n>\\n${JSON.stringify(\n        parsed.i18n,\n        null,\n        2,\n      )}\\n</i18n>${parsed.after}`;\n    },\n  });\n}\n\nfunction parseVueFile(input: string) {\n  const match = input.match(/^([\\s\\S]*)<i18n>([\\s\\S]*)<\\/i18n>([\\s\\S]*)$/);\n\n  if (!match) {\n    return null;\n  }\n\n  const [, before, jsonString = \"{}\", after] = match;\n  let i18n: Record<string, any>;\n  try {\n    i18n = JSON.parse(jsonString);\n  } catch (error) {\n    i18n = JSON.parse(jsonrepair(jsonString));\n  }\n\n  return { before, after, i18n };\n}\n","import { parse } from \"@babel/parser\";\nimport _ from \"lodash\";\nimport babelTraverseModule from \"@babel/traverse\";\nimport type { NodePath } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\nimport babelGenerateModule from \"@babel/generator\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { resolveCjsExport } from \"./cjs-interop\";\n\nconst traverse = resolveCjsExport(babelTraverseModule, \"@babel/traverse\");\nconst generate = resolveCjsExport(babelGenerateModule, \"@babel/generator\");\n\nexport default function createTypescriptLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      if (!input) {\n        return {};\n      }\n\n      const ast = parseTypeScript(input);\n      const extractedStrings = extractStringsFromDefaultExport(ast);\n      return extractedStrings;\n    },\n    push: async (\n      locale,\n      data,\n      originalInput,\n      defaultLocale,\n      pullInput,\n      pullOutput,\n    ) => {\n      const ast = parseTypeScript(originalInput || \"\");\n      const finalData = _.merge({}, pullOutput, data);\n      updateStringsInDefaultExport(ast, finalData);\n\n      const { code } = generate(ast, {\n        jsescOption: {\n          minimal: true,\n        },\n      });\n      return code;\n    },\n  });\n}\n\n/**\n * Parse TypeScript code into an AST\n */\nfunction parseTypeScript(input: string) {\n  return parse(input, {\n    sourceType: \"module\",\n    plugins: [\"typescript\"],\n  });\n}\n\n/**\n * Extract the localizable (string literal) content from the default export\n * and return it as a nested object that mirrors the original structure.\n */\nfunction extractStringsFromDefaultExport(ast: t.File): Record<string, any> {\n  let extracted: Record<string, any> = {};\n\n  traverse(ast, {\n    ExportDefaultDeclaration(path: NodePath<t.ExportDefaultDeclaration>) {\n      const { declaration } = path.node;\n\n      const decl = unwrapTSAsExpression(declaration);\n\n      if (t.isObjectExpression(decl)) {\n        extracted = objectExpressionToObject(decl);\n      } else if (t.isArrayExpression(decl)) {\n        extracted = arrayExpressionToArray(decl) as unknown as Record<\n          string,\n          any\n        >;\n      } else if (t.isIdentifier(decl)) {\n        // Handle: const foo = {...}; export default foo;\n        const binding = path.scope.bindings[decl.name];\n        if (\n          binding &&\n          t.isVariableDeclarator(binding.path.node) &&\n          binding.path.node.init\n        ) {\n          const initRaw = binding.path.node.init;\n          const init = initRaw ? unwrapTSAsExpression(initRaw) : initRaw;\n          if (t.isObjectExpression(init)) {\n            extracted = objectExpressionToObject(init);\n          } else if (t.isArrayExpression(init)) {\n            extracted = arrayExpressionToArray(init) as unknown as Record<\n              string,\n              any\n            >;\n          }\n        }\n      }\n    },\n  });\n\n  return extracted;\n}\n\n/**\n * Helper: unwraps nested TSAsExpression nodes (e.g. `obj as const`)\n * to get to the underlying expression/node we care about.\n */\nfunction unwrapTSAsExpression<T extends t.Node>(node: T): t.Node {\n  let current: t.Node = node;\n  // TSAsExpression is produced for `expr as const` assertions.\n  // We want to get to the underlying expression so that the rest of the\n  // loader logic can work unchanged.\n  // There could theoretically be multiple nested `as const` assertions, so we\n  // unwrap in a loop.\n  // eslint-disable-next-line no-constant-condition\n  while (t.isTSAsExpression(current)) {\n    current = current.expression;\n  }\n  return current;\n}\n\n/**\n * Recursively converts an `ObjectExpression` into a plain JavaScript object that\n * only contains the string-literal values we care about. Non-string primitives\n * (numbers, booleans, etc.) are ignored.\n */\nfunction objectExpressionToObject(\n  objectExpression: t.ObjectExpression,\n): Record<string, any> {\n  const obj: Record<string, any> = {};\n\n  objectExpression.properties.forEach((prop) => {\n    if (!t.isObjectProperty(prop)) return;\n\n    const key = getPropertyKey(prop);\n\n    if (t.isStringLiteral(prop.value)) {\n      obj[key] = prop.value.value;\n    } else if (\n      t.isTemplateLiteral(prop.value) &&\n      prop.value.expressions.length === 0\n    ) {\n      // Handle template literals without expressions as plain strings\n      obj[key] = prop.value.quasis[0].value.cooked ?? \"\";\n    } else if (t.isObjectExpression(prop.value)) {\n      const nested = objectExpressionToObject(prop.value);\n      if (Object.keys(nested).length > 0) {\n        obj[key] = nested;\n      }\n    } else if (t.isArrayExpression(prop.value)) {\n      const arr = arrayExpressionToArray(prop.value);\n      if (arr.length > 0) {\n        obj[key] = arr;\n      }\n    }\n  });\n\n  return obj;\n}\n\n/**\n * Recursively converts an `ArrayExpression` into a JavaScript array that\n * contains string literals and nested objects/arrays when relevant.\n */\nfunction arrayExpressionToArray(arrayExpression: t.ArrayExpression): any[] {\n  const arr: any[] = [];\n\n  arrayExpression.elements.forEach((element) => {\n    if (!element) return; // holes in the array\n\n    if (t.isStringLiteral(element)) {\n      arr.push(element.value);\n    } else if (\n      t.isTemplateLiteral(element) &&\n      element.expressions.length === 0\n    ) {\n      arr.push(element.quasis[0].value.cooked ?? \"\");\n    } else if (t.isObjectExpression(element)) {\n      const nestedObj = objectExpressionToObject(element);\n      arr.push(nestedObj);\n    } else if (t.isArrayExpression(element)) {\n      arr.push(arrayExpressionToArray(element));\n    }\n  });\n\n  return arr;\n}\n\n// ------------------ updating helpers (nested data) ------------------------\n\nfunction updateStringsInDefaultExport(\n  ast: t.File,\n  data: Record<string, any>,\n): boolean {\n  let modified = false;\n\n  traverse(ast, {\n    ExportDefaultDeclaration(path: NodePath<t.ExportDefaultDeclaration>) {\n      const { declaration } = path.node;\n\n      const decl = unwrapTSAsExpression(declaration);\n\n      if (t.isObjectExpression(decl)) {\n        modified = updateStringsInObjectExpression(decl, data) || modified;\n      } else if (t.isArrayExpression(decl)) {\n        if (Array.isArray(data)) {\n          modified = updateStringsInArrayExpression(decl, data) || modified;\n        }\n      } else if (t.isIdentifier(decl)) {\n        modified = updateStringsInExportedIdentifier(path, data) || modified;\n      }\n    },\n  });\n\n  return modified;\n}\n\nfunction updateStringsInObjectExpression(\n  objectExpression: t.ObjectExpression,\n  data: Record<string, any>,\n): boolean {\n  let modified = false;\n\n  objectExpression.properties.forEach((prop) => {\n    if (!t.isObjectProperty(prop)) return;\n\n    const key = getPropertyKey(prop);\n    const incomingVal = data?.[key];\n\n    if (incomingVal === undefined) {\n      // nothing to update for this key\n      return;\n    }\n\n    if (t.isStringLiteral(prop.value) && typeof incomingVal === \"string\") {\n      if (prop.value.value !== incomingVal) {\n        prop.value.value = incomingVal;\n        modified = true;\n      }\n    } else if (\n      t.isTemplateLiteral(prop.value) &&\n      prop.value.expressions.length === 0 &&\n      typeof incomingVal === \"string\"\n    ) {\n      const currentVal = prop.value.quasis[0].value.cooked ?? \"\";\n      if (currentVal !== incomingVal) {\n        // Replace the existing template literal with an updated one\n        prop.value.quasis[0].value.raw = incomingVal;\n        prop.value.quasis[0].value.cooked = incomingVal;\n        modified = true;\n      }\n    } else if (\n      t.isObjectExpression(prop.value) &&\n      typeof incomingVal === \"object\" &&\n      !Array.isArray(incomingVal)\n    ) {\n      const subModified = updateStringsInObjectExpression(\n        prop.value,\n        incomingVal,\n      );\n      modified = subModified || modified;\n    } else if (t.isArrayExpression(prop.value) && Array.isArray(incomingVal)) {\n      const subModified = updateStringsInArrayExpression(\n        prop.value,\n        incomingVal,\n      );\n      modified = subModified || modified;\n    }\n  });\n\n  return modified;\n}\n\nfunction updateStringsInArrayExpression(\n  arrayExpression: t.ArrayExpression,\n  incoming: any[],\n): boolean {\n  let modified = false;\n\n  arrayExpression.elements.forEach((element, index) => {\n    if (!element) return;\n\n    const incomingVal = incoming?.[index];\n    if (incomingVal === undefined) return;\n\n    if (t.isStringLiteral(element) && typeof incomingVal === \"string\") {\n      if (element.value !== incomingVal) {\n        element.value = incomingVal;\n        modified = true;\n      }\n    } else if (\n      t.isTemplateLiteral(element) &&\n      element.expressions.length === 0 &&\n      typeof incomingVal === \"string\"\n    ) {\n      const currentVal = element.quasis[0].value.cooked ?? \"\";\n      if (currentVal !== incomingVal) {\n        element.quasis[0].value.raw = incomingVal;\n        element.quasis[0].value.cooked = incomingVal;\n        modified = true;\n      }\n    } else if (\n      t.isObjectExpression(element) &&\n      typeof incomingVal === \"object\" &&\n      !Array.isArray(incomingVal)\n    ) {\n      const subModified = updateStringsInObjectExpression(element, incomingVal);\n      modified = subModified || modified;\n    } else if (t.isArrayExpression(element) && Array.isArray(incomingVal)) {\n      const subModified = updateStringsInArrayExpression(element, incomingVal);\n      modified = subModified || modified;\n    }\n  });\n\n  return modified;\n}\n\nfunction updateStringsInExportedIdentifier(\n  path: NodePath<t.ExportDefaultDeclaration>,\n  data: Record<string, any>,\n): boolean {\n  const exportName = (path.node.declaration as t.Identifier).name;\n  const binding = path.scope.bindings[exportName];\n\n  if (!binding || !binding.path.node) return false;\n\n  if (t.isVariableDeclarator(binding.path.node) && binding.path.node.init) {\n    const initRaw = binding.path.node.init;\n    const init = initRaw ? unwrapTSAsExpression(initRaw) : initRaw;\n    if (t.isObjectExpression(init)) {\n      return updateStringsInObjectExpression(init, data);\n    } else if (t.isArrayExpression(init)) {\n      return updateStringsInArrayExpression(init, data as any[]);\n    }\n  }\n\n  return false;\n}\n\n/**\n * Get the string key from an object property\n */\nfunction getPropertyKey(prop: t.ObjectProperty): string {\n  if (t.isIdentifier(prop.key)) {\n    return prop.key.name;\n  } else if (t.isStringLiteral(prop.key)) {\n    return prop.key.value;\n  } else if (t.isNumericLiteral(prop.key)) {\n    return String(prop.key.value);\n  }\n  return String(prop.key);\n}\n","/**\n * @fileoverview Helpers for CommonJS ‚áÜ ES Module inter-op quirks.\n */\n\n/**\n * Resolve the actual default export value of a CommonJS module that has been\n * imported via an ES-module `import` statement.\n *\n * Why is this needed?\n * -------------------\n * When a package that is published as **CommonJS** (for example, `@babel/traverse`)\n * is imported inside native **ESM** code (or via a bundler in ESM mode) the\n * runtime value you receive is not consistent across environments:\n *\n *   ‚Ä¢ **Node.js** (native ESM) wraps the CJS module in an object like\n *     `{ default: moduleExports, ‚Ä¶namedReExports }`.\n *   ‚Ä¢ **esbuild / Vite / Vitest** may decide to mimic TypeScript's\n *     `esModuleInterop` behaviour and give you `moduleExports` directly.\n *   ‚Ä¢ Other tools can produce yet different shapes.\n *\n * If you blindly assume one shape, you will hit runtime errors such as\n * `TypeError: traverse is not a function` when the actual function lives on the\n * `.default` property ‚Äî or the opposite, depending on the environment.\n *\n * This helper inspects the imported value at runtime and returns what looks like\n * the real default export regardless of how it was wrapped.  It hides the ugly\n * `typeof mod === \"function\" ? ‚Ä¶ : mod.default` branching behind a single call\n * site.\n *\n * Example\n * -------\n * ```ts\n * import traverseModule from \"@babel/traverse\";\n * import { resolveCjsExport } from \"../utils/cjs-interop\";\n *\n * const traverse = resolveCjsExport<typeof traverseModule>(\n *   traverseModule,\n *   \"@babel/traverse\",\n * );\n * ```\n *\n * @template T Expected type of the resolved export.\n * @param mod  The runtime value returned by the `import` statement.\n * @param name Friendly name of the module (for error messages).\n * @returns    The resolved default export value.\n */\nexport function resolveCjsExport<T = any>(mod: T, name: string = \"module\"): T {\n  // If the module value itself is callable or clearly not an object, assume it's\n  // already the export we want (covers most bundler scenarios).\n  if (typeof mod === \"function\" || typeof mod !== \"object\" || mod === null) {\n    return mod as T;\n  }\n\n  // Otherwise, look for a `.default` property which is common in Node's CJS->ESM\n  // wrapper as well as in Babel's `interopRequireDefault` helpers.\n  if (\"default\" in mod && typeof mod.default !== \"undefined\") {\n    return mod.default as T;\n  }\n\n  // Give up: log the mysterious shape and throw to fail fast.\n  /* eslint-disable no-console */\n  console.error(\n    `[resolveCjsExport] Unable to determine default export for ${name}.`,\n    \"Received value:\",\n    mod,\n  );\n  throw new Error(`Failed to resolve default export for ${name}.`);\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { minimatch } from \"minimatch\";\n\nexport default function createInjectLocaleLoader(\n  injectLocaleKeys?: string[],\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    async pull(locale, data) {\n      if (!injectLocaleKeys) {\n        return data;\n      }\n      const omitKeys = _getKeysWithLocales(data, injectLocaleKeys, locale);\n      const result = _.omit(data, omitKeys);\n      return result;\n    },\n    async push(locale, data, originalInput, originalLocale) {\n      if (!injectLocaleKeys || !originalInput) {\n        return data;\n      }\n\n      const localeKeys = _getKeysWithLocales(\n        originalInput,\n        injectLocaleKeys,\n        originalLocale,\n      );\n\n      localeKeys.forEach((key) => {\n        _.set(data, key, locale);\n      });\n\n      return data;\n    },\n  });\n}\n\nfunction _getKeysWithLocales(\n  data: Record<string, any>,\n  injectLocaleKeys: string[],\n  locale: string,\n) {\n  const allKeys = _getAllKeys(data);\n  return allKeys.filter((key) => {\n    return (\n      injectLocaleKeys.some((pattern) => minimatch(key, pattern)) &&\n      _.get(data, key) === locale\n    );\n  });\n}\n\n// Helper to get all deep keys in lodash path style (e.g., 'a.b.c')\nfunction _getAllKeys(obj: Record<string, any>, prefix = \"\"): string[] {\n  let keys: string[] = [];\n  for (const key in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;\n    const path = prefix ? `${prefix}.${key}` : key;\n    if (\n      typeof obj[key] === \"object\" &&\n      obj[key] !== null &&\n      !Array.isArray(obj[key])\n    ) {\n      keys = keys.concat(_getAllKeys(obj[key], path));\n    } else {\n      keys.push(path);\n    }\n  }\n  return keys;\n}\n","export const balanced = (\n  a: string | RegExp,\n  b: string | RegExp,\n  str: string,\n) => {\n  const ma = a instanceof RegExp ? maybeMatch(a, str) : a\n  const mb = b instanceof RegExp ? maybeMatch(b, str) : b\n\n  const r = ma !== null && mb != null && range(ma, mb, str)\n\n  return (\n    r && {\n      start: r[0],\n      end: r[1],\n      pre: str.slice(0, r[0]),\n      body: str.slice(r[0] + ma.length, r[1]),\n      post: str.slice(r[1] + mb.length),\n    }\n  )\n}\n\nconst maybeMatch = (reg: RegExp, str: string) => {\n  const m = str.match(reg)\n  return m ? m[0] : null\n}\n\nexport const range = (\n  a: string,\n  b: string,\n  str: string,\n): undefined | [number, number] => {\n  let begs: number[],\n    beg: number | undefined,\n    left: number,\n    right: number | undefined = undefined,\n    result: undefined | [number, number]\n  let ai = str.indexOf(a)\n  let bi = str.indexOf(b, ai + 1)\n  let i = ai\n\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi]\n    }\n    begs = []\n    left = str.length\n\n    while (i >= 0 && !result) {\n      if (i === ai) {\n        begs.push(i)\n        ai = str.indexOf(a, i + 1)\n      } else if (begs.length === 1) {\n        const r = begs.pop()\n        if (r !== undefined) result = [r, bi]\n      } else {\n        beg = begs.pop()\n        if (beg !== undefined && beg < left) {\n          left = beg\n          right = bi\n        }\n\n        bi = str.indexOf(b, i + 1)\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi\n    }\n\n    if (begs.length && right !== undefined) {\n      result = [left, right]\n    }\n  }\n\n  return result\n}\n","import { balanced } from '@isaacs/balanced-match'\n\nconst escSlash = '\\0SLASH' + Math.random() + '\\0'\nconst escOpen = '\\0OPEN' + Math.random() + '\\0'\nconst escClose = '\\0CLOSE' + Math.random() + '\\0'\nconst escComma = '\\0COMMA' + Math.random() + '\\0'\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0'\nconst escSlashPattern = new RegExp(escSlash, 'g')\nconst escOpenPattern = new RegExp(escOpen, 'g')\nconst escClosePattern = new RegExp(escClose, 'g')\nconst escCommaPattern = new RegExp(escComma, 'g')\nconst escPeriodPattern = new RegExp(escPeriod, 'g')\nconst slashPattern = /\\\\\\\\/g\nconst openPattern = /\\\\{/g\nconst closePattern = /\\\\}/g\nconst commaPattern = /\\\\,/g\nconst periodPattern = /\\\\./g\n\nfunction numeric(str: string) {\n  return !isNaN(str as any) ? parseInt(str, 10) : str.charCodeAt(0)\n}\n\nfunction escapeBraces(str: string) {\n  return str\n    .replace(slashPattern, escSlash)\n    .replace(openPattern, escOpen)\n    .replace(closePattern, escClose)\n    .replace(commaPattern, escComma)\n    .replace(periodPattern, escPeriod)\n}\n\nfunction unescapeBraces(str: string) {\n  return str\n    .replace(escSlashPattern, '\\\\')\n    .replace(escOpenPattern, '{')\n    .replace(escClosePattern, '}')\n    .replace(escCommaPattern, ',')\n    .replace(escPeriodPattern, '.')\n}\n\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str: string) {\n  if (!str) {\n    return ['']\n  }\n\n  const parts: string[] = []\n  const m = balanced('{', '}', str)\n\n  if (!m) {\n    return str.split(',')\n  }\n\n  const { pre, body, post } = m\n  const p = pre.split(',')\n\n  p[p.length - 1] += '{' + body + '}'\n  const postParts = parseCommaParts(post)\n  if (post.length) {\n    ;(p[p.length - 1] as string) += postParts.shift()\n    p.push.apply(p, postParts)\n  }\n\n  parts.push.apply(parts, p)\n\n  return parts\n}\n\nexport function expand(str: string) {\n  if (!str) {\n    return []\n  }\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.slice(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.slice(2)\n  }\n\n  return expand_(escapeBraces(str), true).map(unescapeBraces)\n}\n\nfunction embrace(str: string) {\n  return '{' + str + '}'\n}\n\nfunction isPadded(el: string) {\n  return /^-?0\\d/.test(el)\n}\n\nfunction lte(i: number, y: number) {\n  return i <= y\n}\n\nfunction gte(i: number, y: number) {\n  return i >= y\n}\n\nfunction expand_(str: string, isTop?: boolean): string[] {\n  /** @type {string[]} */\n  const expansions: string[] = []\n\n  const m = balanced('{', '}', str)\n  if (!m) return [str]\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  const pre = m.pre\n  const post: string[] = m.post.length ? expand_(m.post, false) : ['']\n\n  if (/\\$$/.test(m.pre)) {\n    for (let k = 0; k < post.length; k++) {\n      const expansion = pre + '{' + m.body + '}' + post[k]\n      expansions.push(expansion)\n    }\n  } else {\n    const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isSequence = isNumericSequence || isAlphaSequence\n    const isOptions = m.body.indexOf(',') >= 0\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post\n        return expand_(str)\n      }\n      return [str]\n    }\n\n    let n: string[]\n    if (isSequence) {\n      n = m.body.split(/\\.\\./)\n    } else {\n      n = parseCommaParts(m.body)\n      if (n.length === 1 && n[0] !== undefined) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand_(n[0], false).map(embrace)\n        //XXX is this necessary? Can't seem to hit it in tests.\n        /* c8 ignore start */\n        if (n.length === 1) {\n          return post.map(p => m.pre + n[0] + p)\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    let N: string[]\n\n    if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n      const x = numeric(n[0])\n      const y = numeric(n[1])\n      const width = Math.max(n[0].length, n[1].length)\n      let incr =\n        n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1\n      let test = lte\n      const reverse = y < x\n      if (reverse) {\n        incr *= -1\n        test = gte\n      }\n      const pad = n.some(isPadded)\n\n      N = []\n\n      for (let i = x; test(i, y); i += incr) {\n        let c\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i)\n          if (c === '\\\\') {\n            c = ''\n          }\n        } else {\n          c = String(i)\n          if (pad) {\n            const need = width - c.length\n            if (need > 0) {\n              const z = new Array(need + 1).join('0')\n              if (i < 0) {\n                c = '-' + z + c.slice(1)\n              } else {\n                c = z + c\n              }\n            }\n          }\n        }\n        N.push(c)\n      }\n    } else {\n      N = []\n\n      for (let j = 0; j < n.length; j++) {\n        N.push.apply(N, expand_(n[j] as string, false))\n      }\n    }\n\n    for (let j = 0; j < N.length; j++) {\n      for (let k = 0; k < post.length; k++) {\n        const expansion = pre + N[j] + post[k]\n        if (!isTop || isSequence || expansion) {\n          expansions.push(expansion)\n        }\n      }\n    }\n  }\n\n  return expansions\n}\n","const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n","// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n","import { expand } from '@isaacs/brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport _ from \"lodash\";\nimport { matchesKeyPattern } from \"../utils/key-matching\";\n\nexport default function createLockedKeysLoader(\n  lockedKeys: string[],\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    pull: async (locale, data) => {\n      return _.pickBy(\n        data,\n        (value, key) => !matchesKeyPattern(key, lockedKeys),\n      );\n    },\n    push: async (locale, data, originalInput) => {\n      const lockedSubObject = _.chain(originalInput)\n        .pickBy((value, key) => matchesKeyPattern(key, lockedKeys))\n        .value();\n\n      return _.merge({}, data, lockedSubObject);\n    },\n  });\n}\n","import { minimatch } from \"minimatch\";\n\n/**\n * Checks if a key matches any of the provided patterns using prefix or glob matching\n */\nexport function matchesKeyPattern(key: string, patterns: string[]): boolean {\n  return patterns.some(\n    (pattern) => key.startsWith(pattern) || minimatch(key, pattern),\n  );\n}\n\n/**\n * Filters entries based on key matching patterns\n */\nexport function filterEntriesByPattern(\n  entries: [string, any][],\n  patterns: string[],\n): [string, any][] {\n  return entries.filter(([key]) => matchesKeyPattern(key, patterns));\n}\n\n/**\n * Formats a value for display, truncating long strings\n */\nexport function formatDisplayValue(value: any, maxLength = 50): string {\n  if (typeof value === \"string\") {\n    return value.length > maxLength\n      ? `${value.substring(0, maxLength)}...`\n      : value;\n  }\n  return JSON.stringify(value);\n}\n","import matter from \"gray-matter\";\nimport YAML from \"yaml\";\nimport { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { RawMdx } from \"./_types\";\n\nexport default function createMdxFrontmatterSplitLoader(): ILoader<\n  string,\n  RawMdx\n> {\n  const fmEngine = createFmEngine();\n\n  return createLoader({\n    async pull(locale, input) {\n      const source = input || \"\";\n      const { data: frontmatter, content } = fmEngine.parse(source);\n\n      return {\n        frontmatter: frontmatter as Record<string, any>,\n        content,\n      };\n    },\n\n    async push(locale, data) {\n      const { frontmatter = {}, content = \"\" } = data || ({} as RawMdx);\n\n      const result = fmEngine.stringify(content, frontmatter).trim();\n\n      return result;\n    },\n  });\n}\n\nfunction createFmEngine() {\n  const yamlEngine = {\n    parse: (str: string) => YAML.parse(str),\n    stringify: (obj: any) =>\n      YAML.stringify(obj, { defaultStringType: \"PLAIN\" }),\n  };\n\n  return {\n    parse: (input: string) =>\n      matter(input, {\n        engines: {\n          yaml: yamlEngine,\n        },\n      }),\n    stringify: (content: string, frontmatter: Record<string, any>) =>\n      matter.stringify(content, frontmatter, {\n        engines: {\n          yaml: yamlEngine,\n        },\n      }),\n  };\n}\n","import { MD5 } from \"object-hash\";\n\nexport function md5(input: any) {\n  return MD5(input);\n}\n","import { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { md5 } from \"../../utils/md5\";\nimport _ from \"lodash\";\n\nconst fenceRegex = /([ \\t]*)(^>\\s*)?```([\\s\\S]*?)```/gm;\nconst inlineCodeRegex = /(?<!`)`([^`\\r\\n]+?)`(?!`)/g;\n\n// Matches markdown image tags, with optional alt text & parenthesis URL, possibly inside blockquotes\n// Captures patterns like ![](url) or ![alt](url), with optional leading '> ' for blockquotes\nconst imageRegex =\n  /([ \\t]*)(^>\\s*)?!\\[[^\\]]*?\\]\\(([^()]*(\\([^()]*\\)[^()]*)*)\\)/gm;\n\n/**\n * Ensures that markdown image tags are surrounded by blank lines (\\n\\n) so that they are properly\n * treated as separate blocks during subsequent processing and serialization.\n *\n * Behaviour mirrors `ensureTrailingFenceNewline` logic for code fences:\n *   ‚Ä¢ If an image tag is already inside a blockquote (starts with `>` after trimming) we leave it untouched.\n *   ‚Ä¢ Otherwise we add two newlines before and after the image tag, then later collapse multiple\n *     consecutive blank lines back to exactly one separation using lodash chain logic.\n */\nfunction ensureSurroundingImageNewlines(_content: string) {\n  let found = false;\n  let content = _content;\n  let workingContent = content;\n\n  do {\n    found = false;\n    const matches = workingContent.match(imageRegex);\n    if (matches) {\n      const match = matches[0];\n\n      const replacement = match.trim().startsWith(\">\")\n        ? match\n        : `\\n\\n${match}\\n\\n`;\n\n      content = content.replaceAll(match, () => replacement);\n      workingContent = workingContent.replaceAll(match, \"\");\n      found = true;\n    }\n  } while (found);\n\n  content = _.chain(content)\n    .split(\"\\n\\n\")\n    .map((section) => _.trim(section, \"\\n\"))\n    .filter(Boolean)\n    .join(\"\\n\\n\")\n    .value();\n\n  return content;\n}\n\nfunction ensureTrailingFenceNewline(_content: string) {\n  let found = false;\n  let content = _content;\n  let workingContent = content;\n\n  do {\n    found = false;\n    const matches = workingContent.match(fenceRegex);\n    if (matches) {\n      const match = matches[0];\n\n      const replacement = match.trim().startsWith(\">\")\n        ? match\n        : `\\n\\n${match}\\n\\n`;\n      content = content.replaceAll(match, () => replacement);\n      workingContent = workingContent.replaceAll(match, \"\");\n      found = true;\n    }\n  } while (found);\n\n  content = _.chain(content)\n    .split(\"\\n\\n\")\n    .map((section) => _.trim(section, \"\\n\"))\n    .filter(Boolean)\n    .join(\"\\n\\n\")\n    .value();\n\n  return content;\n}\n\n// Helper that replaces code (block & inline) with stable placeholders and returns\n// both the transformed content and the placeholder ‚Üí original mapping so it can\n// later be restored. Extracted so that we can reuse the exact same logic in both\n// `pull` and `push` phases (e.g. to recreate the mapping from `originalInput`).\nfunction extractCodePlaceholders(content: string): {\n  content: string;\n  codePlaceholders: Record<string, string>;\n} {\n  let finalContent = content;\n  finalContent = ensureTrailingFenceNewline(finalContent);\n  finalContent = ensureSurroundingImageNewlines(finalContent);\n\n  const codePlaceholders: Record<string, string> = {};\n\n  const codeBlockMatches = finalContent.matchAll(fenceRegex);\n  for (const match of codeBlockMatches) {\n    const codeBlock = match[0];\n    const codeBlockHash = md5(codeBlock);\n    const placeholder = `---CODE-PLACEHOLDER-${codeBlockHash}---`;\n\n    codePlaceholders[placeholder] = codeBlock;\n\n    const replacement = codeBlock.trim().startsWith(\">\")\n      ? `> ${placeholder}`\n      : `${placeholder}`;\n    finalContent = finalContent.replace(codeBlock, () => replacement);\n  }\n\n  const inlineCodeMatches = finalContent.matchAll(inlineCodeRegex);\n  for (const match of inlineCodeMatches) {\n    const inlineCode = match[0];\n    const inlineCodeHash = md5(inlineCode);\n    const placeholder = `---INLINE-CODE-PLACEHOLDER-${inlineCodeHash}---`;\n    codePlaceholders[placeholder] = inlineCode;\n    const replacement = placeholder;\n    finalContent = finalContent.replace(inlineCode, () => replacement);\n  }\n\n  return {\n    content: finalContent,\n    codePlaceholders,\n  };\n}\n\nexport default function createMdxCodePlaceholderLoader(): ILoader<\n  string,\n  string\n> {\n  // Keep a global registry of all placeholders we've ever created\n  // This solves the state synchronization issue\n  const globalPlaceholderRegistry: Record<string, string> = {};\n\n  return createLoader({\n    async pull(locale, input) {\n      const response = extractCodePlaceholders(input);\n\n      // Register all placeholders we create so we can use them later\n      Object.assign(globalPlaceholderRegistry, response.codePlaceholders);\n\n      return response.content;\n    },\n\n    async push(locale, data, originalInput, originalLocale, pullInput) {\n      const sourceInfo = extractCodePlaceholders(originalInput ?? \"\");\n      const currentInfo = extractCodePlaceholders(pullInput ?? \"\");\n\n      // Use the global registry to ensure all placeholders can be replaced,\n      // including those from previous pulls that are no longer in current state\n      const codePlaceholders = _.merge(\n        sourceInfo.codePlaceholders,\n        currentInfo.codePlaceholders,\n        globalPlaceholderRegistry, // Include ALL placeholders ever created\n      );\n\n      let result = data;\n      for (const [placeholder, original] of Object.entries(codePlaceholders)) {\n        const replacement = original.startsWith(\">\")\n          ? _.trimStart(original, \"> \")\n          : original;\n\n        // Use function replacer to avoid special $ character handling\n        // When using a string, $ has special meaning (e.g., $` inserts text before match)\n        result = result.replaceAll(placeholder, () => replacement);\n      }\n\n      return result;\n    },\n  });\n}\n","import { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { LocalizableMdxDocument, SectionedMdx } from \"./_types\";\n\nexport default function createLocalizableMdxDocumentLoader(): ILoader<\n  SectionedMdx,\n  LocalizableMdxDocument\n> {\n  return createLoader({\n    async pull(_locale, input) {\n      return {\n        meta: input.frontmatter,\n        content: input.sections,\n      };\n    },\n\n    async push(_locale, data, originalInput, _originalLocale, pullInput) {\n      const result: SectionedMdx = {\n        frontmatter: data.meta || {},\n        sections: data.content || {},\n      };\n\n      return result;\n    },\n  });\n}\n","import { ILoader } from \"../_types\";\nimport { createLoader } from \"../_utils\";\nimport { PlaceholderedMdx, SectionedMdx } from \"./_types\";\nimport _ from \"lodash\";\n\nexport default function createMdxSectionsSplit2Loader(): ILoader<\n  PlaceholderedMdx,\n  SectionedMdx\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const sections = _.chain(input.content)\n        .split(\"\\n\\n\")\n        .filter(Boolean)\n        .map((section, index) => [index, section])\n        .fromPairs()\n        .value();\n\n      const result: SectionedMdx = {\n        frontmatter: input.frontmatter,\n        sections,\n      };\n\n      return result;\n    },\n\n    async push(locale, data, originalInput, _originalLocale, pullInput) {\n      const content = _.chain(data.sections).values().join(\"\\n\\n\").value();\n\n      const result: PlaceholderedMdx = {\n        frontmatter: data.frontmatter,\n        codePlaceholders: pullInput?.codePlaceholders || {},\n        content,\n      };\n\n      return result;\n    },\n  });\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport { md5 } from \"../utils/md5\";\n\n/**\n * Extracts content matching regex patterns and replaces it with placeholders.\n * Returns the transformed content and a mapping of placeholders to original content.\n */\nfunction extractLockedPatterns(\n  content: string,\n  patterns: string[] = [],\n): {\n  content: string;\n  lockedPlaceholders: Record<string, string>;\n} {\n  let finalContent = content;\n  const lockedPlaceholders: Record<string, string> = {};\n\n  if (!patterns || patterns.length === 0) {\n    return { content: finalContent, lockedPlaceholders };\n  }\n\n  for (const patternStr of patterns) {\n    try {\n      const pattern = new RegExp(patternStr, \"gm\");\n      const matches = Array.from(finalContent.matchAll(pattern));\n\n      for (const match of matches) {\n        const matchedText = match[0];\n        const matchHash = md5(matchedText);\n        const placeholder = `---LOCKED-PATTERN-${matchHash}---`;\n\n        lockedPlaceholders[placeholder] = matchedText;\n        finalContent = finalContent.replace(matchedText, placeholder);\n      }\n    } catch (error) {\n      console.warn(`Invalid regex pattern: ${patternStr}`);\n    }\n  }\n\n  return {\n    content: finalContent,\n    lockedPlaceholders,\n  };\n}\n\n/**\n * Creates a loader that preserves content matching regex patterns during translation.\n *\n * This loader extracts content matching the provided regex patterns and replaces it\n * with placeholders before translation. After translation, the placeholders are\n * restored with the original content.\n *\n * This is useful for preserving technical terms, code snippets, URLs, template\n * variables, and other non-translatable content within translatable files.\n *\n * Works with any string-based format (JSON, YAML, XML, Markdown, HTML, etc.).\n * Note: For structured formats (JSON, XML, YAML), ensure patterns only match\n * content within values, not structural syntax, to avoid breaking parsing.\n *\n * @param defaultPatterns - Array of regex pattern strings to match and preserve\n * @returns A loader that handles pattern locking/unlocking\n */\nexport default function createLockedPatternsLoader(\n  defaultPatterns?: string[],\n): ILoader<string, string> {\n  return createLoader({\n    async pull(locale, input, initCtx, originalLocale) {\n      const patterns = defaultPatterns || [];\n\n      const { content } = extractLockedPatterns(input || \"\", patterns);\n\n      return content;\n    },\n\n    async push(\n      locale,\n      data,\n      originalInput,\n      originalLocale,\n      pullInput,\n      pullOutput,\n    ) {\n      const patterns = defaultPatterns || [];\n\n      if (!pullInput) {\n        return data;\n      }\n\n      const { lockedPlaceholders } = extractLockedPatterns(\n        pullInput as string,\n        patterns,\n      );\n\n      let result = data;\n      for (const [placeholder, original] of Object.entries(\n        lockedPlaceholders,\n      )) {\n        result = result.replaceAll(placeholder, original);\n      }\n\n      return result;\n    },\n  });\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\nimport _ from \"lodash\";\nimport { matchesKeyPattern } from \"../utils/key-matching\";\n\nexport default function createIgnoredKeysLoader(\n  ignoredKeys: string[],\n): ILoader<Record<string, any>, Record<string, any>> {\n  return createLoader({\n    pull: async (locale, data) => {\n      const result = _.omitBy(data, (value, key) =>\n        matchesKeyPattern(key, ignoredKeys),\n      );\n      return result;\n    },\n    push: async (locale, data, originalInput, originalLocale, pullInput) => {\n      // Remove ignored keys from the data being pushed\n      const result = _.omitBy(data, (value, key) =>\n        matchesKeyPattern(key, ignoredKeys),\n      );\n      return result;\n    },\n  });\n}\n","import * as ejs from \"ejs\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\ninterface EjsParseResult {\n  content: string;\n  translatable: Record<string, string>;\n}\n\nfunction parseEjsForTranslation(input: string): EjsParseResult {\n  const translatable: Record<string, string> = {};\n  let counter = 0;\n\n  // Regular expression for all EJS tags\n  const ejsTagRegex = /<%[\\s\\S]*?%>/g;\n\n  // Split content by EJS tags, preserving both text and EJS parts\n  const parts: Array<{ type: \"text\" | \"ejs\"; content: string }> = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = ejsTagRegex.exec(input)) !== null) {\n    // Add text before the tag\n    if (match.index > lastIndex) {\n      parts.push({\n        type: \"text\",\n        content: input.slice(lastIndex, match.index),\n      });\n    }\n    // Add the EJS tag\n    parts.push({\n      type: \"ejs\",\n      content: match[0],\n    });\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Add remaining text after the last tag\n  if (lastIndex < input.length) {\n    parts.push({\n      type: \"text\",\n      content: input.slice(lastIndex),\n    });\n  }\n\n  // Build the template and extract translatable content\n  let template = \"\";\n\n  for (const part of parts) {\n    if (part.type === \"ejs\") {\n      // Keep EJS tags as-is\n      template += part.content;\n    } else {\n      // For text content, extract translatable parts while preserving HTML structure\n      const textContent = part.content;\n\n      // Extract text content from HTML tags while preserving structure\n      const htmlTagRegex = /<[^>]+>/g;\n      const textParts: Array<{ type: \"html\" | \"text\"; content: string }> = [];\n      let lastTextIndex = 0;\n      let htmlMatch;\n\n      while ((htmlMatch = htmlTagRegex.exec(textContent)) !== null) {\n        // Add text before the HTML tag\n        if (htmlMatch.index > lastTextIndex) {\n          const textBefore = textContent.slice(lastTextIndex, htmlMatch.index);\n          if (textBefore.trim()) {\n            textParts.push({ type: \"text\", content: textBefore });\n          } else {\n            textParts.push({ type: \"html\", content: textBefore });\n          }\n        }\n        // Add the HTML tag\n        textParts.push({ type: \"html\", content: htmlMatch[0] });\n        lastTextIndex = htmlMatch.index + htmlMatch[0].length;\n      }\n\n      // Add remaining text after the last HTML tag\n      if (lastTextIndex < textContent.length) {\n        const remainingText = textContent.slice(lastTextIndex);\n        if (remainingText.trim()) {\n          textParts.push({ type: \"text\", content: remainingText });\n        } else {\n          textParts.push({ type: \"html\", content: remainingText });\n        }\n      }\n\n      // If no HTML tags found, treat entire content as text\n      if (textParts.length === 0) {\n        const trimmedContent = textContent.trim();\n        if (trimmedContent) {\n          textParts.push({ type: \"text\", content: textContent });\n        } else {\n          textParts.push({ type: \"html\", content: textContent });\n        }\n      }\n\n      // Process text parts\n      for (const textPart of textParts) {\n        if (textPart.type === \"text\") {\n          const trimmedContent = textPart.content.trim();\n          if (trimmedContent) {\n            const key = `text_${counter++}`;\n            translatable[key] = trimmedContent;\n            template += textPart.content.replace(\n              trimmedContent,\n              `__LINGO_PLACEHOLDER_${key}__`,\n            );\n          } else {\n            template += textPart.content;\n          }\n        } else {\n          template += textPart.content;\n        }\n      }\n    }\n  }\n\n  return { content: template, translatable };\n}\n\nfunction reconstructEjsWithTranslation(\n  template: string,\n  translatable: Record<string, string>,\n): string {\n  let result = template;\n\n  // Replace placeholders with translated content\n  for (const [key, value] of Object.entries(translatable)) {\n    const placeholder = `__LINGO_PLACEHOLDER_${key}__`;\n    result = result.replace(new RegExp(placeholder, \"g\"), value);\n  }\n\n  return result;\n}\n\nexport default function createEjsLoader(): ILoader<\n  string,\n  Record<string, any>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      if (!input || input.trim() === \"\") {\n        return {};\n      }\n\n      try {\n        const parseResult = parseEjsForTranslation(input);\n        return parseResult.translatable;\n      } catch (error) {\n        console.warn(\n          \"Warning: Could not parse EJS template, treating as plain text\",\n        );\n        // Fallback: treat entire input as translatable content\n        return { content: input.trim() };\n      }\n    },\n\n    async push(locale, data, originalInput) {\n      if (!originalInput) {\n        // If no original input, reconstruct from data\n        return Object.values(data).join(\"\\n\");\n      }\n\n      try {\n        const parseResult = parseEjsForTranslation(originalInput);\n\n        // Merge original translatable content with new translations\n        const mergedTranslatable = { ...parseResult.translatable, ...data };\n\n        return reconstructEjsWithTranslation(\n          parseResult.content,\n          mergedTranslatable,\n        );\n      } catch (error) {\n        console.warn(\n          \"Warning: Could not reconstruct EJS template, returning translated data\",\n        );\n        return Object.values(data).join(\"\\n\");\n      }\n    },\n  });\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createEnsureKeyOrderLoader(): ILoader<\n  Record<string, any>,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (_locale, input) => {\n      return input;\n    },\n    push: async (_locale, data, originalInput) => {\n      if (!originalInput || !data) {\n        return data;\n      }\n      return reorderKeys(data, originalInput);\n    },\n  });\n}\n\nfunction reorderKeys(\n  data: Record<string, any>,\n  originalInput: Record<string, any>,\n): Record<string, any> {\n  if (_.isArray(originalInput) && _.isArray(data)) {\n    // If both are arrays, recursively reorder keys in each element\n    return data.map((item, idx) => reorderKeys(item, originalInput[idx] ?? {}));\n  }\n  if (!_.isObject(data) || _.isArray(data) || _.isDate(data)) {\n    return data;\n  }\n\n  const orderedData: Record<string, any> = {};\n  const originalKeys = Object.keys(originalInput);\n  const dataKeys = new Set(Object.keys(data));\n\n  for (const key of originalKeys) {\n    if (dataKeys.has(key)) {\n      orderedData[key] = reorderKeys(data[key], originalInput[key]);\n      dataKeys.delete(key);\n    }\n  }\n\n  return orderedData;\n}\n","import { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nexport default function createTxtLoader(): ILoader<\n  string,\n  Record<string, string>\n> {\n  return createLoader({\n    async pull(locale, input) {\n      const result: Record<string, string> = {};\n\n      if (input !== undefined && input !== null && input !== \"\") {\n        const lines = input.split(\"\\n\");\n        lines.forEach((line, index) => {\n          result[String(index + 1)] = line;\n        });\n      }\n\n      return result;\n    },\n\n    async push(locale, payload) {\n      const sortedEntries = Object.entries(payload).sort(\n        ([a], [b]) => parseInt(a) - parseInt(b),\n      );\n      return sortedEntries.map(([_, value]) => value).join(\"\\n\");\n    },\n  });\n}\n","import _ from \"lodash\";\nimport { ILoader } from \"./_types\";\nimport { createLoader } from \"./_utils\";\n\nconst TOP_LEVEL_KEY = \"--content--\";\n\nexport default function createJsonDictionaryLoader(): ILoader<\n  Record<string, any>,\n  Record<string, any>\n> {\n  return createLoader({\n    pull: async (locale, input) => {\n      const result = extractTranslatables(input, locale);\n\n      // if locale keys are on top level, only single string is extracted and returned under special key\n      if (typeof result === \"string\") {\n        return { [TOP_LEVEL_KEY]: result };\n      }\n\n      return result;\n    },\n    push: async (locale, data, originalInput, originalLocale) => {\n      if (!originalInput) {\n        throw new Error(\"Error while parsing json-dictionary bucket\");\n      }\n      const input = _.cloneDeep(originalInput);\n\n      // if content is under special key, locale keys are on top level\n      if (\n        Object.keys(data).length === 1 &&\n        Object.keys(data)[0] === TOP_LEVEL_KEY\n      ) {\n        setNestedLocale(\n          { [TOP_LEVEL_KEY]: input },\n          [TOP_LEVEL_KEY],\n          locale,\n          data[TOP_LEVEL_KEY],\n          originalLocale,\n        );\n        return input;\n      }\n\n      // set the translation under the target locale key, use value from data (which is now a string)\n      function walk(obj: any, dataNode: any, path: string[] = []) {\n        if (Array.isArray(obj) && Array.isArray(dataNode)) {\n          obj.forEach((item, idx) =>\n            walk(item, dataNode[idx], [...path, String(idx)]),\n          );\n        } else if (\n          obj &&\n          typeof obj === \"object\" &&\n          dataNode &&\n          typeof dataNode === \"object\" &&\n          !Array.isArray(dataNode)\n        ) {\n          for (const key of Object.keys(obj)) {\n            if (dataNode.hasOwnProperty(key)) {\n              walk(obj[key], dataNode[key], [...path, key]);\n            }\n          }\n        } else if (\n          obj &&\n          typeof obj === \"object\" &&\n          !Array.isArray(obj) &&\n          typeof dataNode === \"string\"\n        ) {\n          // dataNode is the new string for the target locale\n          setNestedLocale(input, path, locale, dataNode, originalLocale);\n        }\n      }\n      walk(input, data);\n\n      return input;\n    },\n  });\n}\n\n// extract all keys that match locale from object\nfunction extractTranslatables(obj: any, locale: string): any {\n  if (Array.isArray(obj)) {\n    return obj.map((item) => extractTranslatables(item, locale));\n  } else if (isTranslatableObject(obj, locale)) {\n    return obj[locale];\n  } else if (obj && typeof obj === \"object\") {\n    const result: any = {};\n    for (const key of Object.keys(obj)) {\n      const value = extractTranslatables(obj[key], locale);\n      if (\n        (typeof value === \"object\" &&\n          value !== null &&\n          Object.keys(value).length > 0) ||\n        (Array.isArray(value) && value.length > 0) ||\n        (typeof value === \"string\" && value.length > 0)\n      ) {\n        result[key] = value;\n      }\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction isTranslatableObject(obj: any, locale: string): boolean {\n  return (\n    obj &&\n    typeof obj === \"object\" &&\n    !Array.isArray(obj) &&\n    Object.prototype.hasOwnProperty.call(obj, locale)\n  );\n}\n\nfunction setNestedLocale(\n  obj: any,\n  path: string[],\n  locale: string,\n  value: string,\n  originalLocale: string,\n) {\n  let curr = obj;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (!(key in curr)) curr[key] = {};\n    curr = curr[key];\n  }\n  const last = path[path.length - 1];\n  if (curr[last] && typeof curr[last] === \"object\") {\n    curr[last][locale] = value;\n    // Reorder keys: source locale first, then others alphabetically\n    if (originalLocale && curr[last][originalLocale]) {\n      const entries = Object.entries(curr[last]);\n      const first = entries.filter(([k]) => k === originalLocale);\n      const rest = entries\n        .filter(([k]) => k !== originalLocale)\n        .sort(([a], [b]) => a.localeCompare(b));\n      const ordered = [...first, ...rest];\n      const reordered: Record<string, string> = {};\n      for (const [k, v] of ordered) {\n        reordered[k] = v as string;\n      }\n      curr[last] = reordered;\n    }\n  }\n}\n","import Z from \"zod\";\nimport jsdom from \"jsdom\";\nimport { bucketTypeSchema } from \"@lingo.dev/_spec\";\nimport { composeLoaders } from \"./_utils\";\nimport createJsonLoader from \"./json\";\nimport createJson5Loader from \"./json5\";\nimport createJsoncLoader from \"./jsonc\";\nimport createFlatLoader from \"./flat\";\nimport createTextFileLoader from \"./text-file\";\nimport createYamlLoader from \"./yaml\";\nimport createRootKeyLoader from \"./root-key\";\nimport createFlutterLoader from \"./flutter\";\nimport { ILoader } from \"./_types\";\nimport createAndroidLoader from \"./android\";\nimport createCsvLoader from \"./csv\";\nimport createHtmlLoader from \"./html\";\nimport createMarkdownLoader from \"./markdown\";\nimport createMarkdocLoader from \"./markdoc\";\nimport createPropertiesLoader from \"./properties\";\nimport createXcodeStringsLoader from \"./xcode-strings\";\nimport createXcodeStringsdictLoader from \"./xcode-stringsdict\";\nimport createXcodeXcstringsLoader from \"./xcode-xcstrings\";\nimport createXcodeXcstringsV2Loader from \"./xcode-xcstrings-v2-loader\";\nimport { isICUPluralObject } from \"./xcode-xcstrings-icu\";\nimport createUnlocalizableLoader from \"./unlocalizable\";\nimport { createFormatterLoader, FormatterType } from \"./formatters\";\nimport createPoLoader from \"./po\";\nimport createXliffLoader from \"./xliff\";\nimport createXmlLoader from \"./xml\";\nimport createSrtLoader from \"./srt\";\nimport createDatoLoader from \"./dato\";\nimport createVttLoader from \"./vtt\";\nimport createVariableLoader from \"./variable\";\nimport createSyncLoader from \"./sync\";\nimport createPlutilJsonTextLoader from \"./plutil-json-loader\";\nimport createPhpLoader from \"./php\";\nimport createVueJsonLoader from \"./vue-json\";\nimport createTypescriptLoader from \"./typescript\";\nimport createInjectLocaleLoader from \"./inject-locale\";\nimport createLockedKeysLoader from \"./locked-keys\";\nimport createMdxFrontmatterSplitLoader from \"./mdx2/frontmatter-split\";\nimport createMdxCodePlaceholderLoader from \"./mdx2/code-placeholder\";\nimport createLocalizableMdxDocumentLoader from \"./mdx2/localizable-document\";\nimport createMdxSectionsSplit2Loader from \"./mdx2/sections-split-2\";\nimport createLockedPatternsLoader from \"./locked-patterns\";\nimport createIgnoredKeysLoader from \"./ignored-keys\";\nimport createEjsLoader from \"./ejs\";\nimport createEnsureKeyOrderLoader from \"./ensure-key-order\";\nimport createTxtLoader from \"./txt\";\nimport createJsonKeysLoader from \"./json-dictionary\";\n\ntype BucketLoaderOptions = {\n  returnUnlocalizedKeys?: boolean;\n  defaultLocale: string;\n  injectLocale?: string[];\n  targetLocale?: string;\n  formatter?: FormatterType;\n};\n\nexport default function createBucketLoader(\n  bucketType: Z.infer<typeof bucketTypeSchema>,\n  bucketPathPattern: string,\n  options: BucketLoaderOptions,\n  lockedKeys?: string[],\n  lockedPatterns?: string[],\n  ignoredKeys?: string[],\n): ILoader<void, Record<string, any>> {\n  switch (bucketType) {\n    default:\n      throw new Error(`Unsupported bucket type: ${bucketType}`);\n    case \"android\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createAndroidLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"csv\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createCsvLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"html\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"html\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createHtmlLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"ejs\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createEjsLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"json\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"json\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsonLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createInjectLocaleLoader(options.injectLocale),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"json5\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createJson5Loader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createInjectLocaleLoader(options.injectLocale),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"jsonc\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsoncLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createInjectLocaleLoader(options.injectLocale),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"markdown\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"markdown\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createMarkdownLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"markdoc\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createMarkdocLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"mdx\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"mdx\", bucketPathPattern),\n        createMdxCodePlaceholderLoader(),\n        createLockedPatternsLoader(lockedPatterns),\n        createMdxFrontmatterSplitLoader(),\n        createMdxSectionsSplit2Loader(),\n        createLocalizableMdxDocumentLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"po\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createPoLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createVariableLoader({ type: \"python\" }),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"properties\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createPropertiesLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xcode-strings\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createXcodeStringsLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xcode-stringsdict\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createXcodeStringsdictLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xcode-xcstrings\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createPlutilJsonTextLoader(),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsonLoader(),\n        createXcodeXcstringsLoader(options.defaultLocale),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createVariableLoader({ type: \"ieee\" }),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xcode-xcstrings-v2\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createPlutilJsonTextLoader(),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsonLoader(),\n        createXcodeXcstringsLoader(options.defaultLocale),\n        createXcodeXcstringsV2Loader(options.defaultLocale),\n        createFlatLoader({ shouldPreserveObject: isICUPluralObject }),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createVariableLoader({ type: \"ieee\" }),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"yaml\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"yaml\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createYamlLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"yaml-root-key\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"yaml\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createYamlLoader(),\n        createRootKeyLoader(true),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"flutter\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"json\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsonLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlutterLoader(),\n        createFlatLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xliff\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createXliffLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"xml\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createXmlLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"srt\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createSrtLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"dato\":\n      return composeLoaders(\n        createDatoLoader(bucketPathPattern),\n        createSyncLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"vtt\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createVttLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"php\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createPhpLoader(),\n        createSyncLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"vue-json\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createVueJsonLoader(),\n        createSyncLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"typescript\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(\n          options.formatter,\n          \"typescript\",\n          bucketPathPattern,\n        ),\n        createLockedPatternsLoader(lockedPatterns),\n        createTypescriptLoader(),\n        createFlatLoader(),\n        createEnsureKeyOrderLoader(),\n        createSyncLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"txt\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createTxtLoader(),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n    case \"json-dictionary\":\n      return composeLoaders(\n        createTextFileLoader(bucketPathPattern),\n        createFormatterLoader(options.formatter, \"json\", bucketPathPattern),\n        createLockedPatternsLoader(lockedPatterns),\n        createJsonLoader(),\n        createJsonKeysLoader(),\n        createEnsureKeyOrderLoader(),\n        createFlatLoader(),\n        createInjectLocaleLoader(options.injectLocale),\n        createLockedKeysLoader(lockedKeys || []),\n        createIgnoredKeysLoader(ignoredKeys || []),\n        createSyncLoader(),\n        createUnlocalizableLoader(options.returnUnlocalizedKeys),\n      );\n  }\n}\n","import { Command } from \"interactive-commander\";\nimport Ora from \"ora\";\nimport { getConfig } from \"../../utils/config\";\nimport { CLIError } from \"../../utils/errors\";\nimport { getBuckets } from \"../../utils/buckets\";\nimport { executeKeyCommand } from \"./_shared-key-command\";\n\nexport default new Command()\n  .command(\"ignored-keys\")\n  .description(\n    \"Show which key-value pairs in source files match ignoredKeys patterns\",\n  )\n  .option(\"--bucket <name>\", \"Only show ignored keys for a specific bucket\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (options) => {\n    const ora = Ora();\n    try {\n      const i18nConfig = await getConfig();\n\n      if (!i18nConfig) {\n        throw new CLIError({\n          message:\n            \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n          docUrl: \"i18nNotFound\",\n        });\n      }\n\n      const buckets = getBuckets(i18nConfig);\n\n      await executeKeyCommand(i18nConfig, buckets, options, {\n        filterType: \"ignoredKeys\",\n        displayName: \"ignored\",\n      });\n    } catch (error: any) {\n      ora.fail(error.message);\n      process.exit(1);\n    }\n  });\n","import { Command } from \"interactive-commander\";\n\nimport setCmd from \"./set\";\nimport unsetCmd from \"./unset\";\nimport getCmd from \"./get\";\n\nexport default new Command()\n  .command(\"config\")\n  .description(\n    \"Manage CLI settings (authentication, API keys) stored in ~/.lingodotdevrc\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .addCommand(setCmd)\n  .addCommand(unsetCmd)\n  .addCommand(getCmd);\n","import { Command } from \"interactive-commander\";\nimport chalk from \"chalk\";\nimport dedent from \"dedent\";\nimport _ from \"lodash\";\nimport {\n  SETTINGS_KEYS,\n  loadSystemSettings,\n  saveSettings,\n} from \"../../utils/settings\";\n\nexport default new Command()\n  .name(\"set\")\n  .description(\"Set or update a CLI setting in ~/.lingodotdevrc\")\n  .addHelpText(\"afterAll\", `\\nAvailable keys:\\n  ${SETTINGS_KEYS.join(\"\\n  \")}`)\n  .argument(\n    \"<key>\",\n    \"Configuration key to set (dot notation, e.g., auth.apiKey)\",\n  )\n  .argument(\"<value>\", \"The configuration value to set\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (key: string, value: string) => {\n    if (!SETTINGS_KEYS.includes(key)) {\n      console.error(\n        dedent`\n          ${chalk.red(\"‚úñ\")} Unknown configuration key: ${chalk.bold(key)}\n          Run ${chalk.dim(\"lingo.dev config set --help\")} to see available keys.\n        `,\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    const current = loadSystemSettings();\n    const updated: any = _.cloneDeep(current);\n    _.set(updated, key, value);\n\n    try {\n      saveSettings(updated as any);\n      console.log(`${chalk.green(\"‚úî\")} Set ${chalk.bold(key)}`);\n    } catch (err) {\n      console.error(\n        chalk.red(\n          `‚úñ Failed to save configuration: ${chalk.dim(\n            err instanceof Error ? err.message : String(err),\n          )}`,\n        ),\n      );\n      process.exitCode = 1;\n    }\n  });\n","import { Command } from \"interactive-commander\";\nimport chalk from \"chalk\";\nimport dedent from \"dedent\";\nimport _ from \"lodash\";\nimport {\n  SETTINGS_KEYS,\n  loadSystemSettings,\n  saveSettings,\n} from \"../../utils/settings\";\n\nexport default new Command()\n  .name(\"unset\")\n  .description(\"Remove a CLI setting from ~/.lingodotdevrc\")\n  .addHelpText(\"afterAll\", `\\nAvailable keys:\\n  ${SETTINGS_KEYS.join(\"\\n  \")}`)\n  .argument(\n    \"<key>\",\n    \"Configuration key to remove (must match one of the available keys listed below)\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (key: string) => {\n    // Validate key first (defensive; choices() should already restrict but keep for safety).\n    if (!SETTINGS_KEYS.includes(key)) {\n      console.error(\n        dedent`\n          ${chalk.red(\"‚úñ\")} Unknown configuration key: ${chalk.bold(key)}\n          Run ${chalk.dim(\n            \"lingo.dev config unset --help\",\n          )} to see available keys.\n        `,\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    // Load existing settings.\n    const settings = loadSystemSettings();\n    const currentValue = _.get(settings, key);\n\n    if (!_.trim(String(currentValue || \"\"))) {\n      console.log(`${chalk.cyan(\"‚Ñπ\")} ${chalk.bold(key)} is not set.`);\n      return;\n    } else {\n      const updated: any = _.cloneDeep(settings);\n      _.unset(updated, key);\n      try {\n        saveSettings(updated as any);\n        console.log(\n          `${chalk.green(\"‚úî\")} Removed configuration key ${chalk.bold(key)}`,\n        );\n      } catch (err) {\n        console.error(\n          chalk.red(\n            `‚úñ Failed to save configuration: ${chalk.dim(\n              err instanceof Error ? err.message : String(err),\n            )}`,\n          ),\n        );\n        process.exitCode = 1;\n      }\n    }\n  });\n","import { Command } from \"interactive-commander\";\nimport chalk from \"chalk\";\nimport _ from \"lodash\";\nimport { SETTINGS_KEYS, loadSystemSettings } from \"../../utils/settings\";\nimport dedent from \"dedent\";\n\nexport default new Command()\n  .name(\"get\")\n  .description(\"Display the value of a CLI setting from ~/.lingodotdevrc\")\n  .addHelpText(\"afterAll\", `\\nAvailable keys:\\n  ${SETTINGS_KEYS.join(\"\\n  \")}`)\n  .argument(\n    \"<key>\",\n    \"Configuration key to read (choose from the available keys listed below)\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (key: string) => {\n    // Validate that the provided key is one of the recognised configuration keys.\n    if (!SETTINGS_KEYS.includes(key)) {\n      console.error(\n        dedent`\n          ${chalk.red(\"‚úñ\")} Unknown configuration key: ${chalk.bold(key)}\n          Run ${chalk.dim(\"lingo.dev config get --help\")} to see available keys.\n        `,\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    const settings = loadSystemSettings();\n    const value = _.get(settings, key);\n\n    if (!value) {\n      // Key is valid but not set in the configuration file.\n      console.log(`${chalk.cyan(\"‚Ñπ\")} ${chalk.bold(key)} is not set.`);\n      return;\n    }\n\n    if (typeof value === \"object\") {\n      console.log(JSON.stringify(value, null, 2));\n    } else {\n      console.log(value);\n    }\n  });\n","import {\n  bucketTypeSchema,\n  I18nConfig,\n  localeCodeSchema,\n  resolveOverriddenLocale,\n} from \"@lingo.dev/_spec\";\nimport { Command } from \"interactive-commander\";\nimport Z from \"zod\";\nimport _ from \"lodash\";\nimport * as path from \"path\";\nimport { getConfig } from \"../utils/config\";\nimport { getSettings } from \"../utils/settings\";\nimport {\n  ConfigError,\n  AuthenticationError,\n  ValidationError,\n  LocalizationError,\n  BucketProcessingError,\n  getCLIErrorType,\n  isLocalizationError,\n  isBucketProcessingError,\n  ErrorDetail,\n  aggregateErrorAnalytics,\n  createPreviousErrorContext,\n} from \"../utils/errors\";\nimport Ora from \"ora\";\nimport createBucketLoader from \"../loaders\";\nimport { createAuthenticator } from \"../utils/auth\";\nimport { getBuckets } from \"../utils/buckets\";\nimport chalk from \"chalk\";\nimport { createTwoFilesPatch } from \"diff\";\nimport inquirer from \"inquirer\";\nimport externalEditor from \"external-editor\";\nimport updateGitignore from \"../utils/update-gitignore\";\nimport createProcessor from \"../processor\";\nimport { withExponentialBackoff } from \"../utils/exp-backoff\";\nimport trackEvent from \"../utils/observability\";\nimport { createDeltaProcessor } from \"../utils/delta\";\nimport { isICUPluralObject } from \"../loaders/xcode-xcstrings-icu\";\n\nexport default new Command()\n  .command(\"i18n\")\n  .description(\n    \"DEPRECATED: Run localization pipeline (prefer `run` command instead)\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--locale <locale>\",\n    \"Limit processing to the listed target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--bucket <bucket>\",\n    \"Limit processing to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all buckets\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--key <key>\",\n    \"Limit processing to a single translation key by exact match. Filters all buckets and locales to process only this key, useful for testing or debugging specific translations. Example: auth.login.title\",\n    (val: string) => encodeURIComponent(val),\n  )\n  .option(\n    \"--file [files...]\",\n    \"Filter processing to only buckets whose file paths contain these substrings. Example: 'components' to process only files in components directories\",\n  )\n  .option(\n    \"--frozen\",\n    \"Validate translations are up-to-date without making changes - fails if source files, target files, or lockfile are out of sync. Ideal for CI/CD to ensure translation consistency before deployment\",\n  )\n  .option(\n    \"--force\",\n    \"Force re-translation of all keys, bypassing change detection. Useful when you want to regenerate translations with updated AI models or translation settings\",\n  )\n  .option(\n    \"--verbose\",\n    \"Print the translation data being processed as formatted JSON for each bucket and locale\",\n  )\n  .option(\n    \"--interactive\",\n    \"Review and edit AI-generated translations interactively before applying changes to files\",\n  )\n  .option(\n    \"--api-key <api-key>\",\n    \"Override API key from settings or environment variables\",\n  )\n  .option(\n    \"--debug\",\n    \"Pause before processing localization so you can attach a debugger\",\n  )\n  .option(\n    \"--strict\",\n    \"Stop immediately on first error instead of continuing to process remaining buckets and locales (fail-fast mode)\",\n  )\n  .action(async function (options) {\n    updateGitignore();\n\n    const ora = Ora();\n    let flags: ReturnType<typeof parseFlags>;\n\n    try {\n      flags = parseFlags(options);\n    } catch (parseError: any) {\n      // Handle flag validation errors (like invalid locale codes)\n      await trackEvent(\"unknown\", \"cmd.i18n.error\", {\n        errorType: \"validation_error\",\n        errorName: parseError.name || \"ValidationError\",\n        errorMessage: parseError.message || \"Invalid command line options\",\n        errorStack: parseError.stack,\n        fatal: true,\n        errorCount: 1,\n        stage: \"flag_validation\",\n      });\n      throw parseError;\n    }\n\n    if (flags.debug) {\n      // wait for user input, use inquirer\n      const { debug } = await inquirer.prompt([\n        {\n          type: \"confirm\",\n          name: \"debug\",\n          message: \"Debug mode. Wait for user input before continuing.\",\n        },\n      ]);\n    }\n\n    let hasErrors = false;\n    let authId: string | null = null;\n    const errorDetails: ErrorDetail[] = [];\n    try {\n      ora.start(\"Loading configuration...\");\n      const i18nConfig = getConfig();\n      const settings = getSettings(flags.apiKey);\n      ora.succeed(\"Configuration loaded\");\n\n      ora.start(\"Validating localization configuration...\");\n      validateParams(i18nConfig, flags);\n      ora.succeed(\"Localization configuration is valid\");\n\n      ora.start(\"Connecting to Lingo.dev Localization Engine...\");\n      const isByokMode = !!i18nConfig?.provider;\n\n      if (isByokMode) {\n        authId = null;\n        ora.succeed(\"Using external provider (BYOK mode)\");\n      } else {\n        const auth = await validateAuth(settings);\n        authId = auth.id;\n        ora.succeed(`Authenticated as ${auth.email}`);\n      }\n\n      await trackEvent(authId, \"cmd.i18n.start\", {\n        i18nConfig,\n        flags,\n      });\n\n      let buckets = getBuckets(i18nConfig!);\n      if (flags.bucket?.length) {\n        buckets = buckets.filter((bucket: any) =>\n          flags.bucket!.includes(bucket.type),\n        );\n      }\n      ora.succeed(\"Buckets retrieved\");\n\n      if (flags.file?.length) {\n        buckets = buckets\n          .map((bucket: any) => {\n            const paths = bucket.paths.filter((path: any) =>\n              flags.file!.find((file) => path.pathPattern?.includes(file)),\n            );\n            return { ...bucket, paths };\n          })\n          .filter((bucket: any) => bucket.paths.length > 0);\n        if (buckets.length === 0) {\n          ora.fail(\n            \"No buckets found. All buckets were filtered out by --file option.\",\n          );\n          throw new Error(\n            \"No buckets found. All buckets were filtered out by --file option.\",\n          );\n        } else {\n          ora.info(`\\x1b[36mProcessing only filtered buckets:\\x1b[0m`);\n          buckets.map((bucket: any) => {\n            ora.info(`  ${bucket.type}:`);\n            bucket.paths.forEach((path: any) => {\n              ora.info(`    - ${path.pathPattern}`);\n            });\n          });\n        }\n      }\n\n      const targetLocales = flags.locale?.length\n        ? flags.locale\n        : i18nConfig!.locale.targets;\n\n      // Ensure the lockfile exists\n      ora.start(\"Setting up localization cache...\");\n      const checkLockfileProcessor = createDeltaProcessor(\"\");\n      const lockfileExists = await checkLockfileProcessor.checkIfLockExists();\n      if (!lockfileExists) {\n        ora.start(\"Creating i18n.lock...\");\n        for (const bucket of buckets) {\n          for (const bucketPath of bucket.paths) {\n            const sourceLocale = resolveOverriddenLocale(\n              i18nConfig!.locale.source,\n              bucketPath.delimiter,\n            );\n            const bucketLoader = createBucketLoader(\n              bucket.type,\n              bucketPath.pathPattern,\n              {\n                defaultLocale: sourceLocale,\n                injectLocale: bucket.injectLocale,\n                formatter: i18nConfig!.formatter,\n              },\n              bucket.lockedKeys,\n              bucket.lockedPatterns,\n              bucket.ignoredKeys,\n            );\n            bucketLoader.setDefaultLocale(sourceLocale);\n            await bucketLoader.init();\n\n            const sourceData = await bucketLoader.pull(\n              i18nConfig!.locale.source,\n            );\n\n            const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);\n            const checksums = await deltaProcessor.createChecksums(sourceData);\n            await deltaProcessor.saveChecksums(checksums);\n          }\n        }\n        ora.succeed(\"Localization cache initialized\");\n      } else {\n        ora.succeed(\"Localization cache loaded\");\n      }\n\n      if (flags.frozen) {\n        ora.start(\"Checking for lockfile updates...\");\n        let requiresUpdate: string | null = null;\n        bucketLoop: for (const bucket of buckets) {\n          for (const bucketPath of bucket.paths) {\n            const sourceLocale = resolveOverriddenLocale(\n              i18nConfig!.locale.source,\n              bucketPath.delimiter,\n            );\n\n            const bucketLoader = createBucketLoader(\n              bucket.type,\n              bucketPath.pathPattern,\n              {\n                defaultLocale: sourceLocale,\n                returnUnlocalizedKeys: true,\n                injectLocale: bucket.injectLocale,\n              },\n              bucket.lockedKeys,\n              bucket.lockedPatterns,\n              bucket.ignoredKeys,\n            );\n            bucketLoader.setDefaultLocale(sourceLocale);\n            await bucketLoader.init();\n\n            const { unlocalizable: sourceUnlocalizable, ...sourceData } =\n              await bucketLoader.pull(i18nConfig!.locale.source);\n            const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);\n            const sourceChecksums =\n              await deltaProcessor.createChecksums(sourceData);\n            const savedChecksums = await deltaProcessor.loadChecksums();\n\n            // Get updated data by comparing current checksums with saved checksums\n            const updatedSourceData = _.pickBy(\n              sourceData,\n              (value, key) => sourceChecksums[key] !== savedChecksums[key],\n            );\n\n            // translation was updated in the source file\n            if (Object.keys(updatedSourceData).length > 0) {\n              requiresUpdate = \"updated\";\n              break bucketLoop;\n            }\n\n            for (const _targetLocale of targetLocales) {\n              const targetLocale = resolveOverriddenLocale(\n                _targetLocale,\n                bucketPath.delimiter,\n              );\n              const { unlocalizable: targetUnlocalizable, ...targetData } =\n                await bucketLoader.pull(targetLocale);\n\n              const missingKeys = _.difference(\n                Object.keys(sourceData),\n                Object.keys(targetData),\n              );\n              const extraKeys = _.difference(\n                Object.keys(targetData),\n                Object.keys(sourceData),\n              );\n              const unlocalizableDataDiff = !_.isEqual(\n                sourceUnlocalizable,\n                targetUnlocalizable,\n              );\n\n              // translation is missing in the target file\n              if (missingKeys.length > 0) {\n                requiresUpdate = \"missing\";\n                break bucketLoop;\n              }\n\n              // target file has extra translations\n              if (extraKeys.length > 0) {\n                requiresUpdate = \"extra\";\n                break bucketLoop;\n              }\n\n              // unlocalizable keys do not match\n              if (unlocalizableDataDiff) {\n                requiresUpdate = \"unlocalizable\";\n                break bucketLoop;\n              }\n            }\n          }\n        }\n\n        if (requiresUpdate) {\n          const message = {\n            updated: \"Source file has been updated.\",\n            missing: \"Target file is missing translations.\",\n            extra:\n              \"Target file has extra translations not present in the source file.\",\n            unlocalizable:\n              \"Unlocalizable data (such as booleans, dates, URLs, etc.) do not match.\",\n          }[requiresUpdate];\n          ora.fail(\n            `Localization data has changed; please update i18n.lock or run without --frozen.`,\n          );\n          ora.fail(`  Details: ${message}`);\n          throw new Error(\n            `Localization data has changed; please update i18n.lock or run without --frozen. Details: ${message}`,\n          );\n        } else {\n          ora.succeed(\"No lockfile updates required.\");\n        }\n      }\n\n      // Process each bucket\n      for (const bucket of buckets) {\n        try {\n          console.log();\n          ora.info(`Processing bucket: ${bucket.type}`);\n          for (const bucketPath of bucket.paths) {\n            const bucketOra = Ora({ indent: 2 }).info(\n              `Processing path: ${bucketPath.pathPattern}`,\n            );\n\n            const sourceLocale = resolveOverriddenLocale(\n              i18nConfig!.locale.source,\n              bucketPath.delimiter,\n            );\n\n            const bucketLoader = createBucketLoader(\n              bucket.type,\n              bucketPath.pathPattern,\n              {\n                defaultLocale: sourceLocale,\n                injectLocale: bucket.injectLocale,\n                formatter: i18nConfig!.formatter,\n              },\n              bucket.lockedKeys,\n              bucket.lockedPatterns,\n              bucket.ignoredKeys,\n            );\n            bucketLoader.setDefaultLocale(sourceLocale);\n            await bucketLoader.init();\n            let sourceData = await bucketLoader.pull(sourceLocale);\n\n            for (const _targetLocale of targetLocales) {\n              const targetLocale = resolveOverriddenLocale(\n                _targetLocale,\n                bucketPath.delimiter,\n              );\n              try {\n                bucketOra.start(\n                  `[${sourceLocale} -> ${targetLocale}] (0%) Localization in progress...`,\n                );\n\n                sourceData = await bucketLoader.pull(sourceLocale);\n\n                const targetData = await bucketLoader.pull(targetLocale);\n                const deltaProcessor = createDeltaProcessor(\n                  bucketPath.pathPattern,\n                );\n                const checksums = await deltaProcessor.loadChecksums();\n                const delta = await deltaProcessor.calculateDelta({\n                  sourceData,\n                  targetData,\n                  checksums,\n                });\n                let processableData = _.chain(sourceData)\n                  .entries()\n                  .filter(\n                    ([key, value]) =>\n                      delta.added.includes(key) ||\n                      delta.updated.includes(key) ||\n                      !!flags.force,\n                  )\n                  .fromPairs()\n                  .value();\n\n                if (flags.key) {\n                  processableData = _.pickBy(\n                    processableData,\n                    (_, key) => key === flags.key,\n                  );\n                }\n                if (flags.verbose) {\n                  bucketOra.info(JSON.stringify(processableData, null, 2));\n                }\n\n                bucketOra.start(\n                  `[${sourceLocale} -> ${targetLocale}] [${\n                    Object.keys(processableData).length\n                  } entries] (0%) AI localization in progress...`,\n                );\n                let processPayload = createProcessor(i18nConfig!.provider, {\n                  apiKey: settings.auth.apiKey,\n                  apiUrl: settings.auth.apiUrl,\n                });\n                processPayload = withExponentialBackoff(\n                  processPayload,\n                  3,\n                  1000,\n                );\n\n                const processedTargetData = await processPayload(\n                  {\n                    sourceLocale,\n                    sourceData,\n                    processableData,\n                    targetLocale,\n                    targetData,\n                  },\n                  (progress, sourceChunk, processedChunk) => {\n                    bucketOra.text = `[${sourceLocale} -> ${targetLocale}] [${\n                      Object.keys(processableData).length\n                    } entries] (${progress}%) AI localization in progress...`;\n                  },\n                );\n\n                if (flags.verbose) {\n                  bucketOra.info(JSON.stringify(processedTargetData, null, 2));\n                }\n\n                let finalTargetData = _.merge(\n                  {},\n                  sourceData,\n                  targetData,\n                  processedTargetData,\n                );\n\n                // rename keys\n                finalTargetData = _.chain(finalTargetData)\n                  .entries()\n                  .map(([key, value]) => {\n                    const renaming = delta.renamed.find(\n                      ([oldKey, newKey]) => oldKey === key,\n                    );\n                    if (!renaming) {\n                      return [key, value];\n                    }\n                    return [renaming[1], value];\n                  })\n                  .fromPairs()\n                  .value();\n\n                if (flags.interactive) {\n                  bucketOra.stop();\n                  const reviewedData = await reviewChanges({\n                    pathPattern: bucketPath.pathPattern,\n                    targetLocale,\n                    currentData: targetData,\n                    proposedData: finalTargetData,\n                    sourceData,\n                    force: flags.force!,\n                  });\n\n                  finalTargetData = reviewedData;\n                  bucketOra.start(\n                    `Applying changes to ${bucketPath} (${targetLocale})`,\n                  );\n                }\n\n                const finalDiffSize = _.chain(finalTargetData)\n                  .omitBy((value, key) => {\n                    const targetValue = targetData[key];\n\n                    // For ICU plural objects, use deep equality (excluding Symbol)\n                    if (\n                      isICUPluralObject(value) &&\n                      isICUPluralObject(targetValue)\n                    ) {\n                      return _.isEqual(\n                        { icu: value.icu, _meta: value._meta },\n                        { icu: targetValue.icu, _meta: targetValue._meta },\n                      );\n                    }\n\n                    // Default strict equality for other values\n                    return value === targetValue;\n                  })\n                  .size()\n                  .value();\n\n                // Push to bucket all the time as there might be changes to unlocalizable keys\n                await bucketLoader.push(targetLocale, finalTargetData);\n\n                if (finalDiffSize > 0 || flags.force) {\n                  bucketOra.succeed(\n                    `[${sourceLocale} -> ${targetLocale}] Localization completed`,\n                  );\n                } else {\n                  bucketOra.succeed(\n                    `[${sourceLocale} -> ${targetLocale}] Localization completed (no changes).`,\n                  );\n                }\n              } catch (_error: any) {\n                const error = new LocalizationError(\n                  `[${sourceLocale} -> ${targetLocale}] Localization failed: ${_error.message}`,\n                  {\n                    bucket: bucket.type,\n                    sourceLocale,\n                    targetLocale,\n                    pathPattern: bucketPath.pathPattern,\n                  },\n                );\n                errorDetails.push({\n                  type: \"locale_error\",\n                  bucket: bucket.type,\n                  locale: `${sourceLocale} -> ${targetLocale}`,\n                  pathPattern: bucketPath.pathPattern,\n                  message: _error.message,\n                  stack: _error.stack,\n                });\n                if (flags.strict) {\n                  throw error;\n                } else {\n                  bucketOra.fail(error.message);\n                  hasErrors = true;\n                }\n              }\n            }\n\n            const deltaProcessor = createDeltaProcessor(bucketPath.pathPattern);\n            const checksums = await deltaProcessor.createChecksums(sourceData);\n            if (!flags.locale?.length) {\n              await deltaProcessor.saveChecksums(checksums);\n            }\n          }\n        } catch (_error: any) {\n          const error = new BucketProcessingError(\n            `Failed to process bucket ${bucket.type}: ${_error.message}`,\n            bucket.type,\n          );\n          errorDetails.push({\n            type: \"bucket_error\",\n            bucket: bucket.type,\n            message: _error.message,\n            stack: _error.stack,\n          });\n          if (flags.strict) {\n            throw error;\n          } else {\n            ora.fail(error.message);\n            hasErrors = true;\n          }\n        }\n      }\n      console.log();\n      if (!hasErrors) {\n        ora.succeed(\"Localization completed.\");\n        await trackEvent(authId, \"cmd.i18n.success\", {\n          i18nConfig: {\n            sourceLocale: i18nConfig!.locale.source,\n            targetLocales: i18nConfig!.locale.targets,\n            bucketTypes: Object.keys(i18nConfig!.buckets),\n          },\n          flags,\n          bucketCount: buckets.length,\n          localeCount: targetLocales.length,\n          processedSuccessfully: true,\n        });\n      } else {\n        ora.warn(\"Localization completed with errors.\");\n        await trackEvent(authId || \"unknown\", \"cmd.i18n.error\", {\n          flags,\n          ...aggregateErrorAnalytics(\n            errorDetails,\n            buckets,\n            targetLocales,\n            i18nConfig!,\n          ),\n        });\n      }\n    } catch (error: any) {\n      ora.fail(error.message);\n\n      // Use robust error type detection\n      const errorType = getCLIErrorType(error);\n\n      // Extract additional context from typed errors\n      let errorContext: any = {};\n      if (isLocalizationError(error)) {\n        errorContext = {\n          bucket: error.bucket,\n          sourceLocale: error.sourceLocale,\n          targetLocale: error.targetLocale,\n          pathPattern: error.pathPattern,\n        };\n      } else if (isBucketProcessingError(error)) {\n        errorContext = {\n          bucket: error.bucket,\n        };\n      }\n\n      await trackEvent(authId || \"unknown\", \"cmd.i18n.error\", {\n        flags,\n        errorType,\n        errorName: error.name || \"Error\",\n        errorMessage: error.message,\n        errorStack: error.stack,\n        errorContext,\n        fatal: true,\n        errorCount: errorDetails.length + 1,\n        previousErrors: createPreviousErrorContext(errorDetails),\n      });\n    }\n  });\n\nfunction parseFlags(options: any) {\n  return Z.object({\n    apiKey: Z.string().optional(),\n    locale: Z.array(localeCodeSchema).optional(),\n    bucket: Z.array(bucketTypeSchema).optional(),\n    force: Z.boolean().optional(),\n    frozen: Z.boolean().optional(),\n    verbose: Z.boolean().optional(),\n    strict: Z.boolean().optional(),\n    key: Z.string().optional(),\n    file: Z.array(Z.string()).optional(),\n    interactive: Z.boolean().default(false),\n    debug: Z.boolean().default(false),\n  }).parse(options);\n}\n\n// Export validateAuth for use in other commands\nexport async function validateAuth(settings: ReturnType<typeof getSettings>) {\n  if (!settings.auth.apiKey) {\n    throw new AuthenticationError({\n      message:\n        \"Not authenticated. Please run `lingo.dev login` to authenticate.\",\n      docUrl: \"authError\",\n    });\n  }\n\n  const authenticator = createAuthenticator({\n    apiKey: settings.auth.apiKey,\n    apiUrl: settings.auth.apiUrl,\n  });\n  const user = await authenticator.whoami();\n  if (!user) {\n    throw new AuthenticationError({\n      message: \"Invalid API key. Please run `lingo.dev login` to authenticate.\",\n      docUrl: \"authError\",\n    });\n  }\n\n  return user;\n}\n\nfunction validateParams(\n  i18nConfig: I18nConfig | null,\n  flags: ReturnType<typeof parseFlags>,\n) {\n  if (!i18nConfig) {\n    throw new ConfigError({\n      message:\n        \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n      docUrl: \"i18nNotFound\",\n    });\n  } else if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {\n    throw new ConfigError({\n      message:\n        \"No buckets found in i18n.json. Please add at least one bucket containing i18n content.\",\n      docUrl: \"bucketNotFound\",\n    });\n  } else if (\n    flags.locale?.some((locale) => !i18nConfig.locale.targets.includes(locale))\n  ) {\n    throw new ValidationError({\n      message: `One or more specified locales do not exist in i18n.json locale.targets. Please add them to the list and try again.`,\n      docUrl: \"localeTargetNotFound\",\n    });\n  } else if (\n    flags.bucket?.some(\n      (bucket) =>\n        !i18nConfig.buckets[bucket as keyof typeof i18nConfig.buckets],\n    )\n  ) {\n    throw new ValidationError({\n      message: `One or more specified buckets do not exist in i18n.json. Please add them to the list and try again.`,\n      docUrl: \"bucketNotFound\",\n    });\n  }\n}\n\nasync function reviewChanges(args: {\n  pathPattern: string;\n  targetLocale: string;\n  currentData: Record<string, any>;\n  proposedData: Record<string, any>;\n  sourceData: Record<string, any>;\n  force: boolean;\n}): Promise<Record<string, any>> {\n  const currentStr = JSON.stringify(args.currentData, null, 2);\n  const proposedStr = JSON.stringify(args.proposedData, null, 2);\n\n  // Early return if no changes\n  if (currentStr === proposedStr && !args.force) {\n    console.log(\n      `\\n${chalk.blue(args.pathPattern)} (${chalk.yellow(\n        args.targetLocale,\n      )}): ${chalk.gray(\"No changes to review\")}`,\n    );\n    return args.proposedData;\n  }\n\n  const patch = createTwoFilesPatch(\n    `${args.pathPattern} (current)`,\n    `${args.pathPattern} (proposed)`,\n    currentStr,\n    proposedStr,\n    undefined,\n    undefined,\n    { context: 3 },\n  );\n\n  // Color the diff output\n  const coloredDiff = patch\n    .split(\"\\n\")\n    .map((line) => {\n      if (line.startsWith(\"+\")) return chalk.green(line);\n      if (line.startsWith(\"-\")) return chalk.red(line);\n      if (line.startsWith(\"@\")) return chalk.cyan(line);\n      return line;\n    })\n    .join(\"\\n\");\n\n  console.log(\n    `\\nReviewing changes for ${chalk.blue(args.pathPattern)} (${chalk.yellow(\n      args.targetLocale,\n    )}):`,\n  );\n  console.log(coloredDiff);\n\n  const { action } = await inquirer.prompt([\n    {\n      type: \"list\",\n      name: \"action\",\n      message: \"Choose action:\",\n      choices: [\n        { name: \"Approve changes\", value: \"approve\" },\n        { name: \"Skip changes\", value: \"skip\" },\n        { name: \"Edit individually\", value: \"edit\" },\n      ],\n      default: \"approve\",\n    },\n  ]);\n\n  if (action === \"approve\") {\n    return args.proposedData;\n  }\n\n  if (action === \"skip\") {\n    return args.currentData;\n  }\n\n  // If edit was chosen, prompt for each changed value\n  const customData = { ...args.currentData };\n  const changes = _.reduce(\n    args.proposedData,\n    (result: string[], value: string, key: string) => {\n      if (args.currentData[key] !== value) {\n        result.push(key);\n      }\n      return result;\n    },\n    [],\n  );\n\n  for (const key of changes) {\n    console.log(`\\nEditing value for: ${chalk.cyan(key)}`);\n    console.log(chalk.gray(\"Source text:\"), chalk.blue(args.sourceData[key]));\n    console.log(\n      chalk.gray(\"Current value:\"),\n      chalk.red(args.currentData[key] || \"(empty)\"),\n    );\n    console.log(\n      chalk.gray(\"Suggested value:\"),\n      chalk.green(args.proposedData[key]),\n    );\n    console.log(\n      chalk.gray(\n        \"\\nYour editor will open. Edit the text and save to continue.\",\n      ),\n    );\n    console.log(chalk.gray(\"------------\"));\n\n    try {\n      // Prepare the editor content with a header comment and the suggested value\n      const editorContent = [\n        \"# Edit the translation below.\",\n        \"# Lines starting with # will be ignored.\",\n        \"# Save and exit the editor to continue.\",\n        \"#\",\n        `# Source text (${chalk.blue(\"English\")}):`,\n        `# ${args.sourceData[key]}`,\n        \"#\",\n        `# Current value (${chalk.red(args.targetLocale)}):`,\n        `# ${args.currentData[key] || \"(empty)\"}`,\n        \"#\",\n        args.proposedData[key],\n      ].join(\"\\n\");\n\n      const result = externalEditor.edit(editorContent);\n\n      // Clean up the result by removing comments and trimming\n      const customValue = result\n        .split(\"\\n\")\n        .filter((line) => !line.startsWith(\"#\"))\n        .join(\"\\n\")\n        .trim();\n\n      if (customValue) {\n        customData[key] = customValue;\n      } else {\n        console.log(\n          chalk.yellow(\"Empty value provided, keeping the current value.\"),\n        );\n        customData[key] = args.currentData[key] || args.proposedData[key];\n      }\n    } catch (error) {\n      console.log(\n        chalk.red(\"Error while editing, keeping the suggested value.\"),\n      );\n      customData[key] = args.proposedData[key];\n    }\n  }\n\n  return customData;\n}\n","import { I18nConfig } from \"@lingo.dev/_spec\";\nimport chalk from \"chalk\";\nimport dedent from \"dedent\";\nimport { LocalizerFn } from \"./_base\";\nimport { createLingoLocalizer } from \"./lingo\";\nimport { createBasicTranslator } from \"./basic\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { colors } from \"../constants\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { createMistral } from \"@ai-sdk/mistral\";\nimport { createOllama } from \"ollama-ai-provider\";\n\nexport default function createProcessor(\n  provider: I18nConfig[\"provider\"],\n  params: { apiKey?: string; apiUrl: string },\n): LocalizerFn {\n  if (!provider) {\n    const result = createLingoLocalizer(params);\n    return result;\n  } else {\n    const model = getPureModelProvider(provider);\n    const settings = provider.settings || {};\n    const result = createBasicTranslator(model, provider.prompt, settings);\n    return result;\n  }\n}\n\nfunction getPureModelProvider(provider: I18nConfig[\"provider\"]) {\n  const createMissingKeyErrorMessage = (\n    providerId: string,\n    envVar?: string,\n  ) => dedent`\n  You're trying to use raw ${chalk.dim(providerId)} API for translation. ${\n    envVar\n      ? `However, ${chalk.dim(envVar)} environment variable is not set.`\n      : \"However, that provider is unavailable.\"\n  }\n\n  To fix this issue:\n  1. ${\n    envVar\n      ? `Set ${chalk.dim(envVar)} in your environment variables`\n      : \"Set the environment variable for your provider (if required)\"\n  }, or\n  2. Remove the ${chalk.italic(\n    \"provider\",\n  )} node from your i18n.json configuration to switch to ${chalk.hex(\n    colors.green,\n  )(\"Lingo.dev\")}\n\n  ${chalk.hex(colors.blue)(\"Docs: https://lingo.dev/go/docs\")}\n`;\n\n  const createUnsupportedProviderErrorMessage = (providerId?: string) =>\n    dedent`\n  You're trying to use unsupported provider: ${chalk.dim(providerId)}.\n\n  To fix this issue:\n  1. Switch to one of the supported providers, or\n  2. Remove the ${chalk.italic(\n    \"provider\",\n  )} node from your i18n.json configuration to switch to ${chalk.hex(\n    colors.green,\n  )(\"Lingo.dev\")}\n\n  ${chalk.hex(colors.blue)(\"Docs: https://lingo.dev/go/docs\")}\n  `;\n\n  switch (provider?.id) {\n    case \"openai\": {\n      if (!process.env.OPENAI_API_KEY) {\n        throw new Error(\n          createMissingKeyErrorMessage(\"OpenAI\", \"OPENAI_API_KEY\"),\n        );\n      }\n      return createOpenAI({\n        apiKey: process.env.OPENAI_API_KEY,\n        baseURL: provider.baseUrl,\n      })(provider.model);\n    }\n    case \"anthropic\": {\n      if (!process.env.ANTHROPIC_API_KEY) {\n        throw new Error(\n          createMissingKeyErrorMessage(\"Anthropic\", \"ANTHROPIC_API_KEY\"),\n        );\n      }\n      return createAnthropic({\n        apiKey: process.env.ANTHROPIC_API_KEY,\n      })(provider.model);\n    }\n    case \"google\": {\n      if (!process.env.GOOGLE_API_KEY) {\n        throw new Error(\n          createMissingKeyErrorMessage(\"Google\", \"GOOGLE_API_KEY\"),\n        );\n      }\n      return createGoogleGenerativeAI({\n        apiKey: process.env.GOOGLE_API_KEY,\n      })(provider.model);\n    }\n    case \"openrouter\": {\n      if (!process.env.OPENROUTER_API_KEY) {\n        throw new Error(\n          createMissingKeyErrorMessage(\"OpenRouter\", \"OPENROUTER_API_KEY\"),\n        );\n      }\n      return createOpenRouter({\n        apiKey: process.env.OPENROUTER_API_KEY,\n        baseURL: provider.baseUrl,\n      })(provider.model);\n    }\n    case \"ollama\": {\n      // No API key check needed for Ollama\n      return createOllama()(provider.model);\n    }\n    case \"mistral\": {\n      if (!process.env.MISTRAL_API_KEY) {\n        throw new Error(\n          createMissingKeyErrorMessage(\"Mistral\", \"MISTRAL_API_KEY\"),\n        );\n      }\n      return createMistral({\n        apiKey: process.env.MISTRAL_API_KEY,\n        baseURL: provider.baseUrl,\n      })(provider.model);\n    }\n    default: {\n      throw new Error(createUnsupportedProviderErrorMessage(provider?.id));\n    }\n  }\n}\n","import { LingoDotDevEngine } from \"@lingo.dev/_sdk\";\nimport { LocalizerInput, LocalizerProgressFn } from \"./_base\";\n\nexport function createLingoLocalizer(params: {\n  apiKey?: string;\n  apiUrl: string;\n}) {\n  return async (input: LocalizerInput, onProgress: LocalizerProgressFn) => {\n    if (!Object.keys(input.processableData).length) {\n      return input.processableData;\n    }\n\n    const lingo = new LingoDotDevEngine({\n      apiKey: params.apiKey,\n      apiUrl: params.apiUrl,\n    });\n\n    const result = await lingo.localizeObject(\n      input.processableData,\n      {\n        sourceLocale: input.sourceLocale,\n        targetLocale: input.targetLocale,\n        reference: {\n          [input.sourceLocale]: input.sourceData,\n          [input.targetLocale]: input.targetData,\n        },\n      },\n      onProgress,\n    );\n\n    return result;\n  };\n}\n","import { generateText, LanguageModelV1 } from \"ai\";\nimport { LocalizerInput, LocalizerProgressFn } from \"./_base\";\nimport _ from \"lodash\";\n\ntype ModelSettings = {\n  temperature?: number;\n};\n\nexport function createBasicTranslator(\n  model: LanguageModelV1,\n  systemPrompt: string,\n  settings: ModelSettings = {},\n) {\n  return async (input: LocalizerInput, onProgress: LocalizerProgressFn) => {\n    const chunks = extractPayloadChunks(input.processableData);\n\n    const subResults: Record<string, any>[] = [];\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const result = await doJob({\n        ...input,\n        processableData: chunk,\n      });\n      subResults.push(result);\n      onProgress((i / chunks.length) * 100, chunk, result);\n    }\n\n    const result = _.merge({}, ...subResults);\n\n    return result;\n  };\n\n  async function doJob(input: LocalizerInput) {\n    if (!Object.keys(input.processableData).length) {\n      return input.processableData;\n    }\n\n    const response = await generateText({\n      model,\n      ...settings,\n      messages: [\n        {\n          role: \"system\",\n          content: JSON.stringify({\n            role: \"system\",\n            content: systemPrompt\n              .replaceAll(\"{source}\", input.sourceLocale)\n              .replaceAll(\"{target}\", input.targetLocale),\n          }),\n        },\n        {\n          role: \"user\",\n          content: JSON.stringify({\n            sourceLocale: \"en\",\n            targetLocale: \"es\",\n            data: {\n              message: \"Hello, world!\",\n            },\n          }),\n        },\n        {\n          role: \"assistant\",\n          content: JSON.stringify({\n            sourceLocale: \"en\",\n            targetLocale: \"es\",\n            data: {\n              message: \"Hola, mundo!\",\n            },\n          }),\n        },\n        {\n          role: \"user\",\n          content: JSON.stringify({\n            sourceLocale: input.sourceLocale,\n            targetLocale: input.targetLocale,\n            data: input.processableData,\n          }),\n        },\n      ],\n    });\n\n    const result = JSON.parse(response.text);\n\n    return result?.data || {};\n  }\n}\n\n/**\n * Extract payload chunks based on the ideal chunk size\n * @param payload - The payload to be chunked\n * @returns An array of payload chunks\n */\nfunction extractPayloadChunks(\n  payload: Record<string, string>,\n): Record<string, string>[] {\n  const idealBatchItemSize = 250;\n  const batchSize = 25;\n  const result: Record<string, string>[] = [];\n  let currentChunk: Record<string, string> = {};\n  let currentChunkItemCount = 0;\n\n  const payloadEntries = Object.entries(payload);\n  for (let i = 0; i < payloadEntries.length; i++) {\n    const [key, value] = payloadEntries[i];\n    currentChunk[key] = value;\n    currentChunkItemCount++;\n\n    const currentChunkSize = countWordsInRecord(currentChunk);\n    if (\n      currentChunkSize > idealBatchItemSize ||\n      currentChunkItemCount >= batchSize ||\n      i === payloadEntries.length - 1\n    ) {\n      result.push(currentChunk);\n      currentChunk = {};\n      currentChunkItemCount = 0;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Count words in a record or array\n * @param payload - The payload to count words in\n * @returns The total number of words\n */\nfunction countWordsInRecord(\n  payload: any | Record<string, any> | Array<any>,\n): number {\n  if (Array.isArray(payload)) {\n    return payload.reduce((acc, item) => acc + countWordsInRecord(item), 0);\n  } else if (typeof payload === \"object\" && payload !== null) {\n    return Object.values(payload).reduce(\n      (acc: number, item) => acc + countWordsInRecord(item),\n      0,\n    );\n  } else if (typeof payload === \"string\") {\n    return payload.trim().split(/\\s+/).filter(Boolean).length;\n  } else {\n    return 0;\n  }\n}\n","export function withExponentialBackoff<T, Args extends any[]>(\n  fn: (...args: Args) => Promise<T>,\n  maxAttempts: number = 3,\n  baseDelay: number = 1000,\n): (...args: Args) => Promise<T> {\n  return async (...args: Args): Promise<T> => {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        return await fn(...args);\n      } catch (error) {\n        if (attempt === maxAttempts - 1) throw error;\n\n        const delay = baseDelay * Math.pow(2, attempt);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n    throw new Error(\"Unreachable code\");\n  };\n}\n","import pkg from \"node-machine-id\";\nconst { machineIdSync } = pkg;\nimport https from \"https\";\n\nconst POSTHOG_API_KEY = \"phc_eR0iSoQufBxNY36k0f0T15UvHJdTfHlh8rJcxsfhfXk\";\nconst POSTHOG_HOST = \"eu.i.posthog.com\";\nconst POSTHOG_PATH = \"/i/v0/e/\"; // Correct PostHog capture endpoint\nconst REQUEST_TIMEOUT_MS = 1000;\n\n/**\n * Sends an analytics event to PostHog using direct HTTPS API.\n * This is a fire-and-forget implementation that won't block the process.\n *\n * @param distinctId - Unique identifier for the user/device\n * @param event - Name of the event to track\n * @param properties - Additional properties to attach to the event\n */\nexport default function trackEvent(\n  distinctId: string | null | undefined,\n  event: string,\n  properties?: Record<string, any>,\n): void {\n  // Skip tracking if explicitly disabled or in CI environment\n  if (process.env.DO_NOT_TRACK === \"1\") {\n    return;\n  }\n\n  // Defer execution to next tick to avoid blocking\n  setImmediate(() => {\n    try {\n      const actualId = distinctId || `device-${machineIdSync()}`;\n\n      // PostHog expects distinct_id at the root level, not nested in properties\n      const eventData = {\n        api_key: POSTHOG_API_KEY,\n        event,\n        distinct_id: actualId,\n        properties: {\n          ...properties,\n          $lib: \"lingo.dev-cli\",\n          $lib_version: process.env.npm_package_version || \"unknown\",\n          // Essential debugging context only\n          node_version: process.version,\n          is_ci: !!process.env.CI,\n          debug_enabled: process.env.DEBUG === \"true\",\n        },\n        timestamp: new Date().toISOString(),\n      };\n\n      const payload = JSON.stringify(eventData);\n\n      const options: https.RequestOptions = {\n        hostname: POSTHOG_HOST,\n        path: POSTHOG_PATH,\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Content-Length\": Buffer.byteLength(payload).toString(),\n        },\n        timeout: REQUEST_TIMEOUT_MS,\n      };\n\n      const req = https.request(options);\n\n      // Handle timeout by destroying the request\n      req.on(\"timeout\", () => {\n        req.destroy();\n      });\n\n      // Silently ignore errors to prevent crashes\n      req.on(\"error\", (error) => {\n        if (process.env.DEBUG === \"true\") {\n          console.error(\"[Tracking] Error ignored:\", error.message);\n        }\n      });\n\n      // Send payload and close the request\n      req.write(payload);\n      req.end();\n\n      // Ensure cleanup after timeout\n      setTimeout(() => {\n        if (!req.destroyed) {\n          req.destroy();\n        }\n      }, REQUEST_TIMEOUT_MS);\n    } catch (error) {\n      // Catch-all for any synchronous errors\n      if (process.env.DEBUG === \"true\") {\n        console.error(\"[Tracking] Failed to send event:\", error);\n      }\n    }\n  });\n}\n","import _ from \"lodash\";\nimport z from \"zod\";\nimport { md5 } from \"./md5\";\nimport { tryReadFile, writeFile, checkIfFileExists } from \"../utils/fs\";\nimport * as path from \"path\";\nimport YAML from \"yaml\";\n\nconst LockSchema = z.object({\n  version: z.literal(1).default(1),\n  checksums: z\n    .record(\n      z.string(), // localizable files' keys\n      // checksums hashmap\n      z\n        .record(\n          // key\n          z.string(),\n          // checksum of the key's value in the source locale\n          z.string(),\n        )\n        .default({}),\n    )\n    .default({}),\n});\nexport type LockData = z.infer<typeof LockSchema>;\n\nexport type Delta = {\n  added: string[];\n  removed: string[];\n  updated: string[];\n  renamed: [string, string][];\n  hasChanges: boolean;\n};\n\nexport function createDeltaProcessor(fileKey: string) {\n  const lockfilePath = path.join(process.cwd(), \"i18n.lock\");\n  return {\n    async checkIfLockExists() {\n      return checkIfFileExists(lockfilePath);\n    },\n    async calculateDelta(params: {\n      sourceData: Record<string, any>;\n      targetData: Record<string, any>;\n      checksums: Record<string, string>;\n    }): Promise<Delta> {\n      let added = _.difference(\n        Object.keys(params.sourceData),\n        Object.keys(params.targetData),\n      );\n      let removed = _.difference(\n        Object.keys(params.targetData),\n        Object.keys(params.sourceData),\n      );\n      const updated = Object.keys(params.sourceData).filter(\n        (key) =>\n          md5(params.sourceData[key]) !== params.checksums[key] &&\n          params.checksums[key],\n      );\n\n      const renamed: [string, string][] = [];\n      for (const addedKey of added) {\n        const addedHash = md5(params.sourceData[addedKey]);\n        for (const removedKey of removed) {\n          if (params.checksums[removedKey] === addedHash) {\n            renamed.push([removedKey, addedKey]);\n            break;\n          }\n        }\n      }\n      added = added.filter(\n        (key) => !renamed.some(([oldKey, newKey]) => newKey === key),\n      );\n      removed = removed.filter(\n        (key) => !renamed.some(([oldKey, newKey]) => oldKey === key),\n      );\n\n      const hasChanges = [\n        added.length > 0,\n        removed.length > 0,\n        updated.length > 0,\n        renamed.length > 0,\n      ].some((v) => v);\n\n      return {\n        added,\n        removed,\n        updated,\n        renamed,\n        hasChanges,\n      };\n    },\n    async loadLock() {\n      const lockfileContent = tryReadFile(lockfilePath, null);\n      const lockfileYaml = lockfileContent ? YAML.parse(lockfileContent) : null;\n      const lockfileData: z.infer<typeof LockSchema> = lockfileYaml\n        ? LockSchema.parse(lockfileYaml)\n        : {\n            version: 1,\n            checksums: {},\n          };\n      return lockfileData;\n    },\n    async saveLock(lockData: LockData) {\n      const lockfileYaml = YAML.stringify(lockData);\n      writeFile(lockfilePath, lockfileYaml);\n    },\n    async loadChecksums() {\n      const id = md5(fileKey);\n      const lockfileData = await this.loadLock();\n      return lockfileData.checksums[id] || {};\n    },\n    async saveChecksums(checksums: Record<string, string>) {\n      const id = md5(fileKey);\n      const lockfileData = await this.loadLock();\n      lockfileData.checksums[id] = checksums;\n      await this.saveLock(lockfileData);\n    },\n    async createChecksums(sourceData: Record<string, any>) {\n      const checksums = _.mapValues(sourceData, (value) => md5(value));\n      return checksums;\n    },\n  };\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\n\nexport function tryReadFile(\n  filePath: string,\n  defaultValue: string | null = null,\n): string | null {\n  try {\n    const content = fs.readFileSync(filePath, \"utf-8\");\n    return content;\n  } catch (error) {\n    return defaultValue;\n  }\n}\n\nexport function writeFile(filePath: string, content: string) {\n  // create dirs\n  const dir = path.dirname(filePath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n  fs.writeFileSync(filePath, content);\n}\n\nexport function checkIfFileExists(filePath: string) {\n  return fs.existsSync(filePath);\n}\n","import { Command } from \"interactive-commander\";\nimport Z from \"zod\";\nimport Ora from \"ora\";\nimport { createLockfileHelper } from \"../utils/lockfile\";\nimport { bucketTypeSchema, resolveOverriddenLocale } from \"@lingo.dev/_spec\";\nimport { getConfig } from \"../utils/config\";\nimport createBucketLoader from \"../loaders\";\nimport { getBuckets } from \"../utils/buckets\";\n\nexport default new Command()\n  .command(\"lockfile\")\n  .description(\n    \"Generate or refresh i18n.lock based on the current source locale content\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"-f, --force\",\n    \"Overwrite existing lockfile to reset translation tracking\",\n  )\n  .action(async (options) => {\n    const flags = flagsSchema.parse(options);\n    const ora = Ora();\n\n    const lockfileHelper = createLockfileHelper();\n    if (lockfileHelper.isLockfileExists() && !flags.force) {\n      ora.warn(\n        `Lockfile won't be created because it already exists. Use --force to overwrite.`,\n      );\n    } else {\n      const i18nConfig = getConfig();\n      const buckets = getBuckets(i18nConfig!);\n\n      for (const bucket of buckets) {\n        for (const bucketConfig of bucket.paths) {\n          const sourceLocale = resolveOverriddenLocale(\n            i18nConfig!.locale.source,\n            bucketConfig.delimiter,\n          );\n          const bucketLoader = createBucketLoader(\n            bucket.type,\n            bucketConfig.pathPattern,\n            {\n              defaultLocale: sourceLocale,\n              formatter: i18nConfig!.formatter,\n            },\n            bucket.lockedKeys,\n            bucket.lockedPatterns,\n            bucket.ignoredKeys,\n          );\n          bucketLoader.setDefaultLocale(sourceLocale);\n\n          const sourceData = await bucketLoader.pull(sourceLocale);\n          lockfileHelper.registerSourceData(\n            bucketConfig.pathPattern,\n            sourceData,\n          );\n        }\n      }\n      ora.succeed(\"Lockfile created\");\n    }\n  });\n\nconst flagsSchema = Z.object({\n  force: Z.boolean().default(false),\n});\n","import fs from \"fs\";\nimport path from \"path\";\nimport Z from \"zod\";\nimport YAML from \"yaml\";\nimport { MD5 } from \"object-hash\";\nimport _ from \"lodash\";\n\nexport function createLockfileHelper() {\n  return {\n    isLockfileExists: () => {\n      const lockfilePath = _getLockfilePath();\n      return fs.existsSync(lockfilePath);\n    },\n    registerSourceData: (\n      pathPattern: string,\n      sourceData: Record<string, any>,\n    ) => {\n      const lockfile = _loadLockfile();\n\n      const sectionKey = MD5(pathPattern);\n      const sectionChecksums = _.mapValues(sourceData, (value) => MD5(value));\n\n      lockfile.checksums[sectionKey] = sectionChecksums;\n\n      _saveLockfile(lockfile);\n    },\n    registerPartialSourceData: (\n      pathPattern: string,\n      partialSourceData: Record<string, any>,\n    ) => {\n      const lockfile = _loadLockfile();\n\n      const sectionKey = MD5(pathPattern);\n      const sectionChecksums = _.mapValues(partialSourceData, (value) =>\n        MD5(value),\n      );\n\n      lockfile.checksums[sectionKey] = _.merge(\n        {},\n        lockfile.checksums[sectionKey] ?? {},\n        sectionChecksums,\n      );\n\n      _saveLockfile(lockfile);\n    },\n    extractUpdatedData: (\n      pathPattern: string,\n      sourceData: Record<string, any>,\n    ) => {\n      const lockfile = _loadLockfile();\n\n      const sectionKey = MD5(pathPattern);\n      const currentChecksums = _.mapValues(sourceData, (value) => MD5(value));\n\n      const savedChecksums = lockfile.checksums[sectionKey] || {};\n      const updatedData = _.pickBy(\n        sourceData,\n        (value, key) => savedChecksums[key] !== currentChecksums[key],\n      );\n\n      return updatedData;\n    },\n  };\n\n  function _loadLockfile() {\n    const lockfilePath = _getLockfilePath();\n    if (!fs.existsSync(lockfilePath)) {\n      return LockfileSchema.parse({});\n    }\n    const content = fs.readFileSync(lockfilePath, \"utf-8\");\n    const result = LockfileSchema.parse(YAML.parse(content));\n    return result;\n  }\n\n  function _saveLockfile(lockfile: Z.infer<typeof LockfileSchema>) {\n    const lockfilePath = _getLockfilePath();\n    const content = YAML.stringify(lockfile);\n    fs.writeFileSync(lockfilePath, content);\n  }\n\n  function _getLockfilePath() {\n    return path.join(process.cwd(), \"i18n.lock\");\n  }\n}\n\nconst LockfileSchema = Z.object({\n  version: Z.literal(1).default(1),\n  checksums: Z.record(\n    Z.string(), // localizable files' keys\n    Z.record(\n      // checksums hashmap\n      Z.string(), // key\n      Z.string(), // checksum of the key's value in the source locale\n    ).default({}),\n  ).default({}),\n});\n","import { I18nConfig, resolveOverriddenLocale } from \"@lingo.dev/_spec\";\nimport { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport { getConfig } from \"../utils/config\";\nimport { CLIError } from \"../utils/errors\";\nimport Ora from \"ora\";\nimport createBucketLoader from \"../loaders\";\nimport { getBuckets } from \"../utils/buckets\";\n\nexport default new Command()\n  .command(\"cleanup\")\n  .description(\n    \"Remove translation keys from target locales that no longer exist in the source locale\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--locale <locale>\",\n    \"Limit cleanup to a specific target locale from i18n.json. Defaults to all configured target locales\",\n  )\n  .option(\n    \"--bucket <bucket>\",\n    \"Limit cleanup to a specific bucket type defined under `buckets` in i18n.json\",\n  )\n  .option(\n    \"--dry-run\",\n    \"Preview which keys would be deleted without making any changes\",\n  )\n  .option(\n    \"--verbose\",\n    \"Print detailed output showing the specific keys to be removed for each locale\",\n  )\n  .action(async function (options) {\n    const ora = Ora();\n    const results: any = [];\n\n    try {\n      ora.start(\"Loading configuration...\");\n      const i18nConfig = getConfig();\n      validateConfig(i18nConfig);\n      ora.succeed(\"Configuration loaded\");\n\n      let buckets = getBuckets(i18nConfig!);\n      if (options.bucket) {\n        buckets = buckets.filter(\n          (bucket: any) => bucket.type === options.bucket,\n        );\n      }\n\n      const targetLocales = options.locale\n        ? [options.locale]\n        : i18nConfig!.locale.targets;\n\n      // Process each bucket\n      for (const bucket of buckets) {\n        console.log();\n        ora.info(`Processing bucket: ${bucket.type}`);\n\n        for (const bucketConfig of bucket.paths) {\n          const sourceLocale = resolveOverriddenLocale(\n            i18nConfig!.locale.source,\n            bucketConfig.delimiter,\n          );\n          const bucketOra = Ora({ indent: 2 }).info(\n            `Processing path: ${bucketConfig.pathPattern}`,\n          );\n          const bucketLoader = createBucketLoader(\n            bucket.type,\n            bucketConfig.pathPattern,\n            {\n              defaultLocale: sourceLocale,\n              formatter: i18nConfig!.formatter,\n            },\n            bucket.lockedKeys,\n            bucket.lockedPatterns,\n            bucket.ignoredKeys,\n          );\n          bucketLoader.setDefaultLocale(sourceLocale);\n\n          // Load source data\n          const sourceData = await bucketLoader.pull(sourceLocale);\n          const sourceKeys = Object.keys(sourceData);\n\n          for (const _targetLocale of targetLocales) {\n            const targetLocale = resolveOverriddenLocale(\n              _targetLocale,\n              bucketConfig.delimiter,\n            );\n            try {\n              const targetData = await bucketLoader.pull(targetLocale);\n              const targetKeys = Object.keys(targetData);\n              const keysToRemove = _.difference(targetKeys, sourceKeys);\n\n              if (keysToRemove.length === 0) {\n                bucketOra.succeed(`[${targetLocale}] No keys to remove`);\n                continue;\n              }\n\n              if (options.verbose) {\n                bucketOra.info(\n                  `[${targetLocale}] Keys to remove: ${JSON.stringify(\n                    keysToRemove,\n                    null,\n                    2,\n                  )}`,\n                );\n              }\n\n              if (!options.dryRun) {\n                const cleanedData = _.pick(targetData, sourceKeys);\n                await bucketLoader.push(targetLocale, cleanedData);\n                bucketOra.succeed(\n                  `[${targetLocale}] Removed ${keysToRemove.length} keys`,\n                );\n              } else {\n                bucketOra.succeed(\n                  `[${targetLocale}] Would remove ${keysToRemove.length} keys (dry run)`,\n                );\n              }\n            } catch (error: any) {\n              bucketOra.fail(\n                `[${targetLocale}] Failed to cleanup: ${error.message}`,\n              );\n              results.push({\n                step: `Cleanup ${bucket.type}/${bucketConfig} for ${targetLocale}`,\n                status: \"Failed\",\n                error: error.message,\n              });\n            }\n          }\n        }\n      }\n\n      console.log();\n      ora.succeed(\"Cleanup completed!\");\n    } catch (error: any) {\n      ora.fail(error.message);\n      process.exit(1);\n    } finally {\n      displaySummary(results);\n    }\n  });\n\nfunction validateConfig(i18nConfig: I18nConfig | null) {\n  if (!i18nConfig) {\n    throw new CLIError({\n      message:\n        \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n      docUrl: \"i18nNotFound\",\n    });\n  }\n  if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {\n    throw new CLIError({\n      message:\n        \"No buckets found in i18n.json. Please add at least one bucket containing i18n content.\",\n      docUrl: \"bucketNotFound\",\n    });\n  }\n}\n\nfunction displaySummary(results: any[]) {\n  if (results.length === 0) return;\n\n  console.log(\"\\nProcess Summary:\");\n  results.forEach((result) => {\n    console.log(`${result.step}: ${result.status}`);\n    if (result.error) console.log(`  - Error: ${result.error}`);\n  });\n}\n","import { Command } from \"interactive-commander\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport Z from \"zod\";\nimport { ReplexicaEngine } from \"@lingo.dev/_sdk\";\nimport { getSettings } from \"../utils/settings\";\nimport { createAuthenticator } from \"../utils/auth\";\n\nexport default new Command()\n  .command(\"mcp\")\n  .description(\n    \"Start a Model Context Protocol (MCP) server for AI assistant integration\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async (_, program) => {\n    const apiKey = program.args[0];\n    const settings = getSettings(apiKey);\n\n    if (!settings.auth.apiKey) {\n      console.error(\"No API key provided\");\n      return;\n    }\n\n    const authenticator = createAuthenticator({\n      apiUrl: settings.auth.apiUrl,\n      apiKey: settings.auth.apiKey!,\n    });\n    const auth = await authenticator.whoami();\n\n    if (!auth) {\n      console.error(\"Not authenticated\");\n      return;\n    } else {\n      console.log(`Authenticated as ${auth.email}`);\n    }\n\n    const replexicaEngine = new ReplexicaEngine({\n      apiKey: settings.auth.apiKey,\n      apiUrl: settings.auth.apiUrl,\n    });\n\n    const server = new McpServer({\n      name: \"Lingo.dev\",\n      version: \"1.0.0\",\n    });\n\n    server.tool(\n      \"translate\",\n      \"Detect language and translate text with Lingo.dev.\",\n      {\n        text: Z.string(),\n        targetLocale: Z.string().regex(/^[a-z]{2}(-[A-Z]{2})?$/),\n      },\n      async ({ text, targetLocale }) => {\n        const sourceLocale = await replexicaEngine.recognizeLocale(text);\n        const data = await replexicaEngine.localizeText(text, {\n          sourceLocale,\n          targetLocale,\n        });\n        return { content: [{ type: \"text\", text: data }] };\n      },\n    );\n\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n    console.log(\"Lingo.dev MCP Server running on stdio\");\n  });\n","import { Command } from \"interactive-commander\";\nimport createOra from \"ora\";\nimport { getSettings } from \"../../utils/settings\";\nimport { createAuthenticator } from \"../../utils/auth\";\nimport { IIntegrationFlow } from \"./flows/_base\";\nimport { PullRequestFlow } from \"./flows/pull-request\";\nimport { InBranchFlow } from \"./flows/in-branch\";\nimport { getPlatformKit } from \"./platforms\";\n\ninterface CIOptions {\n  parallel?: boolean;\n  apiKey?: string;\n  debug?: boolean;\n  pullRequest?: boolean;\n  commitMessage?: string;\n  pullRequestTitle?: string;\n  commitAuthorName?: string;\n  commitAuthorEmail?: string;\n  workingDirectory?: string;\n  processOwnCommits?: boolean;\n}\n\nexport default new Command()\n  .command(\"ci\")\n  .description(\"Run localization pipeline in CI/CD environment\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--parallel [boolean]\",\n    \"Process translations concurrently for faster execution. Defaults to false\",\n    parseBooleanArg,\n  )\n  .option(\n    \"--api-key <key>\",\n    \"Override API key from settings or environment variables\",\n  )\n  .option(\n    \"--pull-request [boolean]\",\n    \"Create or update translations on a dedicated branch and manage pull requests automatically. When false, commits directly to current branch. Defaults to false\",\n    parseBooleanArg,\n  )\n  .option(\n    \"--commit-message <message>\",\n    \"Commit message for localization changes. Defaults to 'feat: update translations via @lingodotdev'\",\n  )\n  .option(\n    \"--pull-request-title <title>\",\n    \"Title for the pull request when using --pull-request mode. Defaults to 'feat: update translations via @lingodotdev'\",\n  )\n  .option(\n    \"--commit-author-name <name>\",\n    \"Git commit author name. Defaults to 'Lingo.dev'\",\n  )\n  .option(\n    \"--commit-author-email <email>\",\n    \"Git commit author email. Defaults to 'support@lingo.dev'\",\n  )\n  .option(\n    \"--working-directory <dir>\",\n    \"Directory to run localization from (useful for monorepos where localization files are in a subdirectory)\",\n  )\n  .option(\n    \"--process-own-commits [boolean]\",\n    \"Allow processing commits made by this CI user (bypasses infinite loop prevention)\",\n    parseBooleanArg,\n  )\n  .action(async (options: CIOptions) => {\n    const settings = getSettings(options.apiKey);\n\n    console.log(options);\n\n    if (!settings.auth.apiKey) {\n      console.error(\"No API key provided\");\n      return;\n    }\n\n    const authenticator = createAuthenticator({\n      apiUrl: settings.auth.apiUrl,\n      apiKey: settings.auth.apiKey,\n    });\n    const auth = await authenticator.whoami();\n\n    if (!auth) {\n      console.error(\"Not authenticated\");\n      return;\n    }\n\n    const env = {\n      LINGODOTDEV_API_KEY: settings.auth.apiKey,\n      LINGODOTDEV_PULL_REQUEST: options.pullRequest?.toString() || \"false\",\n      ...(options.commitMessage && {\n        LINGODOTDEV_COMMIT_MESSAGE: options.commitMessage,\n      }),\n      ...(options.pullRequestTitle && {\n        LINGODOTDEV_PULL_REQUEST_TITLE: options.pullRequestTitle,\n      }),\n      ...(options.commitAuthorName && {\n        LINGODOTDEV_COMMIT_AUTHOR_NAME: options.commitAuthorName,\n      }),\n      ...(options.commitAuthorEmail && {\n        LINGODOTDEV_COMMIT_AUTHOR_EMAIL: options.commitAuthorEmail,\n      }),\n      ...(options.workingDirectory && {\n        LINGODOTDEV_WORKING_DIRECTORY: options.workingDirectory,\n      }),\n      ...(options.processOwnCommits && {\n        LINGODOTDEV_PROCESS_OWN_COMMITS: options.processOwnCommits.toString(),\n      }),\n    };\n\n    process.env = { ...process.env, ...env };\n\n    const ora = createOra();\n    const platformKit = getPlatformKit();\n    const { isPullRequestMode } = platformKit.config;\n\n    ora.info(`Pull request mode: ${isPullRequestMode ? \"on\" : \"off\"}`);\n\n    const flow: IIntegrationFlow = isPullRequestMode\n      ? new PullRequestFlow(ora, platformKit)\n      : new InBranchFlow(ora, platformKit);\n\n    const canRun = await flow.preRun?.();\n    if (canRun === false) {\n      return;\n    }\n\n    const hasChanges = await flow.run({\n      parallel: options.parallel,\n    });\n    if (!hasChanges) {\n      return;\n    }\n\n    await flow.postRun?.();\n  });\n\nfunction parseBooleanArg(val: string | boolean | undefined): boolean {\n  if (val === true) return true;\n  if (typeof val === \"string\") {\n    return val.toLowerCase() === \"true\";\n  }\n  return false;\n}\n","import { execSync } from \"child_process\";\nimport { InBranchFlow } from \"./in-branch\";\nimport { IIntegrationFlowOptions } from \"./_base\";\n\nexport class PullRequestFlow extends InBranchFlow {\n  async preRun() {\n    const canContinue = await super.preRun?.();\n    if (!canContinue) {\n      return false;\n    }\n\n    this.ora.start(\"Calculating automated branch name\");\n    this.i18nBranchName = this.calculatePrBranchName();\n    this.ora.succeed(\n      `Automated branch name calculated: ${this.i18nBranchName}`,\n    );\n\n    this.ora.start(\"Checking if branch exists\");\n    const branchExists = await this.checkBranchExistance(this.i18nBranchName);\n    this.ora.succeed(branchExists ? \"Branch exists\" : \"Branch does not exist\");\n\n    if (branchExists) {\n      this.ora.start(`Checking out branch ${this.i18nBranchName}`);\n      this.checkoutI18nBranch(this.i18nBranchName);\n      this.ora.succeed(`Checked out branch ${this.i18nBranchName}`);\n\n      this.ora.start(\n        `Syncing with ${this.platformKit.platformConfig.baseBranchName}`,\n      );\n      this.syncI18nBranch();\n      this.ora.succeed(`Checked out and synced branch ${this.i18nBranchName}`);\n    } else {\n      this.ora.start(`Creating branch ${this.i18nBranchName}`);\n      this.createI18nBranch(this.i18nBranchName);\n      this.ora.succeed(`Created branch ${this.i18nBranchName}`);\n    }\n\n    return true;\n  }\n\n  override async run(options: IIntegrationFlowOptions) {\n    return super.run({\n      force: true,\n      ...options,\n    });\n  }\n\n  async postRun() {\n    if (!this.i18nBranchName) {\n      throw new Error(\n        \"i18nBranchName is not set. Did you forget to call preRun?\",\n      );\n    }\n\n    this.ora.start(\"Checking if PR already exists\");\n    const pullRequestNumber = await this.ensureFreshPr(this.i18nBranchName);\n    // await this.createLabelIfNotExists(pullRequestNumber, 'lingo.dev/i18n', false);\n    this.ora.succeed(\n      `Pull request ready: ${this.platformKit.buildPullRequestUrl(\n        pullRequestNumber,\n      )}`,\n    );\n  }\n\n  private calculatePrBranchName(): string {\n    return `lingo.dev/${this.platformKit.platformConfig.baseBranchName}`;\n  }\n\n  private async checkBranchExistance(prBranchName: string) {\n    return this.platformKit.branchExists({\n      branch: prBranchName,\n    });\n  }\n\n  private async ensureFreshPr(i18nBranchName: string) {\n    // Check if PR exists\n    this.ora.start(\n      `Checking for existing PR with head ${i18nBranchName} and base ${this.platformKit.platformConfig.baseBranchName}`,\n    );\n    let prNumber = await this.platformKit.getOpenPullRequestNumber({\n      branch: i18nBranchName,\n    });\n\n    if (prNumber) {\n      this.ora.succeed(`Existing PR found: #${prNumber}`);\n    } else {\n      // Create new PR\n      this.ora.start(`Creating new PR`);\n      prNumber = await this.platformKit.createPullRequest({\n        head: i18nBranchName,\n        title: this.platformKit.config.pullRequestTitle,\n        body: this.getPrBodyContent(),\n      });\n      this.ora.succeed(`Created new PR: #${prNumber}`);\n    }\n\n    return prNumber;\n  }\n\n  private checkoutI18nBranch(i18nBranchName: string) {\n    execSync(`git fetch origin ${i18nBranchName}`, { stdio: \"inherit\" });\n    execSync(`git checkout -b ${i18nBranchName}`, {\n      stdio: \"inherit\",\n    });\n  }\n\n  private createI18nBranch(i18nBranchName: string) {\n    try {\n      execSync(\n        `git fetch origin ${this.platformKit.platformConfig.baseBranchName}`,\n        { stdio: \"inherit\" },\n      );\n      execSync(\n        `git checkout -b ${i18nBranchName} origin/${this.platformKit.platformConfig.baseBranchName}`,\n        {\n          stdio: \"inherit\",\n        },\n      );\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n      this.ora.fail(`Failed to create branch: ${errorMessage}`);\n      this.ora.info(`\n      Troubleshooting tips:\n      1. Make sure you have permission to create branches\n      2. Check if the branch already exists locally (try 'git branch -a')\n      3. Verify connectivity to remote repository\n    `);\n      throw new Error(`Branch creation failed: ${errorMessage}`);\n    }\n  }\n\n  private syncI18nBranch() {\n    if (!this.i18nBranchName) {\n      throw new Error(\"i18nBranchName is not set\");\n    }\n\n    this.ora.start(\n      `Fetching latest changes from ${this.platformKit.platformConfig.baseBranchName}`,\n    );\n    execSync(\n      `git fetch origin ${this.platformKit.platformConfig.baseBranchName}`,\n      { stdio: \"inherit\" },\n    );\n    this.ora.succeed(\n      `Fetched latest changes from ${this.platformKit.platformConfig.baseBranchName}`,\n    );\n\n    try {\n      this.ora.start(\"Attempting to rebase branch\");\n      execSync(\n        `git rebase origin/${this.platformKit.platformConfig.baseBranchName}`,\n        { stdio: \"inherit\" },\n      );\n      this.ora.succeed(\"Successfully rebased branch\");\n    } catch (error) {\n      this.ora.warn(\"Rebase failed, falling back to alternative sync method\");\n\n      this.ora.start(\"Aborting failed rebase\");\n      execSync(\"git rebase --abort\", { stdio: \"inherit\" });\n      this.ora.succeed(\"Aborted failed rebase\");\n\n      this.ora.start(\n        `Resetting to ${this.platformKit.platformConfig.baseBranchName}`,\n      );\n      execSync(\n        `git reset --hard origin/${this.platformKit.platformConfig.baseBranchName}`,\n        { stdio: \"inherit\" },\n      );\n      this.ora.succeed(\n        `Reset to ${this.platformKit.platformConfig.baseBranchName}`,\n      );\n\n      this.ora.start(\"Restoring target files\");\n      const targetFiles = [\"i18n.lock\"];\n      const targetFileNames = execSync(\n        `npx lingo.dev@latest show files --target ${this.platformKit.platformConfig.baseBranchName}`,\n        { encoding: \"utf8\" },\n      )\n        .split(\"\\n\")\n        .filter(Boolean);\n      targetFiles.push(...targetFileNames);\n      execSync(`git fetch origin ${this.i18nBranchName}`, { stdio: \"inherit\" });\n      for (const file of targetFiles) {\n        try {\n          // bring all files to the i18n branch's state\n          execSync(`git checkout FETCH_HEAD -- ${file}`, { stdio: \"inherit\" });\n        } catch (error) {\n          // If file doesn't exist in FETCH_HEAD, that's okay - just skip it\n          this.ora.warn(`Skipping non-existent file: ${file}`);\n          continue;\n        }\n      }\n      this.ora.succeed(\"Restored target files\");\n    }\n\n    this.ora.start(\"Checking for changes to commit\");\n    const hasChanges = this.checkCommitableChanges();\n    if (hasChanges) {\n      execSync(\"git add .\", { stdio: \"inherit\" });\n      execSync(\n        `git commit -m \"chore: sync with ${this.platformKit.platformConfig.baseBranchName}\" --no-verify`,\n        {\n          stdio: \"inherit\",\n        },\n      );\n      this.ora.succeed(\"Committed additional changes\");\n    } else {\n      this.ora.succeed(\"No changes to commit\");\n    }\n  }\n\n  private getPrBodyContent(): string {\n    return `\nHey team,\n\n[**Lingo.dev**](https://lingo.dev) here with fresh translations!\n\n### In this update\n\n- Added missing translations\n- Performed brand voice, context and glossary checks\n- Enhanced translations using Lingo.dev Localization Engine\n\n### Next Steps\n\n- [ ] Review the changes\n- [ ] Merge when ready\n    `.trim();\n  }\n}\n","import { execSync } from \"child_process\";\nimport path from \"path\";\nimport {\n  getGitConfig,\n  IntegrationFlow,\n  escapeShellArg,\n  IIntegrationFlowOptions,\n} from \"./_base\";\nimport i18nCmd from \"../../i18n\";\nimport runCmd from \"../../run\";\n\nexport class InBranchFlow extends IntegrationFlow {\n  async preRun() {\n    this.ora.start(\"Configuring git\");\n    const canContinue = this.configureGit();\n    this.ora.succeed(\"Git configured\");\n\n    return canContinue;\n  }\n\n  async run(options: IIntegrationFlowOptions) {\n    this.ora.start(\"Running Lingo.dev\");\n    await this.runLingoDotDev(options.parallel);\n    this.ora.succeed(\"Done running Lingo.dev\");\n\n    execSync(`rm -f i18n.cache`, { stdio: \"inherit\" }); // do not commit cache file if it exists\n\n    this.ora.start(\"Checking for changes\");\n    const hasChanges = this.checkCommitableChanges();\n    this.ora.succeed(hasChanges ? \"Changes detected\" : \"No changes detected\");\n\n    if (hasChanges) {\n      this.ora.start(\"Committing changes\");\n      execSync(`git add .`, { stdio: \"inherit\" });\n      execSync(`git status --porcelain`, { stdio: \"inherit\" });\n      execSync(\n        `git commit -m ${escapeShellArg(\n          this.platformKit.config.commitMessage,\n        )} --no-verify`,\n        {\n          stdio: \"inherit\",\n        },\n      );\n      this.ora.succeed(\"Changes committed\");\n\n      this.ora.start(\"Pushing changes to remote\");\n      const currentBranch =\n        this.i18nBranchName ?? this.platformKit.platformConfig.baseBranchName;\n      execSync(\n        `git push origin ${currentBranch} ${options.force ? \"--force\" : \"\"}`,\n        {\n          stdio: \"inherit\",\n        },\n      );\n      this.ora.succeed(\"Changes pushed to remote\");\n    }\n\n    return hasChanges;\n  }\n\n  protected checkCommitableChanges() {\n    return (\n      execSync('git status --porcelain || echo \"has_changes\"', {\n        encoding: \"utf8\",\n      }).length > 0\n    );\n  }\n\n  private async runLingoDotDev(isParallel?: boolean) {\n    try {\n      if (!isParallel) {\n        await i18nCmd\n          .exitOverride()\n          .parseAsync([\"--api-key\", this.platformKit.config.replexicaApiKey], {\n            from: \"user\",\n          });\n      } else {\n        await runCmd\n          .exitOverride()\n          .parseAsync([\"--api-key\", this.platformKit.config.replexicaApiKey], {\n            from: \"user\",\n          });\n      }\n    } catch (err: any) {\n      if (err.code === \"commander.helpDisplayed\") return;\n      throw err;\n    }\n  }\n\n  private configureGit() {\n    const { processOwnCommits } = this.platformKit.config;\n    const { baseBranchName } = this.platformKit.platformConfig;\n    const gitConfig = getGitConfig(this.platformKit);\n\n    this.ora.info(`Current working directory:`);\n    execSync(`pwd`, { stdio: \"inherit\" });\n    execSync(`ls -la`, { stdio: \"inherit\" });\n\n    execSync(`git config --global safe.directory ${process.cwd()}`);\n\n    execSync(`git config user.name \"${gitConfig.userName}\"`);\n    execSync(`git config user.email \"${gitConfig.userEmail}\"`);\n\n    // perform platform-specific configuration before fetching or pushing to the remote\n    this.platformKit?.gitConfig();\n\n    execSync(`git fetch origin ${baseBranchName}`, { stdio: \"inherit\" });\n    execSync(`git checkout ${baseBranchName} --`, { stdio: \"inherit\" });\n\n    if (!processOwnCommits) {\n      const currentAuthor = `${gitConfig.userName} <${gitConfig.userEmail}>`;\n      const authorOfLastCommit = execSync(\n        `git log -1 --pretty=format:'%an <%ae>'`,\n      ).toString();\n      if (authorOfLastCommit === currentAuthor) {\n        this.ora.warn(\n          `The last commit was already made by ${currentAuthor}, so this run will be skipped, as running again would have no effect. See docs: https://lingo.dev/ci`,\n        );\n        return false;\n      }\n    }\n\n    const workingDir = path.resolve(\n      process.cwd(),\n      this.platformKit.config.workingDir,\n    );\n    if (workingDir !== process.cwd()) {\n      this.ora.info(\n        `Changing to working directory: ${this.platformKit.config.workingDir}`,\n      );\n      process.chdir(workingDir);\n    }\n\n    return true;\n  }\n}\n","import { Ora } from \"ora\";\nimport { PlatformKit } from \"../platforms/_base\";\n\nexport type IIntegrationFlowOptions = {\n  parallel?: boolean;\n  force?: boolean;\n};\n\nexport interface IIntegrationFlow {\n  preRun?(): Promise<boolean>;\n  run(options: IIntegrationFlowOptions): Promise<boolean>;\n  postRun?(): Promise<void>;\n}\n\nexport abstract class IntegrationFlow implements IIntegrationFlow {\n  protected i18nBranchName?: string;\n\n  constructor(\n    protected ora: Ora,\n    protected platformKit: PlatformKit,\n  ) {}\n\n  abstract run(options: IIntegrationFlowOptions): Promise<boolean>;\n}\n\nexport function getGitConfig(platformKit: PlatformKit) {\n  return {\n    userName: platformKit.config.commitAuthorName,\n    userEmail: platformKit.config.commitAuthorEmail,\n  };\n}\n\nexport function escapeShellArg(arg: string): string {\n  return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n}\n","import { Command } from \"interactive-commander\";\nimport { exec } from \"child_process\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport os from \"os\";\nimport setup from \"./setup\";\nimport plan from \"./plan\";\nimport execute from \"./execute\";\nimport watch from \"./watch\";\nimport { CmdRunContext, flagsSchema } from \"./_types\";\nimport frozen from \"./frozen\";\nimport {\n  renderClear,\n  renderSpacer,\n  renderBanner,\n  renderHero,\n  pauseIfDebug,\n  renderSummary,\n} from \"../../utils/ui\";\nimport trackEvent from \"../../utils/observability\";\nimport { determineAuthId } from \"./_utils\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nfunction playSound(type: \"success\" | \"failure\") {\n  const platform = os.platform();\n\n  return new Promise<void>((resolve) => {\n    const assetDir = path.join(__dirname, \"../assets\");\n    const soundFiles = [path.join(assetDir, `${type}.mp3`)];\n\n    let command = \"\";\n\n    if (platform === \"linux\") {\n      command = soundFiles\n        .map(\n          (file) =>\n            `mpg123 -q \"${file}\" 2>/dev/null || aplay \"${file}\" 2>/dev/null`,\n        )\n        .join(\" || \");\n    } else if (platform === \"darwin\") {\n      command = soundFiles.map((file) => `afplay \"${file}\"`).join(\" || \");\n    } else if (platform === \"win32\") {\n      command = `powershell -c \"try { (New-Object Media.SoundPlayer '${soundFiles[1]}').PlaySync() } catch { Start-Process -FilePath '${soundFiles[0]}' -WindowStyle Hidden -Wait }\"`;\n    } else {\n      command = soundFiles\n        .map(\n          (file) =>\n            `aplay \"${file}\" 2>/dev/null || afplay \"${file}\" 2>/dev/null`,\n        )\n        .join(\" || \");\n    }\n\n    exec(command, () => {\n      resolve();\n    });\n    setTimeout(resolve, 3000);\n  });\n}\n\nexport default new Command()\n  .command(\"run\")\n  .description(\"Run localization pipeline\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--source-locale <source-locale>\",\n    \"Override the source locale from i18n.json for this run\",\n  )\n  .option(\n    \"--target-locale <target-locale>\",\n    \"Limit processing to the listed target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--bucket <bucket>\",\n    \"Limit processing to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all configured buckets\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--file <file>\",\n    \"Filter bucket path pattern values by substring match. Examples: messages.json or locale/. Repeat to add multiple filters\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--key <key>\",\n    \"Filter keys by prefix matching on dot-separated paths. Example: auth.login to match all keys starting with auth.login. Repeat for multiple patterns\",\n    (val: string, prev: string[]) =>\n      prev ? [...prev, encodeURIComponent(val)] : [encodeURIComponent(val)],\n  )\n  .option(\n    \"--force\",\n    \"Force re-translation of all keys, bypassing change detection. Useful when you want to regenerate translations with updated AI models or translation settings\",\n  )\n  .option(\n    \"--frozen\",\n    \"Validate translations are up-to-date without making changes - fails if source files, target files, or lockfile are out of sync. Ideal for CI/CD to ensure translation consistency before deployment\",\n  )\n  .option(\n    \"--api-key <api-key>\",\n    \"Override API key from settings or environment variables\",\n  )\n  .option(\"--debug\", \"Pause before processing to allow attaching a debugger.\")\n  .option(\n    \"--concurrency <concurrency>\",\n    \"Number of translation jobs to run concurrently. Higher values can speed up large translation batches but may increase memory usage. Defaults to 10 (maximum 10)\",\n    (val: string) => parseInt(val),\n  )\n  .option(\n    \"--watch\",\n    \"Watch source locale files continuously and retranslate automatically when files change\",\n  )\n  .option(\n    \"--debounce <milliseconds>\",\n    \"Delay in milliseconds after file changes before retranslating in watch mode. Defaults to 5000\",\n    (val: string) => parseInt(val),\n  )\n  .option(\n    \"--sound\",\n    \"Play audio feedback when translations complete (success or failure sounds)\",\n  )\n  .action(async (args) => {\n    let authId: string | null = null;\n    try {\n      const ctx: CmdRunContext = {\n        flags: flagsSchema.parse(args),\n        config: null,\n        results: new Map(),\n        tasks: [],\n        localizer: null,\n      };\n\n      await pauseIfDebug(ctx.flags.debug);\n      await renderClear();\n      await renderSpacer();\n      await renderBanner();\n      await renderHero();\n      await renderSpacer();\n\n      await setup(ctx);\n\n      authId = await determineAuthId(ctx);\n\n      await trackEvent(authId, \"cmd.run.start\", {\n        config: ctx.config,\n        flags: ctx.flags,\n      });\n\n      await renderSpacer();\n\n      await plan(ctx);\n      await renderSpacer();\n\n      await frozen(ctx);\n      await renderSpacer();\n\n      await execute(ctx);\n      await renderSpacer();\n\n      await renderSummary(ctx.results);\n      await renderSpacer();\n\n      // Play sound after main tasks complete if sound flag is enabled\n      if (ctx.flags.sound) {\n        await playSound(\"success\");\n      }\n\n      // If watch mode is enabled, start watching for changes\n      if (ctx.flags.watch) {\n        await watch(ctx);\n      }\n\n      await trackEvent(authId, \"cmd.run.success\", {\n        config: ctx.config,\n        flags: ctx.flags,\n      });\n    } catch (error: any) {\n      await trackEvent(authId || \"unknown\", \"cmd.run.error\", {});\n      // Play sad sound if sound flag is enabled\n      if (args.sound) {\n        await playSound(\"failure\");\n      }\n      throw error;\n    }\n  });\n","import chalk from \"chalk\";\nimport { Listr } from \"listr2\";\nimport { colors } from \"../../constants\";\nimport { CmdRunContext, flagsSchema } from \"./_types\";\nimport { commonTaskRendererOptions } from \"./_const\";\nimport { getConfig } from \"../../utils/config\";\nimport createLocalizer from \"../../localizer\";\n\nexport default async function setup(input: CmdRunContext) {\n  console.log(chalk.hex(colors.orange)(\"[Setup]\"));\n\n  return new Listr<CmdRunContext>(\n    [\n      {\n        title: \"Setting up the environment\",\n        task: async (ctx, task) => {\n          // setup gitignore, etc here\n          task.title = `Environment setup completed`;\n        },\n      },\n      {\n        title: \"Loading i18n configuration\",\n        task: async (ctx, task) => {\n          ctx.config = getConfig(true);\n\n          if (!ctx.config) {\n            throw new Error(\n              \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n            );\n          } else if (\n            !ctx.config.buckets ||\n            !Object.keys(ctx.config.buckets).length\n          ) {\n            throw new Error(\n              \"No buckets found in i18n.json. Please add at least one bucket containing i18n content.\",\n            );\n          } else if (\n            ctx.flags.bucket?.some(\n              (bucket) =>\n                !ctx.config?.buckets[bucket as keyof typeof ctx.config.buckets],\n            )\n          ) {\n            throw new Error(\n              `One or more specified buckets do not exist in i18n.json. Please add them to the list first and try again.`,\n            );\n          }\n          task.title = `Loaded i18n configuration`;\n        },\n      },\n      {\n        title: \"Selecting localization provider\",\n        task: async (ctx, task) => {\n          ctx.localizer = createLocalizer(\n            ctx.config?.provider,\n            ctx.flags.apiKey,\n          );\n          if (!ctx.localizer) {\n            throw new Error(\n              \"Could not create localization provider. Please check your i18n.json configuration.\",\n            );\n          }\n          task.title =\n            ctx.localizer.id === \"Lingo.dev\"\n              ? `Using ${chalk.hex(colors.green)(ctx.localizer.id)} provider`\n              : `Using raw ${chalk.hex(colors.yellow)(ctx.localizer.id)} API`;\n        },\n      },\n      {\n        title: \"Checking authentication\",\n        enabled: (ctx) => ctx.localizer?.id === \"Lingo.dev\",\n        task: async (ctx, task) => {\n          const authStatus = await ctx.localizer!.checkAuth();\n          if (!authStatus.authenticated) {\n            throw new Error(authStatus.error || \"Authentication failed\");\n          }\n          task.title = `Authenticated as ${chalk.hex(colors.yellow)(\n            authStatus.username,\n          )}`;\n        },\n      },\n      {\n        title: \"Validating configuration\",\n        enabled: (ctx) => ctx.localizer?.id !== \"Lingo.dev\",\n        task: async (ctx, task) => {\n          const validationStatus = await ctx.localizer!.validateSettings!();\n          if (!validationStatus.valid) {\n            throw new Error(\n              validationStatus.error || \"Configuration validation failed\",\n            );\n          }\n          task.title = `Configuration validated`;\n        },\n      },\n      {\n        title: \"Initializing localization provider\",\n        async task(ctx, task) {\n          const isLingoDotDev = ctx.localizer!.id === \"Lingo.dev\";\n\n          const subTasks = isLingoDotDev\n            ? [\n                \"Brand voice enabled\",\n                \"Translation memory connected\",\n                \"Glossary enabled\",\n                \"Quality assurance enabled\",\n              ].map((title) => ({ title, task: () => {} }))\n            : [\n                \"Skipping brand voice\",\n                \"Skipping glossary\",\n                \"Skipping translation memory\",\n                \"Skipping quality assurance\",\n              ].map((title) => ({ title, task: () => {}, skip: true }));\n\n          return task.newListr(subTasks, {\n            concurrent: true,\n            rendererOptions: { collapseSubtasks: false },\n          });\n        },\n      },\n    ],\n    {\n      rendererOptions: commonTaskRendererOptions,\n    },\n  ).run(input);\n}\n","import chalk from \"chalk\";\nimport { ListrDefaultRendererLogLevels } from \"listr2\";\nimport { colors } from \"../../constants\";\n\nexport const commonTaskRendererOptions = {\n  color: {\n    [ListrDefaultRendererLogLevels.COMPLETED]: (msg?: string) =>\n      msg ? chalk.hex(colors.green)(msg) : chalk.hex(colors.green)(\"\"),\n  },\n  icon: {\n    [ListrDefaultRendererLogLevels.COMPLETED]: chalk.hex(colors.green)(\"‚úì\"),\n  },\n};\n","import dedent from \"dedent\";\nimport { ILocalizer, LocalizerData } from \"./_types\";\nimport chalk from \"chalk\";\nimport { colors } from \"../constants\";\nimport { LingoDotDevEngine } from \"@lingo.dev/_sdk\";\nimport { getSettings } from \"../utils/settings\";\n\nexport default function createLingoDotDevLocalizer(\n  explicitApiKey?: string,\n): ILocalizer {\n  const { auth } = getSettings(explicitApiKey);\n\n  if (!auth) {\n    throw new Error(\n      dedent`\n        You're trying to use ${chalk.hex(colors.green)(\n          \"Lingo.dev\",\n        )} provider, however, you are not authenticated.\n\n        To fix this issue:\n        1. Run ${chalk.dim(\"lingo.dev login\")} to authenticate, or\n        2. Use the ${chalk.dim(\"--api-key\")} flag to provide an API key.\n        3. Set ${chalk.dim(\"LINGODOTDEV_API_KEY\")} environment variable.\n      `,\n    );\n  }\n\n  const engine = new LingoDotDevEngine({\n    apiKey: auth.apiKey,\n    apiUrl: auth.apiUrl,\n  });\n\n  return {\n    id: \"Lingo.dev\",\n    checkAuth: async () => {\n      try {\n        const response = await engine.whoami();\n        return {\n          authenticated: !!response,\n          username: response?.email,\n        };\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : String(error);\n        return { authenticated: false, error: errorMessage };\n      }\n    },\n    localize: async (input: LocalizerData, onProgress) => {\n      // Nothing to translate ‚Äì return the input as-is.\n      if (!Object.keys(input.processableData).length) {\n        return input;\n      }\n\n      const processedData = await engine.localizeObject(\n        input.processableData,\n        {\n          sourceLocale: input.sourceLocale,\n          targetLocale: input.targetLocale,\n          reference: {\n            [input.sourceLocale]: input.sourceData,\n            [input.targetLocale]: input.targetData,\n          },\n          hints: input.hints,\n        },\n        onProgress,\n      );\n\n      return processedData;\n    },\n  };\n}\n","import { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { createMistral } from \"@ai-sdk/mistral\";\nimport { I18nConfig } from \"@lingo.dev/_spec\";\nimport chalk from \"chalk\";\nimport dedent from \"dedent\";\nimport { ILocalizer, LocalizerData } from \"./_types\";\nimport { LanguageModel, Message, generateText } from \"ai\";\nimport { colors } from \"../constants\";\nimport { jsonrepair } from \"jsonrepair\";\nimport { createOllama } from \"ollama-ai-provider\";\n\nexport default function createExplicitLocalizer(\n  provider: NonNullable<I18nConfig[\"provider\"]>,\n): ILocalizer {\n  const settings = provider.settings || {};\n\n  switch (provider.id) {\n    default:\n      throw new Error(\n        dedent`\n          You're trying to use unsupported provider: ${chalk.dim(provider.id)}.\n\n          To fix this issue:\n          1. Switch to one of the supported providers, or\n          2. Remove the ${chalk.italic(\n            \"provider\",\n          )} node from your i18n.json configuration to switch to ${chalk.hex(\n            colors.green,\n          )(\"Lingo.dev\")}\n\n          ${chalk.hex(colors.blue)(\"Docs: https://lingo.dev/go/docs\")}\n        `,\n      );\n    case \"openai\":\n      return createAiSdkLocalizer({\n        factory: (params) => createOpenAI(params).languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        apiKeyName: \"OPENAI_API_KEY\",\n        baseUrl: provider.baseUrl,\n        settings,\n      });\n    case \"anthropic\":\n      return createAiSdkLocalizer({\n        factory: (params) =>\n          createAnthropic(params).languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        apiKeyName: \"ANTHROPIC_API_KEY\",\n        baseUrl: provider.baseUrl,\n        settings,\n      });\n    case \"google\":\n      return createAiSdkLocalizer({\n        factory: (params) =>\n          createGoogleGenerativeAI(params).languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        apiKeyName: \"GOOGLE_API_KEY\",\n        baseUrl: provider.baseUrl,\n        settings,\n      });\n    case \"openrouter\":\n      return createAiSdkLocalizer({\n        factory: (params) =>\n          createOpenRouter(params).languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        apiKeyName: \"OPENROUTER_API_KEY\",\n        baseUrl: provider.baseUrl,\n        settings,\n      });\n    case \"ollama\":\n      return createAiSdkLocalizer({\n        factory: (_params) => createOllama().languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        skipAuth: true,\n        settings,\n      });\n    case \"mistral\":\n      return createAiSdkLocalizer({\n        factory: (params) =>\n          createMistral(params).languageModel(provider.model),\n        id: provider.id,\n        prompt: provider.prompt,\n        apiKeyName: \"MISTRAL_API_KEY\",\n        baseUrl: provider.baseUrl,\n        settings,\n      });\n  }\n}\n\nfunction createAiSdkLocalizer(params: {\n  factory: (params: { apiKey?: string; baseUrl?: string }) => LanguageModel;\n  id: NonNullable<I18nConfig[\"provider\"]>[\"id\"];\n  prompt: string;\n  apiKeyName?: string;\n  baseUrl?: string;\n  skipAuth?: boolean;\n  settings?: { temperature?: number };\n}): ILocalizer {\n  const skipAuth = params.skipAuth === true;\n\n  const apiKey = process.env[params?.apiKeyName ?? \"\"];\n  if ((!skipAuth && !apiKey) || !params.apiKeyName) {\n    throw new Error(\n      dedent`\n        You're trying to use raw ${chalk.dim(params.id)} API for translation. ${\n          params.apiKeyName\n            ? `However, ${chalk.dim(\n                params.apiKeyName,\n              )} environment variable is not set.`\n            : \"However, that provider is unavailable.\"\n        }\n\n        To fix this issue:\n        1. ${\n          params.apiKeyName\n            ? `Set ${chalk.dim(\n                params.apiKeyName,\n              )} in your environment variables`\n            : \"Set the environment variable for your provider (if required)\"\n        }, or\n        2. Remove the ${chalk.italic(\n          \"provider\",\n        )} node from your i18n.json configuration to switch to ${chalk.hex(\n          colors.green,\n        )(\"Lingo.dev\")}\n\n        ${chalk.hex(colors.blue)(\"Docs: https://lingo.dev/go/docs\")}\n      `,\n    );\n  }\n\n  const model = params.factory(\n    skipAuth ? {} : { apiKey, baseUrl: params.baseUrl },\n  );\n\n  return {\n    id: params.id,\n    checkAuth: async () => {\n      // For BYOK providers, auth check is not meaningful\n      // Configuration validation happens in validateSettings\n      return { authenticated: true, username: \"anonymous\" };\n    },\n    validateSettings: async () => {\n      try {\n        await generateText({\n          model,\n          ...params.settings,\n          messages: [\n            { role: \"system\", content: \"You are an echo server\" },\n            { role: \"user\", content: \"OK\" },\n            { role: \"assistant\", content: \"OK\" },\n            { role: \"user\", content: \"OK\" },\n          ],\n        });\n\n        return { valid: true };\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : String(error);\n        return { valid: false, error: errorMessage };\n      }\n    },\n    localize: async (input: LocalizerData) => {\n      const systemPrompt = params.prompt\n        .replaceAll(\"{source}\", input.sourceLocale)\n        .replaceAll(\"{target}\", input.targetLocale);\n      const shots = [\n        [\n          {\n            sourceLocale: \"en\",\n            targetLocale: \"es\",\n            data: {\n              message: \"Hello, world!\",\n            },\n          },\n          {\n            sourceLocale: \"en\",\n            targetLocale: \"es\",\n            data: {\n              message: \"Hola, mundo!\",\n            },\n          },\n        ],\n      ];\n\n      const payload = {\n        sourceLocale: input.sourceLocale,\n        targetLocale: input.targetLocale,\n        data: input.processableData,\n      };\n\n      const response = await generateText({\n        model,\n        ...params.settings,\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: \"OK\" },\n          ...shots.flatMap(\n            ([userShot, assistantShot]) =>\n              [\n                { role: \"user\", content: JSON.stringify(userShot) },\n                { role: \"assistant\", content: JSON.stringify(assistantShot) },\n              ] as Message[],\n          ),\n          { role: \"user\", content: JSON.stringify(payload) },\n        ],\n      });\n\n      const result = JSON.parse(response.text);\n\n      // Handle both object and string responses\n      if (typeof result.data === \"object\" && result.data !== null) {\n        return result.data;\n      }\n\n      // Handle string responses - extract and repair JSON\n      const index = result.data.indexOf(\"{\");\n      const lastIndex = result.data.lastIndexOf(\"}\");\n      const trimmed = result.data.slice(index, lastIndex + 1);\n      const repaired = jsonrepair(trimmed);\n      const finalResult = JSON.parse(repaired);\n\n      return finalResult.data;\n    },\n  };\n}\n","import { I18nConfig } from \"@lingo.dev/_spec\";\n\nimport createLingoDotDevLocalizer from \"./lingodotdev\";\nimport createExplicitLocalizer from \"./explicit\";\nimport { ILocalizer } from \"./_types\";\n\nexport default function createLocalizer(\n  provider: I18nConfig[\"provider\"],\n  apiKey?: string,\n): ILocalizer {\n  if (!provider) {\n    return createLingoDotDevLocalizer(apiKey);\n  } else {\n    return createExplicitLocalizer(provider);\n  }\n}\n","import chalk from \"chalk\";\nimport { Listr } from \"listr2\";\nimport { minimatch } from \"minimatch\";\n\nimport { colors } from \"../../constants\";\nimport { resolveOverriddenLocale } from \"@lingo.dev/_spec\";\nimport { getBuckets } from \"../../utils/buckets\";\nimport { commonTaskRendererOptions } from \"./_const\";\nimport { CmdRunContext } from \"./_types\";\n\nexport default async function plan(\n  input: CmdRunContext,\n): Promise<CmdRunContext> {\n  console.log(chalk.hex(colors.orange)(\"[Planning]\"));\n\n  let buckets = getBuckets(input.config!);\n  if (input.flags.bucket) {\n    buckets = buckets.filter((b) => input.flags.bucket!.includes(b.type));\n  }\n\n  const _sourceLocale = input.flags.sourceLocale || input.config!.locale.source;\n  if (!_sourceLocale) {\n    throw new Error(\n      `No source locale provided. Use --source-locale to specify the source locale or add it to i18n.json (locale.source)`,\n    );\n  }\n  const _targetLocales =\n    input.flags.targetLocale || input.config!.locale.targets;\n  if (!_targetLocales.length) {\n    throw new Error(\n      `No target locales provided. Use --target-locale to specify the target locales or add them to i18n.json (locale.targets)`,\n    );\n  }\n\n  return new Listr<CmdRunContext>(\n    [\n      {\n        title: \"Locating content buckets\",\n        task: async (ctx, task) => {\n          const bucketCount = buckets.length;\n          const bucketFilter = input.flags.bucket\n            ? ` ${chalk.dim(\n                `(filtered by: ${chalk.hex(colors.yellow)(\n                  input.flags.bucket!.join(\", \"),\n                )})`,\n              )}`\n            : \"\";\n          task.title = `Found ${chalk.hex(colors.yellow)(\n            bucketCount.toString(),\n          )} bucket(s)${bucketFilter}`;\n        },\n      },\n      {\n        title: \"Detecting locales\",\n        task: async (ctx, task) => {\n          task.title = `Found ${chalk.hex(colors.yellow)(\n            _targetLocales.length.toString(),\n          )} target locale(s)`;\n        },\n      },\n      {\n        title: \"Locating localizable files\",\n        task: async (ctx, task) => {\n          const patterns: string[] = [];\n\n          for (const bucket of buckets) {\n            for (const bucketPath of bucket.paths) {\n              if (input.flags.file) {\n                if (\n                  !input.flags.file.some(\n                    (f) =>\n                      bucketPath.pathPattern.includes(f) ||\n                      minimatch(bucketPath.pathPattern, f),\n                  )\n                ) {\n                  continue;\n                }\n              }\n\n              patterns.push(bucketPath.pathPattern);\n            }\n          }\n\n          const fileFilter = input.flags.file\n            ? ` ${chalk.dim(\n                `(filtered by: ${chalk.hex(colors.yellow)(\n                  input.flags.file.join(\", \"),\n                )})`,\n              )}`\n            : \"\";\n          task.title = `Found ${chalk.hex(colors.yellow)(\n            patterns.length.toString(),\n          )} path pattern(s)${fileFilter}`;\n        },\n      },\n      {\n        title: \"Computing translation tasks\",\n        task: async (ctx, task) => {\n          for (const bucket of buckets) {\n            for (const bucketPath of bucket.paths) {\n              if (input.flags.file) {\n                if (\n                  !input.flags.file.some(\n                    (f) =>\n                      bucketPath.pathPattern.includes(f) ||\n                      minimatch(bucketPath.pathPattern, f),\n                  )\n                ) {\n                  continue;\n                }\n              }\n\n              const sourceLocale = resolveOverriddenLocale(\n                _sourceLocale,\n                bucketPath.delimiter,\n              );\n\n              for (const _targetLocale of _targetLocales) {\n                const targetLocale = resolveOverriddenLocale(\n                  _targetLocale,\n                  bucketPath.delimiter,\n                );\n\n                // Skip if source and target are identical (shouldn't happen but guard)\n                if (sourceLocale === targetLocale) continue;\n\n                ctx.tasks.push({\n                  sourceLocale,\n                  targetLocale,\n                  bucketType: bucket.type,\n                  bucketPathPattern: bucketPath.pathPattern,\n                  injectLocale: bucket.injectLocale || [],\n                  lockedKeys: bucket.lockedKeys || [],\n                  lockedPatterns: bucket.lockedPatterns || [],\n                  ignoredKeys: bucket.ignoredKeys || [],\n                  onlyKeys: input.flags.key || [],\n                  formatter: input.config!.formatter,\n                });\n              }\n            }\n          }\n\n          task.title = `Prepared ${chalk.hex(colors.green)(\n            ctx.tasks.length.toString(),\n          )} translation task(s)`;\n        },\n      },\n    ],\n    {\n      rendererOptions: commonTaskRendererOptions,\n    },\n  ).run(input);\n}\n","import chalk from \"chalk\";\nimport { Listr, ListrTask } from \"listr2\";\nimport pLimit, { LimitFunction } from \"p-limit\";\nimport _ from \"lodash\";\nimport { minimatch } from \"minimatch\";\n\nimport { colors } from \"../../constants\";\nimport { CmdRunContext, CmdRunTask, CmdRunTaskResult } from \"./_types\";\nimport { commonTaskRendererOptions } from \"./_const\";\nimport createBucketLoader from \"../../loaders\";\nimport { createDeltaProcessor, Delta } from \"../../utils/delta\";\n\nconst MAX_WORKER_COUNT = 10;\n\nexport default async function execute(input: CmdRunContext) {\n  const effectiveConcurrency = Math.min(\n    input.flags.concurrency,\n    input.tasks.length,\n    MAX_WORKER_COUNT,\n  );\n  console.log(chalk.hex(colors.orange)(`[Localization]`));\n\n  return new Listr<CmdRunContext>(\n    [\n      {\n        title: \"Initializing localization engine\",\n        task: async (ctx, task) => {\n          task.title = `Localization engine ${chalk.hex(colors.green)(\n            \"ready\",\n          )} (${ctx.localizer!.id})`;\n        },\n      },\n      {\n        title: `Processing localization tasks ${chalk.dim(\n          `(tasks: ${input.tasks.length}, concurrency: ${effectiveConcurrency})`,\n        )}`,\n        task: async (ctx, task) => {\n          if (input.tasks.length < 1) {\n            task.title = `Skipping, nothing to localize.`;\n            task.skip();\n            return;\n          }\n\n          // Preload checksums for all unique bucket path patterns before starting any workers\n          const initialChecksumsMap = new Map<string, Record<string, string>>();\n          const uniqueBucketPatterns = _.uniq(\n            ctx.tasks.map((t) => t.bucketPathPattern),\n          );\n          for (const bucketPathPattern of uniqueBucketPatterns) {\n            const deltaProcessor = createDeltaProcessor(bucketPathPattern);\n            const checksums = await deltaProcessor.loadChecksums();\n            initialChecksumsMap.set(bucketPathPattern, checksums);\n          }\n\n          const i18nLimiter = pLimit(effectiveConcurrency);\n          const ioLimiter = pLimit(1);\n\n          const perFileIoLimiters = new Map<string, LimitFunction>();\n          const getFileIoLimiter = (\n            bucketPathPattern: string,\n          ): LimitFunction => {\n            const lockKey = bucketPathPattern;\n\n            if (!perFileIoLimiters.has(lockKey)) {\n              perFileIoLimiters.set(lockKey, pLimit(1));\n            }\n            return perFileIoLimiters.get(lockKey)!;\n          };\n\n          const workersCount = effectiveConcurrency;\n\n          const workerTasks: ListrTask[] = [];\n          for (let i = 0; i < workersCount; i++) {\n            const assignedTasks = ctx.tasks.filter(\n              (_, idx) => idx % workersCount === i,\n            );\n            workerTasks.push(\n              createWorkerTask({\n                ctx,\n                assignedTasks,\n                ioLimiter,\n                i18nLimiter,\n                initialChecksumsMap,\n                getFileIoLimiter,\n                onDone() {\n                  task.title = createExecutionProgressMessage(ctx);\n                },\n              }),\n            );\n          }\n\n          return task.newListr(workerTasks, {\n            concurrent: true,\n            exitOnError: false,\n            rendererOptions: {\n              ...commonTaskRendererOptions,\n              collapseSubtasks: true,\n            },\n          });\n        },\n      },\n    ],\n    {\n      exitOnError: false,\n      rendererOptions: commonTaskRendererOptions,\n    },\n  ).run(input);\n}\n\nfunction createWorkerStatusMessage(args: {\n  assignedTask: CmdRunTask;\n  percentage: number;\n}) {\n  const displayPath = args.assignedTask.bucketPathPattern.replace(\n    \"[locale]\",\n    args.assignedTask.targetLocale,\n  );\n  return `[${chalk.hex(colors.yellow)(\n    `${args.percentage}%`,\n  )}] Processing: ${chalk.dim(displayPath)} (${chalk.hex(colors.yellow)(\n    args.assignedTask.sourceLocale,\n  )} -> ${chalk.hex(colors.yellow)(args.assignedTask.targetLocale)})`;\n}\n\nfunction createExecutionProgressMessage(ctx: CmdRunContext) {\n  const succeededTasksCount = countTasks(\n    ctx,\n    (_t, result) => result.status === \"success\",\n  );\n  const failedTasksCount = countTasks(\n    ctx,\n    (_t, result) => result.status === \"error\",\n  );\n  const skippedTasksCount = countTasks(\n    ctx,\n    (_t, result) => result.status === \"skipped\",\n  );\n\n  return `Processed ${chalk.green(succeededTasksCount)}/${\n    ctx.tasks.length\n  }, Failed ${chalk.red(failedTasksCount)}, Skipped ${chalk.dim(\n    skippedTasksCount,\n  )}`;\n}\n\nfunction createLoaderForTask(assignedTask: CmdRunTask) {\n  const bucketLoader = createBucketLoader(\n    assignedTask.bucketType,\n    assignedTask.bucketPathPattern,\n    {\n      defaultLocale: assignedTask.sourceLocale,\n      injectLocale: assignedTask.injectLocale,\n      formatter: assignedTask.formatter,\n    },\n    assignedTask.lockedKeys,\n    assignedTask.lockedPatterns,\n    assignedTask.ignoredKeys,\n  );\n  bucketLoader.setDefaultLocale(assignedTask.sourceLocale);\n\n  return bucketLoader;\n}\n\nfunction createWorkerTask(args: {\n  ctx: CmdRunContext;\n  assignedTasks: CmdRunTask[];\n  ioLimiter: LimitFunction;\n  i18nLimiter: LimitFunction;\n  onDone: () => void;\n  initialChecksumsMap: Map<string, Record<string, string>>;\n  getFileIoLimiter: (bucketPathPattern: string) => LimitFunction;\n}): ListrTask {\n  return {\n    title: \"Initializing...\",\n    task: async (_subCtx: any, subTask: any) => {\n      for (const assignedTask of args.assignedTasks) {\n        subTask.title = createWorkerStatusMessage({\n          assignedTask,\n          percentage: 0,\n        });\n        const bucketLoader = createLoaderForTask(assignedTask);\n        const deltaProcessor = createDeltaProcessor(\n          assignedTask.bucketPathPattern,\n        );\n\n        // Get initial checksums from the preloaded map\n        const initialChecksums =\n          args.initialChecksumsMap.get(assignedTask.bucketPathPattern) || {};\n\n        const taskResult = await args.i18nLimiter(async () => {\n          try {\n            // Pull operations must be serialized per-file for single-file formats\n            // where multiple locales share the same file (e.g., xcode-xcstrings)\n            const fileIoLimiter = args.getFileIoLimiter(\n              assignedTask.bucketPathPattern,\n            );\n            const sourceData = await fileIoLimiter(async () =>\n              bucketLoader.pull(assignedTask.sourceLocale),\n            );\n            const hints = await fileIoLimiter(async () =>\n              bucketLoader.pullHints(),\n            );\n            const targetData = await fileIoLimiter(async () =>\n              bucketLoader.pull(assignedTask.targetLocale),\n            );\n            const delta = await deltaProcessor.calculateDelta({\n              sourceData,\n              targetData,\n              checksums: initialChecksums,\n            });\n\n            const processableData = _.chain(sourceData)\n              .entries()\n              .filter(\n                ([key, value]) =>\n                  delta.added.includes(key) ||\n                  delta.updated.includes(key) ||\n                  !!args.ctx.flags.force,\n              )\n              .filter(\n                ([key]) =>\n                  !assignedTask.onlyKeys.length ||\n                  assignedTask.onlyKeys?.some((pattern) =>\n                    minimatch(key, pattern),\n                  ),\n              )\n              .fromPairs()\n              .value();\n\n            if (!Object.keys(processableData).length) {\n              await fileIoLimiter(async () => {\n                // re-push in case some of the unlocalizable / meta data changed\n                await bucketLoader.push(assignedTask.targetLocale, targetData);\n              });\n              return {\n                status: \"skipped\",\n                pathPattern: assignedTask.bucketPathPattern,\n                sourceLocale: assignedTask.sourceLocale,\n                targetLocale: assignedTask.targetLocale,\n              } satisfies CmdRunTaskResult;\n            }\n\n            const relevantHints = _.pick(hints, Object.keys(processableData));\n            const processedTargetData = await args.ctx.localizer!.localize(\n              {\n                sourceLocale: assignedTask.sourceLocale,\n                targetLocale: assignedTask.targetLocale,\n                sourceData,\n                targetData,\n                processableData,\n                hints: relevantHints,\n              },\n              async (progress, _sourceChunk, processedChunk) => {\n                // write translated chunks as they are received from LLM\n                await fileIoLimiter(async () => {\n                  // pull the latest source data before pushing for buckets that store all locales in a single file\n                  await bucketLoader.pull(assignedTask.sourceLocale);\n                  // pull the latest target data to include all already processed chunks\n                  const latestTargetData = await bucketLoader.pull(\n                    assignedTask.targetLocale,\n                  );\n\n                  // add the new chunk to target data\n                  const _partialData = _.merge(\n                    {},\n                    latestTargetData,\n                    processedChunk,\n                  );\n                  // process renamed keys\n                  const finalChunkTargetData = processRenamedKeys(\n                    delta,\n                    _partialData,\n                  );\n                  // push final chunk to the target locale\n                  await bucketLoader.push(\n                    assignedTask.targetLocale,\n                    finalChunkTargetData,\n                  );\n                });\n\n                subTask.title = createWorkerStatusMessage({\n                  assignedTask,\n                  percentage: progress,\n                });\n              },\n            );\n\n            const finalTargetData = _.merge(\n              {},\n              sourceData,\n              targetData,\n              processedTargetData,\n            );\n            const finalRenamedTargetData = processRenamedKeys(\n              delta,\n              finalTargetData,\n            );\n\n            await fileIoLimiter(async () => {\n              // not all localizers have progress callback (eg. explicit localizer),\n              // the final target data might not be pushed yet - push now to ensure it's up to date\n              await bucketLoader.pull(assignedTask.sourceLocale);\n              await bucketLoader.push(\n                assignedTask.targetLocale,\n                finalRenamedTargetData,\n              );\n\n              const checksums =\n                await deltaProcessor.createChecksums(sourceData);\n              if (!args.ctx.flags.targetLocale?.length) {\n                await deltaProcessor.saveChecksums(checksums);\n              }\n            });\n\n            return {\n              status: \"success\",\n              pathPattern: assignedTask.bucketPathPattern,\n              sourceLocale: assignedTask.sourceLocale,\n              targetLocale: assignedTask.targetLocale,\n            } satisfies CmdRunTaskResult;\n          } catch (error) {\n            return {\n              status: \"error\",\n              error: error as Error,\n              pathPattern: assignedTask.bucketPathPattern,\n              sourceLocale: assignedTask.sourceLocale,\n              targetLocale: assignedTask.targetLocale,\n            } satisfies CmdRunTaskResult;\n          }\n        });\n\n        args.ctx.results.set(assignedTask, taskResult);\n      }\n\n      subTask.title = \"Done\";\n    },\n  };\n}\n\nfunction countTasks(\n  ctx: CmdRunContext,\n  predicate: (task: CmdRunTask, result: CmdRunTaskResult) => boolean,\n) {\n  return Array.from(ctx.results.entries()).filter(([task, result]) =>\n    predicate(task, result),\n  ).length;\n}\n\nfunction processRenamedKeys(delta: Delta, targetData: Record<string, string>) {\n  return _.chain(targetData)\n    .entries()\n    .map(([key, value]) => {\n      const renaming = delta.renamed.find(([oldKey]) => oldKey === key);\n      if (!renaming) {\n        return [key, value];\n      }\n      return [renaming[1], value];\n    })\n    .fromPairs()\n    .value();\n}\n","import * as chokidar from \"chokidar\";\nimport chalk from \"chalk\";\nimport { minimatch } from \"minimatch\";\nimport { colors } from \"../../constants\";\nimport { CmdRunContext } from \"./_types\";\nimport plan from \"./plan\";\nimport execute from \"./execute\";\nimport { renderSummary } from \"../../utils/ui\";\nimport { getBuckets } from \"../../utils/buckets\";\n\ninterface WatchState {\n  isRunning: boolean;\n  pendingChanges: Set<string>;\n  debounceTimer?: NodeJS.Timeout;\n}\n\nexport default async function watch(ctx: CmdRunContext) {\n  const debounceDelay = ctx.flags.debounce || 5000; // Use configured debounce or 5s default\n\n  console.log(chalk.hex(colors.orange)(\"[Watch Mode]\"));\n  console.log(\n    `üëÄ Watching for changes... (Press ${chalk.yellow(\"Ctrl+C\")} to stop)`,\n  );\n  console.log(chalk.dim(`   Debounce delay: ${debounceDelay}ms`));\n  console.log(\"\");\n\n  const state: WatchState = {\n    isRunning: false,\n    pendingChanges: new Set(),\n  };\n\n  // Get all source file patterns to watch\n  const watchPatterns = await getWatchPatterns(ctx);\n\n  if (watchPatterns.length === 0) {\n    console.log(chalk.yellow(\"‚ö†Ô∏è  No source files found to watch\"));\n    return;\n  }\n\n  console.log(chalk.dim(`Watching ${watchPatterns.length} file pattern(s):`));\n  watchPatterns.forEach((pattern) => {\n    console.log(chalk.dim(`  ‚Ä¢ ${pattern}`));\n  });\n  console.log(\"\");\n\n  // Initialize file watcher\n  const watcher = chokidar.watch(watchPatterns, {\n    ignoreInitial: true,\n    persistent: true,\n    awaitWriteFinish: {\n      stabilityThreshold: 500,\n      pollInterval: 100,\n    },\n  });\n\n  // Handle file changes\n  watcher.on(\"change\", (path) => {\n    handleFileChange(path, state, ctx);\n  });\n\n  watcher.on(\"add\", (path) => {\n    handleFileChange(path, state, ctx);\n  });\n\n  watcher.on(\"unlink\", (path) => {\n    handleFileChange(path, state, ctx);\n  });\n\n  watcher.on(\"error\", (error) => {\n    console.error(\n      chalk.red(\n        `Watch error: ${error instanceof Error ? error.message : String(error)}`,\n      ),\n    );\n  });\n\n  // Handle graceful shutdown\n  process.on(\"SIGINT\", () => {\n    console.log(chalk.yellow(\"\\n\\nüõë Stopping watch mode...\"));\n    watcher.close();\n    process.exit(0);\n  });\n\n  // Keep the process running\n  await new Promise(() => {}); // Never resolves, keeps process alive\n}\n\nasync function getWatchPatterns(ctx: CmdRunContext): Promise<string[]> {\n  if (!ctx.config) return [];\n\n  const buckets = getBuckets(ctx.config);\n  const patterns: string[] = [];\n\n  for (const bucket of buckets) {\n    // Skip if specific buckets are filtered\n    if (ctx.flags.bucket && !ctx.flags.bucket.includes(bucket.type)) {\n      continue;\n    }\n\n    for (const bucketPath of bucket.paths) {\n      // Skip if specific files are filtered\n      if (ctx.flags.file) {\n        if (\n          !ctx.flags.file.some(\n            (f) =>\n              bucketPath.pathPattern.includes(f) ||\n              minimatch(bucketPath.pathPattern, f),\n          )\n        ) {\n          continue;\n        }\n      }\n\n      // Get the source locale pattern (replace [locale] with source locale)\n      const sourceLocale = ctx.flags.sourceLocale || ctx.config.locale.source;\n      const sourcePattern = bucketPath.pathPattern.replace(\n        \"[locale]\",\n        sourceLocale,\n      );\n\n      patterns.push(sourcePattern);\n    }\n  }\n\n  return patterns;\n}\n\nfunction handleFileChange(\n  filePath: string,\n  state: WatchState,\n  ctx: CmdRunContext,\n) {\n  const debounceDelay = ctx.flags.debounce || 5000; // Use configured debounce or 5s default\n\n  state.pendingChanges.add(filePath);\n\n  console.log(chalk.dim(`üìù File changed: ${filePath}`));\n\n  // Clear existing debounce timer\n  if (state.debounceTimer) {\n    clearTimeout(state.debounceTimer);\n  }\n\n  // Set new debounce timer\n  state.debounceTimer = setTimeout(async () => {\n    if (state.isRunning) {\n      console.log(\n        chalk.yellow(\"‚è≥ Translation already in progress, skipping...\"),\n      );\n      return;\n    }\n\n    await triggerRetranslation(state, ctx);\n  }, debounceDelay);\n}\n\nasync function triggerRetranslation(state: WatchState, ctx: CmdRunContext) {\n  if (state.isRunning) return;\n\n  state.isRunning = true;\n\n  try {\n    const changedFiles = Array.from(state.pendingChanges);\n    state.pendingChanges.clear();\n\n    console.log(chalk.hex(colors.green)(\"\\nüîÑ Triggering retranslation...\"));\n    console.log(chalk.dim(`Changed files: ${changedFiles.join(\", \")}`));\n    console.log(\"\");\n\n    // Create a new context for this run (preserve original flags but reset tasks/results)\n    const runCtx: CmdRunContext = {\n      ...ctx,\n      tasks: [],\n      results: new Map(),\n    };\n\n    // Re-run the translation pipeline\n    await plan(runCtx);\n\n    if (runCtx.tasks.length === 0) {\n      console.log(chalk.dim(\"‚ú® No translation tasks needed\"));\n    } else {\n      await execute(runCtx);\n      await renderSummary(runCtx.results);\n    }\n\n    console.log(chalk.hex(colors.green)(\"‚úÖ Retranslation completed\"));\n    console.log(chalk.dim(\"üëÄ Continuing to watch for changes...\\n\"));\n  } catch (error: any) {\n    console.error(chalk.red(`‚ùå Retranslation failed: ${error.message}`));\n    console.log(chalk.dim(\"üëÄ Continuing to watch for changes...\\n\"));\n  } finally {\n    state.isRunning = false;\n  }\n}\n","import {\n  bucketTypeSchema,\n  I18nConfig,\n  localeCodeSchema,\n  bucketTypes,\n} from \"@lingo.dev/_spec\";\nimport { z } from \"zod\";\nimport { ILocalizer } from \"../../localizer/_types\";\n\nexport type CmdRunContext = {\n  flags: CmdRunFlags;\n  config: I18nConfig | null;\n  localizer: ILocalizer | null;\n  tasks: CmdRunTask[];\n  results: Map<CmdRunTask, CmdRunTaskResult>;\n};\n\nexport type CmdRunTaskResult = {\n  status: \"success\" | \"error\" | \"skipped\";\n  error?: Error;\n  pathPattern?: string;\n  sourceLocale?: string;\n  targetLocale?: string;\n};\n\nexport type CmdRunTask = {\n  sourceLocale: string;\n  targetLocale: string;\n  bucketType: (typeof bucketTypes)[number];\n  bucketPathPattern: string;\n  injectLocale: string[];\n  lockedKeys: string[];\n  lockedPatterns: string[];\n  ignoredKeys: string[];\n  onlyKeys: string[];\n  formatter?: \"prettier\" | \"biome\";\n};\n\nexport const flagsSchema = z.object({\n  bucket: z.array(bucketTypeSchema).optional(),\n  key: z.array(z.string()).optional(),\n  file: z.array(z.string()).optional(),\n  apiKey: z.string().optional(),\n  force: z.boolean().optional(),\n  frozen: z.boolean().optional(),\n  verbose: z.boolean().optional(),\n  strict: z.boolean().optional(),\n  interactive: z.boolean().default(false),\n  concurrency: z.number().positive().default(10),\n  debug: z.boolean().default(false),\n  sourceLocale: z.string().optional(),\n  targetLocale: z.array(z.string()).optional(),\n  watch: z.boolean().default(false),\n  debounce: z.number().positive().default(5000), // 5 seconds default\n  sound: z.boolean().optional(),\n});\nexport type CmdRunFlags = z.infer<typeof flagsSchema>;\n","import chalk from \"chalk\";\nimport { Listr } from \"listr2\";\nimport _ from \"lodash\";\nimport { minimatch } from \"minimatch\";\n\nimport { colors } from \"../../constants\";\nimport { CmdRunContext } from \"./_types\";\nimport { commonTaskRendererOptions } from \"./_const\";\nimport { getBuckets } from \"../../utils/buckets\";\nimport createBucketLoader from \"../../loaders\";\nimport { createDeltaProcessor } from \"../../utils/delta\";\nimport { resolveOverriddenLocale } from \"@lingo.dev/_spec\";\n\nexport default async function frozen(input: CmdRunContext) {\n  console.log(chalk.hex(colors.orange)(\"[Frozen]\"));\n\n  // Prepare filtered buckets consistently with the planning step\n  let buckets = getBuckets(input.config!);\n  if (input.flags.bucket?.length) {\n    buckets = buckets.filter((b) => input.flags.bucket!.includes(b.type));\n  }\n\n  if (input.flags.file?.length) {\n    buckets = buckets\n      .map((bucket: any) => {\n        const paths = bucket.paths.filter((p: any) =>\n          input.flags.file!.some(\n            (f) => p.pathPattern.includes(f) || minimatch(p.pathPattern, f),\n          ),\n        );\n        return { ...bucket, paths };\n      })\n      .filter((bucket: any) => bucket.paths.length > 0);\n  }\n\n  const _sourceLocale = input.flags.sourceLocale || input.config!.locale.source;\n  const _targetLocales =\n    input.flags.targetLocale || input.config!.locale.targets;\n\n  return new Listr<CmdRunContext>(\n    [\n      {\n        title: \"Setting up localization cache\",\n        task: async (_ctx, task) => {\n          const checkLockfileProcessor = createDeltaProcessor(\"\");\n          const lockfileExists =\n            await checkLockfileProcessor.checkIfLockExists();\n          if (!lockfileExists) {\n            for (const bucket of buckets) {\n              for (const bucketPath of bucket.paths) {\n                const resolvedSourceLocale = resolveOverriddenLocale(\n                  _sourceLocale,\n                  bucketPath.delimiter,\n                );\n\n                const loader = createBucketLoader(\n                  bucket.type,\n                  bucketPath.pathPattern,\n                  {\n                    defaultLocale: resolvedSourceLocale,\n                    injectLocale: bucket.injectLocale,\n                    formatter: input.config!.formatter,\n                  },\n                  bucket.lockedKeys,\n                  bucket.lockedPatterns,\n                  bucket.ignoredKeys,\n                );\n                loader.setDefaultLocale(resolvedSourceLocale);\n                await loader.init();\n\n                const sourceData = await loader.pull(_sourceLocale);\n\n                const delta = createDeltaProcessor(bucketPath.pathPattern);\n                const checksums = await delta.createChecksums(sourceData);\n                await delta.saveChecksums(checksums);\n              }\n            }\n            task.title = \"Localization cache initialized\";\n          } else {\n            task.title = \"Localization cache loaded\";\n          }\n        },\n      },\n      {\n        title: \"Validating frozen state\",\n        enabled: () => !!input.flags.frozen,\n        task: async (_ctx, task) => {\n          for (const bucket of buckets) {\n            for (const bucketPath of bucket.paths) {\n              const resolvedSourceLocale = resolveOverriddenLocale(\n                _sourceLocale,\n                bucketPath.delimiter,\n              );\n\n              const loader = createBucketLoader(\n                bucket.type,\n                bucketPath.pathPattern,\n                {\n                  defaultLocale: resolvedSourceLocale,\n                  returnUnlocalizedKeys: true,\n                  injectLocale: bucket.injectLocale,\n                },\n                bucket.lockedKeys,\n                bucket.lockedPatterns,\n                bucket.ignoredKeys,\n              );\n              loader.setDefaultLocale(resolvedSourceLocale);\n              await loader.init();\n\n              const { unlocalizable: srcUnlocalizable, ...src } =\n                await loader.pull(_sourceLocale);\n\n              const delta = createDeltaProcessor(bucketPath.pathPattern);\n              const sourceChecksums = await delta.createChecksums(src);\n              const savedChecksums = await delta.loadChecksums();\n\n              const updatedSourceData = _.pickBy(\n                src,\n                (value, key) => sourceChecksums[key] !== savedChecksums[key],\n              );\n              if (Object.keys(updatedSourceData).length > 0) {\n                throw new Error(\n                  `Localization data has changed; please update i18n.lock or run without --frozen. Details: Source file has been updated.`,\n                );\n              }\n\n              for (const _tgt of _targetLocales) {\n                const resolvedTargetLocale = resolveOverriddenLocale(\n                  _tgt,\n                  bucketPath.delimiter,\n                );\n                const { unlocalizable: tgtUnlocalizable, ...tgt } =\n                  await loader.pull(resolvedTargetLocale);\n\n                const missingKeys = _.difference(\n                  Object.keys(src),\n                  Object.keys(tgt),\n                );\n                if (missingKeys.length > 0) {\n                  throw new Error(\n                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Target file is missing translations.`,\n                  );\n                }\n\n                const extraKeys = _.difference(\n                  Object.keys(tgt),\n                  Object.keys(src),\n                );\n                if (extraKeys.length > 0) {\n                  throw new Error(\n                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Target file has extra translations not present in the source file.`,\n                  );\n                }\n\n                const unlocalizableDataDiff = !_.isEqual(\n                  srcUnlocalizable,\n                  tgtUnlocalizable,\n                );\n                if (unlocalizableDataDiff) {\n                  throw new Error(\n                    `Localization data has changed; please update i18n.lock or run without --frozen. Details: Unlocalizable data (such as booleans, dates, URLs, etc.) do not match.`,\n                  );\n                }\n              }\n            }\n          }\n\n          task.title = \"No lockfile updates required\";\n        },\n      },\n    ],\n    {\n      rendererOptions: commonTaskRendererOptions,\n    },\n  ).run(input);\n}\n","import { CmdRunContext } from \"./_types\";\n\n/**\n * Determines the authentication ID for tracking purposes\n */\nexport async function determineAuthId(\n  ctx: CmdRunContext,\n): Promise<string | null> {\n  const isByokMode = !!ctx.config?.provider;\n\n  if (isByokMode) {\n    return null;\n  } else {\n    try {\n      const authStatus = await ctx.localizer?.checkAuth();\n      return authStatus?.username || null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import { execSync } from \"child_process\";\nimport bbLib from \"bitbucket\";\nimport Z from \"zod\";\nimport { PlatformKit } from \"./_base\";\n\nconst { Bitbucket } = bbLib;\n\ninterface BitbucketConfig {\n  baseBranchName: string;\n  repositoryOwner: string;\n  repositoryName: string;\n  bbToken?: string;\n}\n\nexport class BitbucketPlatformKit extends PlatformKit<BitbucketConfig> {\n  private _bb?: ReturnType<typeof Bitbucket>;\n\n  private get bb() {\n    if (!this._bb) {\n      this._bb = new Bitbucket({\n        auth: { token: this.platformConfig.bbToken || \"\" },\n      });\n    }\n    return this._bb;\n  }\n\n  async branchExists({ branch }: { branch: string }) {\n    return await this.bb.repositories\n      .getBranch({\n        workspace: this.platformConfig.repositoryOwner,\n        repo_slug: this.platformConfig.repositoryName,\n        name: branch,\n      })\n      .then((r) => r.data)\n      .then((v) => !!v)\n      .catch((r) => (r.status === 404 ? false : Promise.reject(r)));\n  }\n\n  async getOpenPullRequestNumber({ branch }: { branch: string }) {\n    return await this.bb.repositories\n      .listPullRequests({\n        workspace: this.platformConfig.repositoryOwner,\n        repo_slug: this.platformConfig.repositoryName,\n        state: \"OPEN\",\n      })\n      .then(({ data: { values } }) => {\n        // TODO: we might need to handle pagination in future\n        // bitbucket API does not support filtering pull requests\n        // https://developer.atlassian.com/cloud/bitbucket/rest/api-group-pullrequests/#api-repositories-workspace-repo-slug-pullrequests-get\n        return values?.find(\n          ({ source, destination }) =>\n            source?.branch?.name === branch &&\n            destination?.branch?.name === this.platformConfig.baseBranchName,\n        );\n      })\n      .then((pr) => pr?.id);\n  }\n\n  async closePullRequest({ pullRequestNumber }: { pullRequestNumber: number }) {\n    await this.bb.repositories.declinePullRequest({\n      workspace: this.platformConfig.repositoryOwner,\n      repo_slug: this.platformConfig.repositoryName,\n      pull_request_id: pullRequestNumber,\n    });\n  }\n\n  async createPullRequest({\n    title,\n    body,\n    head,\n  }: {\n    title: string;\n    body?: string;\n    head: string;\n  }) {\n    return await this.bb.repositories\n      .createPullRequest({\n        workspace: this.platformConfig.repositoryOwner,\n        repo_slug: this.platformConfig.repositoryName,\n        _body: {\n          title,\n          description: body,\n          source: { branch: { name: head } },\n          destination: { branch: { name: this.platformConfig.baseBranchName } },\n        } as any,\n      })\n      .then(({ data }) => data.id ?? 0);\n  }\n\n  async commentOnPullRequest({\n    pullRequestNumber,\n    body,\n  }: {\n    pullRequestNumber: number;\n    body: string;\n  }) {\n    await this.bb.repositories.createPullRequestComment({\n      workspace: this.platformConfig.repositoryOwner,\n      repo_slug: this.platformConfig.repositoryName,\n      pull_request_id: pullRequestNumber,\n      _body: {\n        content: {\n          raw: body,\n        },\n      } as any,\n    });\n  }\n\n  async gitConfig() {\n    execSync(\"git config --unset http.${BITBUCKET_GIT_HTTP_ORIGIN}.proxy\", {\n      stdio: \"inherit\",\n    });\n    execSync(\n      \"git config http.${BITBUCKET_GIT_HTTP_ORIGIN}.proxy http://host.docker.internal:29418/\",\n      {\n        stdio: \"inherit\",\n      },\n    );\n  }\n\n  get platformConfig() {\n    const env = Z.object({\n      BITBUCKET_BRANCH: Z.string(),\n      BITBUCKET_REPO_FULL_NAME: Z.string(),\n      BB_TOKEN: Z.string().optional(),\n    }).parse(process.env);\n\n    const [repositoryOwner, repositoryName] =\n      env.BITBUCKET_REPO_FULL_NAME.split(\"/\");\n\n    return {\n      baseBranchName: env.BITBUCKET_BRANCH,\n      repositoryOwner,\n      repositoryName,\n      bbToken: env.BB_TOKEN,\n    };\n  }\n\n  buildPullRequestUrl(pullRequestNumber: number) {\n    const { repositoryOwner, repositoryName } = this.platformConfig;\n    return `https://bitbucket.org/${repositoryOwner}/${repositoryName}/pull-requests/${pullRequestNumber}`;\n  }\n}\n","import { execSync } from \"child_process\";\nimport Z from \"zod\";\n\nconst defaultMessage = \"feat: update translations via @lingodotdev\";\n\ninterface BasePlatformConfig {\n  baseBranchName: string;\n  repositoryOwner: string;\n  repositoryName: string;\n}\n\nexport abstract class PlatformKit<\n  PlatformConfig extends BasePlatformConfig = BasePlatformConfig,\n> {\n  abstract branchExists(props: { branch: string }): Promise<boolean>;\n\n  abstract getOpenPullRequestNumber(props: {\n    branch: string;\n  }): Promise<number | undefined>;\n\n  abstract closePullRequest(props: {\n    pullRequestNumber: number;\n  }): Promise<void>;\n\n  abstract createPullRequest(props: {\n    head: string;\n    title: string;\n    body?: string;\n  }): Promise<number>;\n\n  abstract commentOnPullRequest(props: {\n    pullRequestNumber: number;\n    body: string;\n  }): Promise<void>;\n\n  abstract get platformConfig(): PlatformConfig;\n\n  abstract buildPullRequestUrl(pullRequestNumber: number): string;\n\n  gitConfig(token?: string, repoUrl?: string) {\n    if (token && repoUrl) {\n      execSync(`git remote set-url origin ${repoUrl}`, {\n        stdio: \"inherit\",\n      });\n    }\n  }\n\n  get config() {\n    const env = Z.object({\n      LINGODOTDEV_API_KEY: Z.string(),\n      LINGODOTDEV_PULL_REQUEST: Z.preprocess(\n        (val) => val === \"true\" || val === true,\n        Z.boolean(),\n      ),\n      LINGODOTDEV_COMMIT_MESSAGE: Z.string().optional(),\n      LINGODOTDEV_PULL_REQUEST_TITLE: Z.string().optional(),\n      LINGODOTDEV_COMMIT_AUTHOR_NAME: Z.string().optional(),\n      LINGODOTDEV_COMMIT_AUTHOR_EMAIL: Z.string().optional(),\n      LINGODOTDEV_WORKING_DIRECTORY: Z.string().optional(),\n      LINGODOTDEV_PROCESS_OWN_COMMITS: Z.preprocess(\n        (val) => val === \"true\" || val === true,\n        Z.boolean(),\n      ).optional(),\n    }).parse(process.env);\n\n    return {\n      replexicaApiKey: env.LINGODOTDEV_API_KEY,\n      isPullRequestMode: env.LINGODOTDEV_PULL_REQUEST,\n      commitMessage: env.LINGODOTDEV_COMMIT_MESSAGE || defaultMessage,\n      pullRequestTitle: env.LINGODOTDEV_PULL_REQUEST_TITLE || defaultMessage,\n      commitAuthorName: env.LINGODOTDEV_COMMIT_AUTHOR_NAME || \"Lingo.dev\",\n      commitAuthorEmail:\n        env.LINGODOTDEV_COMMIT_AUTHOR_EMAIL || \"support@lingo.dev\",\n      workingDir: env.LINGODOTDEV_WORKING_DIRECTORY || \".\",\n      processOwnCommits: env.LINGODOTDEV_PROCESS_OWN_COMMITS || false,\n    };\n  }\n}\n\nexport interface IConfig {\n  replexicaApiKey: string;\n  isPullRequestMode: boolean;\n  commitMessage: string;\n  pullRequestTitle: string;\n}\n","import { Octokit } from \"octokit\";\nimport { PlatformKit } from \"./_base\";\nimport Z from \"zod\";\n\nexport class GitHubPlatformKit extends PlatformKit {\n  private _octokit?: Octokit;\n\n  private get octokit(): Octokit {\n    if (!this._octokit) {\n      this._octokit = new Octokit({ auth: this.platformConfig.ghToken });\n    }\n    return this._octokit;\n  }\n\n  async branchExists({ branch }: { branch: string }) {\n    return await this.octokit.rest.repos\n      .getBranch({\n        branch,\n        owner: this.platformConfig.repositoryOwner,\n        repo: this.platformConfig.repositoryName,\n      })\n      .then((r) => r.data)\n      .then((v) => !!v)\n      .catch((r) => (r.status === 404 ? false : Promise.reject(r)));\n  }\n\n  async getOpenPullRequestNumber({ branch }: { branch: string }) {\n    return await this.octokit.rest.pulls\n      .list({\n        head: `${this.platformConfig.repositoryOwner}:${branch}`,\n        owner: this.platformConfig.repositoryOwner,\n        repo: this.platformConfig.repositoryName,\n        base: this.platformConfig.baseBranchName,\n        state: \"open\",\n      })\n      .then(({ data }) => data[0])\n      .then((pr) => pr?.number);\n  }\n\n  async closePullRequest({ pullRequestNumber }: { pullRequestNumber: number }) {\n    await this.octokit.rest.pulls.update({\n      pull_number: pullRequestNumber,\n      owner: this.platformConfig.repositoryOwner,\n      repo: this.platformConfig.repositoryName,\n      state: \"closed\",\n    });\n  }\n\n  async createPullRequest({\n    head,\n    title,\n    body,\n  }: {\n    head: string;\n    title: string;\n    body?: string;\n  }) {\n    return await this.octokit.rest.pulls\n      .create({\n        head,\n        title,\n        body,\n        owner: this.platformConfig.repositoryOwner,\n        repo: this.platformConfig.repositoryName,\n        base: this.platformConfig.baseBranchName,\n      })\n      .then(({ data }) => data.number);\n  }\n\n  async commentOnPullRequest({\n    pullRequestNumber,\n    body,\n  }: {\n    pullRequestNumber: number;\n    body: string;\n  }) {\n    await this.octokit.rest.issues.createComment({\n      issue_number: pullRequestNumber,\n      body,\n      owner: this.platformConfig.repositoryOwner,\n      repo: this.platformConfig.repositoryName,\n    });\n  }\n\n  async gitConfig() {\n    const { ghToken, repositoryOwner, repositoryName } = this.platformConfig;\n    const { processOwnCommits } = this.config;\n\n    if (ghToken && processOwnCommits) {\n      console.log(\n        \"Using provided GH_TOKEN. This will trigger your CI/CD pipeline to run again.\",\n      );\n\n      const url = `https://${ghToken}@github.com/${repositoryOwner}/${repositoryName}.git`;\n\n      super.gitConfig(ghToken, url);\n    }\n  }\n\n  get platformConfig() {\n    const env = Z.object({\n      GITHUB_REPOSITORY: Z.string(),\n      GITHUB_REPOSITORY_OWNER: Z.string(),\n      GITHUB_REF_NAME: Z.string(),\n      GITHUB_HEAD_REF: Z.string(),\n      GH_TOKEN: Z.string().optional(),\n    }).parse(process.env);\n\n    const baseBranchName = !env.GITHUB_REF_NAME.endsWith(\"/merge\")\n      ? env.GITHUB_REF_NAME\n      : env.GITHUB_HEAD_REF;\n\n    return {\n      ghToken: env.GH_TOKEN,\n      baseBranchName,\n      repositoryOwner: env.GITHUB_REPOSITORY_OWNER,\n      repositoryName: env.GITHUB_REPOSITORY.split(\"/\")[1],\n    };\n  }\n\n  buildPullRequestUrl(pullRequestNumber: number) {\n    const { repositoryOwner, repositoryName } = this.platformConfig;\n    return `https://github.com/${repositoryOwner}/${repositoryName}/pull/${pullRequestNumber}`;\n  }\n}\n","import { Gitlab } from \"@gitbeaker/rest\";\nimport Z from \"zod\";\nimport { PlatformKit } from \"./_base\";\n\nconst gl = new Gitlab({ token: \"\" });\n\nexport class GitlabPlatformKit extends PlatformKit {\n  private _gitlab?: InstanceType<typeof Gitlab>;\n\n  constructor() {\n    super();\n\n    // change directory to current repository before executing replexica\n    process.chdir(this.platformConfig.projectDir);\n  }\n\n  private get gitlab(): InstanceType<typeof Gitlab> {\n    if (!this._gitlab) {\n      this._gitlab = new Gitlab({\n        token: this.platformConfig.glToken || \"\",\n      });\n    }\n    return this._gitlab;\n  }\n\n  get platformConfig() {\n    const env = Z.object({\n      GL_TOKEN: Z.string().optional(),\n      CI_COMMIT_BRANCH: Z.string(),\n      CI_MERGE_REQUEST_SOURCE_BRANCH_NAME: Z.string().optional(),\n      CI_PROJECT_NAMESPACE: Z.string(),\n      CI_PROJECT_NAME: Z.string(),\n      CI_PROJECT_ID: Z.string(),\n      CI_PROJECT_DIR: Z.string(),\n      CI_REPOSITORY_URL: Z.string(),\n    }).parse(process.env);\n\n    const config = {\n      glToken: env.GL_TOKEN,\n      baseBranchName:\n        env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME ?? env.CI_COMMIT_BRANCH,\n      repositoryOwner: env.CI_PROJECT_NAMESPACE,\n      repositoryName: env.CI_PROJECT_NAME,\n      gitlabProjectId: env.CI_PROJECT_ID,\n      projectDir: env.CI_PROJECT_DIR,\n      reporitoryUrl: env.CI_REPOSITORY_URL,\n    };\n\n    return config;\n  }\n\n  async branchExists({ branch }: { branch: string }): Promise<boolean> {\n    try {\n      await this.gitlab.Branches.show(\n        this.platformConfig.gitlabProjectId,\n        branch,\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getOpenPullRequestNumber({\n    branch,\n  }: {\n    branch: string;\n  }): Promise<number | undefined> {\n    const mergeRequests = await this.gitlab.MergeRequests.all({\n      projectId: this.platformConfig.gitlabProjectId,\n      sourceBranch: branch,\n      state: \"opened\",\n    });\n    return mergeRequests[0]?.iid;\n  }\n\n  async closePullRequest({\n    pullRequestNumber,\n  }: {\n    pullRequestNumber: number;\n  }): Promise<void> {\n    await this.gitlab.MergeRequests.edit(\n      this.platformConfig.gitlabProjectId,\n      pullRequestNumber,\n      {\n        stateEvent: \"close\",\n      },\n    );\n  }\n\n  async createPullRequest({\n    head,\n    title,\n    body,\n  }: {\n    head: string;\n    title: string;\n    body?: string;\n  }): Promise<number> {\n    const mr = await this.gitlab.MergeRequests.create(\n      this.platformConfig.gitlabProjectId,\n      head,\n      this.platformConfig.baseBranchName,\n      title,\n      {\n        description: body,\n      },\n    );\n    return mr.iid;\n  }\n\n  async commentOnPullRequest({\n    pullRequestNumber,\n    body,\n  }: {\n    pullRequestNumber: number;\n    body: string;\n  }): Promise<void> {\n    await this.gitlab.MergeRequestNotes.create(\n      this.platformConfig.gitlabProjectId,\n      pullRequestNumber,\n      body,\n    );\n  }\n\n  gitConfig(): Promise<void> | void {\n    const glToken = this.platformConfig.glToken;\n    const url = `https://oauth2:${glToken}@gitlab.com/${this.platformConfig.repositoryOwner}/${this.platformConfig.repositoryName}.git`;\n\n    super.gitConfig(glToken, url);\n  }\n\n  buildPullRequestUrl(pullRequestNumber: number): string {\n    return `https://gitlab.com/${this.platformConfig.repositoryOwner}/${this.platformConfig.repositoryName}/-/merge_requests/${pullRequestNumber}`;\n  }\n}\n","import { BitbucketPlatformKit } from \"./bitbucket\";\nimport { GitHubPlatformKit } from \"./github\";\nimport { GitlabPlatformKit } from \"./gitlab\";\n\nexport const getPlatformKit = () => {\n  if (process.env.BITBUCKET_PIPELINE_UUID) {\n    return new BitbucketPlatformKit();\n  }\n\n  if (process.env.GITHUB_ACTION) {\n    return new GitHubPlatformKit();\n  }\n\n  if (process.env.GITLAB_CI) {\n    return new GitlabPlatformKit();\n  }\n\n  throw new Error(\"This platform is not supported\");\n};\n","import {\n  bucketTypeSchema,\n  I18nConfig,\n  localeCodeSchema,\n  resolveOverriddenLocale,\n} from \"@lingo.dev/_spec\";\nimport { Command } from \"interactive-commander\";\nimport Z from \"zod\";\nimport _ from \"lodash\";\nimport * as path from \"path\";\nimport { getConfig } from \"../utils/config\";\nimport { getSettings } from \"../utils/settings\";\nimport { CLIError } from \"../utils/errors\";\nimport Ora from \"ora\";\nimport createBucketLoader from \"../loaders\";\nimport { createAuthenticator } from \"../utils/auth\";\nimport { getBuckets } from \"../utils/buckets\";\nimport chalk from \"chalk\";\nimport Table from \"cli-table3\";\nimport { createDeltaProcessor } from \"../utils/delta\";\nimport trackEvent from \"../utils/observability\";\nimport { minimatch } from \"minimatch\";\nimport { exitGracefully } from \"../utils/exit-gracefully\";\n\n// Define types for our language stats\ninterface LanguageStats {\n  complete: number;\n  missing: number;\n  updated: number;\n  words: number;\n}\n\nexport default new Command()\n  .command(\"status\")\n  .description(\"Show the status of the localization process\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--locale <locale>\",\n    \"Limit the report to specific target locales from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--bucket <bucket>\",\n    \"Limit the report to specific bucket types defined in i18n.json (e.g., json, yaml, android). Repeat the flag to include multiple bucket types. Defaults to all buckets\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--file [files...]\",\n    \"Filter the status report to only include files whose paths contain these substrings. Example: 'components' to match any file path containing 'components'\",\n  )\n  .option(\n    \"--force\",\n    \"Force all keys to be counted as needing translation, bypassing change detection. Shows word estimates for a complete retranslation regardless of current translation status\",\n  )\n  .option(\n    \"--verbose\",\n    \"Print detailed output showing missing and updated key counts with example key names for each file and locale\",\n  )\n  .option(\n    \"--api-key <api-key>\",\n    \"Override the API key from settings or environment variables for this run\",\n  )\n  .action(async function (options) {\n    const ora = Ora();\n    const flags = parseFlags(options);\n    let authId: string | null = null;\n\n    try {\n      ora.start(\"Loading configuration...\");\n      const i18nConfig = getConfig();\n      const settings = getSettings(flags.apiKey);\n      ora.succeed(\"Configuration loaded\");\n\n      // Try to authenticate, but continue even if not authenticated\n      try {\n        ora.start(\"Checking authentication status...\");\n        const auth = await tryAuthenticate(settings);\n        if (auth) {\n          authId = auth.id;\n          ora.succeed(`Authenticated as ${auth.email}`);\n        } else {\n          ora.info(\n            \"Not authenticated. Continuing without authentication. (Run `lingo.dev login` to authenticate)\",\n          );\n        }\n      } catch (error) {\n        ora.info(\"Authentication failed. Continuing without authentication.\");\n      }\n\n      ora.start(\"Validating localization configuration...\");\n      validateParams(i18nConfig, flags);\n      ora.succeed(\"Localization configuration is valid\");\n\n      // Track event with or without authentication\n      trackEvent(authId || \"status\", \"cmd.status.start\", {\n        i18nConfig,\n        flags,\n      });\n\n      let buckets = getBuckets(i18nConfig!);\n      if (flags.bucket?.length) {\n        buckets = buckets.filter((bucket: any) =>\n          flags.bucket!.includes(bucket.type),\n        );\n      }\n      ora.succeed(\"Buckets retrieved\");\n\n      if (flags.file?.length) {\n        buckets = buckets\n          .map((bucket: any) => {\n            const paths = bucket.paths.filter((path: any) =>\n              flags.file!.find(\n                (file) =>\n                  path.pathPattern?.includes(file) ||\n                  path.pathPattern?.match(file) ||\n                  minimatch(path.pathPattern, file),\n              ),\n            );\n            return { ...bucket, paths };\n          })\n          .filter((bucket: any) => bucket.paths.length > 0);\n        if (buckets.length === 0) {\n          ora.fail(\n            \"No buckets found. All buckets were filtered out by --file option.\",\n          );\n          process.exit(1);\n        } else {\n          ora.info(`\\x1b[36mProcessing only filtered buckets:\\x1b[0m`);\n          buckets.map((bucket: any) => {\n            ora.info(`  ${bucket.type}:`);\n            bucket.paths.forEach((path: any) => {\n              ora.info(`    - ${path.pathPattern}`);\n            });\n          });\n        }\n      }\n\n      const targetLocales = flags.locale?.length\n        ? flags.locale\n        : i18nConfig!.locale.targets;\n\n      // Global stats\n      let totalSourceKeyCount = 0;\n      let uniqueKeysToTranslate = 0;\n      let totalExistingTranslations = 0;\n      const totalWordCount = new Map<string, number>(); // Words per language\n      const languageStats: Record<string, LanguageStats> = {};\n\n      // Initialize per-language stats\n      for (const locale of targetLocales) {\n        languageStats[locale] = {\n          complete: 0,\n          missing: 0,\n          updated: 0,\n          words: 0,\n        };\n        totalWordCount.set(locale, 0);\n      }\n\n      // Per-file stats\n      const fileStats: Record<\n        string,\n        {\n          path: string;\n          sourceKeys: number;\n          wordCount: number;\n          languageStats: Record<\n            string,\n            {\n              complete: number;\n              missing: number;\n              updated: number;\n              words: number;\n            }\n          >;\n        }\n      > = {};\n\n      // Process each bucket\n      for (const bucket of buckets) {\n        try {\n          console.log();\n          ora.info(`Analyzing bucket: ${bucket.type}`);\n\n          for (const bucketPath of bucket.paths) {\n            const bucketOra = Ora({ indent: 2 }).info(\n              `Analyzing path: ${bucketPath.pathPattern}`,\n            );\n\n            const sourceLocale = resolveOverriddenLocale(\n              i18nConfig!.locale.source,\n              bucketPath.delimiter,\n            );\n            const bucketLoader = createBucketLoader(\n              bucket.type,\n              bucketPath.pathPattern,\n              {\n                defaultLocale: sourceLocale,\n                injectLocale: bucket.injectLocale,\n                formatter: i18nConfig!.formatter,\n              },\n              bucket.lockedKeys,\n              bucket.lockedPatterns,\n              bucket.ignoredKeys,\n            );\n\n            bucketLoader.setDefaultLocale(sourceLocale);\n            await bucketLoader.init();\n\n            // Initialize file stats\n            const filePath = bucketPath.pathPattern;\n            if (!fileStats[filePath]) {\n              fileStats[filePath] = {\n                path: filePath,\n                sourceKeys: 0,\n                wordCount: 0,\n                languageStats: {},\n              };\n\n              for (const locale of targetLocales) {\n                fileStats[filePath].languageStats[locale] = {\n                  complete: 0,\n                  missing: 0,\n                  updated: 0,\n                  words: 0,\n                };\n              }\n            }\n\n            // Get source data and count source keys\n            const sourceData = await bucketLoader.pull(sourceLocale);\n            const sourceKeys = Object.keys(sourceData);\n            fileStats[filePath].sourceKeys = sourceKeys.length;\n            totalSourceKeyCount += sourceKeys.length;\n\n            // Calculate source word count\n            let sourceWordCount = 0;\n            for (const key of sourceKeys) {\n              const value = sourceData[key];\n              if (typeof value === \"string\") {\n                const words = value.trim().split(/\\s+/).length;\n                sourceWordCount += words;\n              }\n            }\n            fileStats[filePath].wordCount = sourceWordCount;\n\n            // Process each target locale\n            for (const _targetLocale of targetLocales) {\n              const targetLocale = resolveOverriddenLocale(\n                _targetLocale,\n                bucketPath.delimiter,\n              );\n              bucketOra.start(\n                `[${sourceLocale} -> ${targetLocale}] Analyzing translation status...`,\n              );\n\n              let targetData = {};\n              let fileExists = true;\n\n              try {\n                targetData = await bucketLoader.pull(targetLocale);\n              } catch (error) {\n                fileExists = false;\n                bucketOra.info(\n                  `[${sourceLocale} -> ${targetLocale}] Target file not found, assuming all keys need translation.`,\n                );\n              }\n\n              if (!fileExists) {\n                // All keys are missing for this locale\n                fileStats[filePath].languageStats[_targetLocale].missing =\n                  sourceKeys.length;\n                fileStats[filePath].languageStats[_targetLocale].words =\n                  sourceWordCount;\n                languageStats[_targetLocale].missing += sourceKeys.length;\n                languageStats[_targetLocale].words += sourceWordCount;\n                totalWordCount.set(\n                  _targetLocale,\n                  (totalWordCount.get(_targetLocale) || 0) + sourceWordCount,\n                );\n\n                bucketOra.succeed(\n                  `[${sourceLocale} -> ${targetLocale}] ${chalk.red(\n                    `0% complete`,\n                  )} (0/${sourceKeys.length} keys) - file not found`,\n                );\n                continue;\n              }\n\n              // Calculate delta for existing file\n              const deltaProcessor = createDeltaProcessor(\n                bucketPath.pathPattern,\n              );\n              const checksums = await deltaProcessor.loadChecksums();\n              const delta = await deltaProcessor.calculateDelta({\n                sourceData,\n                targetData,\n                checksums,\n              });\n\n              const missingKeys = delta.added;\n              const updatedKeys = delta.updated;\n              const completeKeys = sourceKeys.filter(\n                (key) =>\n                  !missingKeys.includes(key) && !updatedKeys.includes(key),\n              );\n\n              // Count words that need translation\n              let wordsToTranslate = 0;\n              const keysToProcess = flags.force\n                ? sourceKeys\n                : [...missingKeys, ...updatedKeys];\n\n              for (const key of keysToProcess) {\n                const value = sourceData[String(key)];\n                if (typeof value === \"string\") {\n                  const words = value.trim().split(/\\s+/).length;\n                  wordsToTranslate += words;\n                }\n              }\n\n              // Update file stats\n              fileStats[filePath].languageStats[_targetLocale].missing =\n                missingKeys.length;\n              fileStats[filePath].languageStats[_targetLocale].updated =\n                updatedKeys.length;\n              fileStats[filePath].languageStats[_targetLocale].complete =\n                completeKeys.length;\n              fileStats[filePath].languageStats[_targetLocale].words =\n                wordsToTranslate;\n\n              // Update global stats\n              languageStats[_targetLocale].missing += missingKeys.length;\n              languageStats[_targetLocale].updated += updatedKeys.length;\n              languageStats[_targetLocale].complete += completeKeys.length;\n              languageStats[_targetLocale].words += wordsToTranslate;\n              totalWordCount.set(\n                _targetLocale,\n                (totalWordCount.get(_targetLocale) || 0) + wordsToTranslate,\n              );\n\n              // Display progress\n              const totalKeysInFile = sourceKeys.length;\n              const completionPercent = (\n                (completeKeys.length / totalKeysInFile) *\n                100\n              ).toFixed(1);\n\n              if (missingKeys.length === 0 && updatedKeys.length === 0) {\n                bucketOra.succeed(\n                  `[${sourceLocale} -> ${targetLocale}] ${chalk.green(\n                    `100% complete`,\n                  )} (${completeKeys.length}/${totalKeysInFile} keys)`,\n                );\n              } else {\n                const message = `[${sourceLocale} -> ${targetLocale}] ${\n                  parseFloat(completionPercent) > 50\n                    ? chalk.yellow(`${completionPercent}% complete`)\n                    : chalk.red(`${completionPercent}% complete`)\n                } (${completeKeys.length}/${totalKeysInFile} keys)`;\n\n                bucketOra.succeed(message);\n\n                if (flags.verbose) {\n                  if (missingKeys.length > 0) {\n                    console.log(\n                      `    ${chalk.red(`Missing:`)} ${missingKeys.length} keys, ~${wordsToTranslate} words`,\n                    );\n                    console.log(\n                      `    ${chalk.red(`Missing:`)} ${\n                        missingKeys.length\n                      } keys, ~${wordsToTranslate} words`,\n                    );\n                    console.log(\n                      `    ${chalk.dim(\n                        `Example missing: ${missingKeys\n                          .slice(0, 2)\n                          .join(\", \")}${missingKeys.length > 2 ? \"...\" : \"\"}`,\n                      )}`,\n                    );\n                  }\n                  if (updatedKeys.length > 0) {\n                    console.log(\n                      `    ${chalk.yellow(`Updated:`)} ${\n                        updatedKeys.length\n                      } keys that changed in source`,\n                    );\n                  }\n                }\n              }\n            }\n          }\n        } catch (error: any) {\n          ora.fail(`Failed to analyze bucket ${bucket.type}: ${error.message}`);\n        }\n      }\n\n      // Calculate unique keys needing translation and keys fully translated\n      // Count unique keys that need translation\n      const totalKeysNeedingTranslation = Object.values(languageStats).reduce(\n        (sum, stats) => {\n          return sum + stats.missing + stats.updated;\n        },\n        0,\n      );\n\n      // Calculate keys that are completely translated\n      const totalCompletedKeys =\n        totalSourceKeyCount -\n        totalKeysNeedingTranslation / targetLocales.length;\n\n      // Summary output\n      console.log();\n      ora.succeed(chalk.green(`Localization status completed.`));\n\n      // Create a visually impactful main header\n      console.log(chalk.bold.cyan(`\\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`));\n      console.log(chalk.bold.cyan(`‚ïë   LOCALIZATION STATUS REPORT       ‚ïë`));\n      console.log(chalk.bold.cyan(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`));\n\n      // Source content overview\n      console.log(chalk.bold(`\\nüìù SOURCE CONTENT:`));\n      console.log(\n        `‚Ä¢ Source language: ${chalk.green(i18nConfig!.locale.source)}`,\n      );\n      console.log(\n        `‚Ä¢ Source keys: ${chalk.yellow(\n          totalSourceKeyCount.toString(),\n        )} keys across all files`,\n      );\n\n      // Create a language-by-language breakdown table\n      console.log(chalk.bold(`\\nüåê LANGUAGE BY LANGUAGE BREAKDOWN:`));\n\n      // Create a new table instance with cli-table3\n      const table = new Table({\n        head: [\n          \"Language\",\n          \"Status\",\n          \"Complete\",\n          \"Missing\",\n          \"Updated\",\n          \"Total Keys\",\n          \"Words to Translate\",\n        ],\n        style: {\n          head: [\"white\"], // White color for headers\n          border: [], // No color for borders\n        },\n        colWidths: [12, 20, 18, 12, 12, 12, 15], // Explicit column widths, making Status column wider\n      });\n\n      // Data rows\n      let totalWordsToTranslate = 0;\n      for (const locale of targetLocales) {\n        const stats = languageStats[locale];\n        const percentComplete = (\n          (stats.complete / totalSourceKeyCount) *\n          100\n        ).toFixed(1);\n        const totalNeeded = stats.missing + stats.updated;\n\n        // Determine status text and color\n        let statusText;\n        let statusColor;\n        if (stats.missing === totalSourceKeyCount) {\n          statusText = \"üî¥ Not started\";\n          statusColor = chalk.red;\n        } else if (stats.missing === 0 && stats.updated === 0) {\n          statusText = \"‚úÖ Complete\";\n          statusColor = chalk.green;\n        } else if (parseFloat(percentComplete) > 80) {\n          statusText = \"üü° Almost done\";\n          statusColor = chalk.yellow;\n        } else if (parseFloat(percentComplete) > 0) {\n          statusText = \"üü† In progress\";\n          statusColor = chalk.yellow;\n        } else {\n          statusText = \"üî¥ Not started\";\n          statusColor = chalk.red;\n        }\n\n        // Create row data\n        const words = totalWordCount.get(locale) || 0;\n        totalWordsToTranslate += words;\n\n        // Add row to the table\n        table.push([\n          locale,\n          statusColor(statusText),\n          `${stats.complete}/${totalSourceKeyCount} (${percentComplete}%)`,\n          stats.missing > 0 ? chalk.red(stats.missing.toString()) : \"0\",\n          stats.updated > 0 ? chalk.yellow(stats.updated.toString()) : \"0\",\n          totalNeeded > 0 ? chalk.magenta(totalNeeded.toString()) : \"0\",\n          words > 0 ? `~${words.toLocaleString()}` : \"0\",\n        ]);\n      }\n\n      // Display the table\n      console.log(table.toString());\n\n      // Total usage summary\n      console.log(chalk.bold(`\\nüìä USAGE ESTIMATE:`));\n      console.log(\n        `‚Ä¢ WORDS TO BE CONSUMED: ~${chalk.yellow.bold(\n          totalWordsToTranslate.toLocaleString(),\n        )} words across all languages`,\n      );\n      console.log(\n        `  (Words are counted from source language for keys that need translation in target languages)`,\n      );\n\n      // Breakdown by language if we have multiple languages\n      if (targetLocales.length > 1) {\n        console.log(`‚Ä¢ Per-language breakdown:`);\n        for (const locale of targetLocales) {\n          const words = totalWordCount.get(locale) || 0;\n          const percent = ((words / totalWordsToTranslate) * 100).toFixed(1);\n          console.log(\n            `  - ${locale}: ~${words.toLocaleString()} words (${percent}% of total)`,\n          );\n        }\n      }\n\n      // Detailed stats if flags.confirm is specified\n      if (flags.confirm && Object.keys(fileStats).length > 0) {\n        console.log(chalk.bold(`\\nüìë BREAKDOWN BY FILE:`));\n\n        Object.entries(fileStats)\n          .sort((a, b) => b[1].wordCount - a[1].wordCount) // Sort by word count\n          .forEach(([path, stats]) => {\n            // Skip files with no source keys\n            if (stats.sourceKeys === 0) return;\n\n            console.log(chalk.bold(`\\n‚Ä¢ ${path}:`));\n            console.log(\n              `  ${\n                stats.sourceKeys\n              } source keys, ~${stats.wordCount.toLocaleString()} source words`,\n            );\n\n            // Create file detail table\n            const fileTable = new Table({\n              head: [\"Language\", \"Status\", \"Details\"],\n              style: {\n                head: [\"white\"],\n                border: [],\n              },\n              colWidths: [12, 20, 50], // Explicit column widths for file detail table\n            });\n\n            for (const locale of targetLocales) {\n              const langStats = stats.languageStats[locale];\n              const complete = langStats.complete;\n              const total = stats.sourceKeys;\n              const completion = ((complete / total) * 100).toFixed(1);\n\n              let status = \"‚úÖ Complete\";\n              let statusColor = chalk.green;\n\n              if (langStats.missing === total) {\n                status = \"‚ùå Not started\";\n                statusColor = chalk.red;\n              } else if (langStats.missing > 0 || langStats.updated > 0) {\n                status = `‚ö†Ô∏è ${completion}% complete`;\n                statusColor = chalk.yellow;\n              }\n\n              // Show counts only if there's something missing or updated\n              let details = \"\";\n              if (langStats.missing > 0 || langStats.updated > 0) {\n                const parts = [];\n                if (langStats.missing > 0)\n                  parts.push(`${langStats.missing} missing`);\n                if (langStats.updated > 0)\n                  parts.push(`${langStats.updated} changed`);\n                details = `${parts.join(\", \")}, ~${langStats.words} words`;\n              } else {\n                details = \"All keys translated\";\n              }\n\n              fileTable.push([locale, statusColor(status), details]);\n            }\n\n            console.log(fileTable.toString());\n          });\n      }\n\n      // Find fully translated and missing languages\n      const completeLanguages = targetLocales.filter(\n        (locale) =>\n          languageStats[locale].missing === 0 &&\n          languageStats[locale].updated === 0,\n      );\n\n      const missingLanguages = targetLocales.filter(\n        (locale) => languageStats[locale].complete === 0,\n      );\n\n      // Add optimization tips\n      console.log(chalk.bold.green(`\\nüí° OPTIMIZATION TIPS:`));\n\n      if (missingLanguages.length > 0) {\n        console.log(\n          `‚Ä¢ ${chalk.yellow(missingLanguages.join(\", \"))} ${\n            missingLanguages.length === 1 ? \"has\" : \"have\"\n          } no translations yet`,\n        );\n      }\n\n      if (completeLanguages.length > 0) {\n        console.log(\n          `‚Ä¢ ${chalk.green(completeLanguages.join(\", \"))} ${\n            completeLanguages.length === 1 ? \"is\" : \"are\"\n          } completely translated`,\n        );\n      }\n\n      // Other tips\n      if (targetLocales.length > 1) {\n        console.log(`‚Ä¢ Translating one language at a time reduces complexity`);\n        console.log(\n          `‚Ä¢ Try 'lingo.dev@latest i18n --locale ${targetLocales[0]}' to process just one language`,\n        );\n      }\n\n      // Track successful completion\n      trackEvent(authId || \"status\", \"cmd.status.success\", {\n        i18nConfig,\n        flags,\n        totalSourceKeyCount,\n        languageStats,\n        totalWordsToTranslate,\n        authenticated: !!authId,\n      });\n      exitGracefully();\n    } catch (error: any) {\n      ora.fail(error.message);\n      trackEvent(authId || \"status\", \"cmd.status.error\", {\n        flags,\n        error: error.message,\n        authenticated: !!authId,\n      });\n      process.exit(1);\n    }\n  });\n\nfunction parseFlags(options: any) {\n  return Z.object({\n    locale: Z.array(localeCodeSchema).optional(),\n    bucket: Z.array(bucketTypeSchema).optional(),\n    force: Z.boolean().optional(),\n    confirm: Z.boolean().optional(),\n    verbose: Z.boolean().optional(),\n    file: Z.array(Z.string()).optional(),\n    apiKey: Z.string().optional(),\n  }).parse(options);\n}\n\nasync function tryAuthenticate(settings: ReturnType<typeof getSettings>) {\n  if (!settings.auth.apiKey) {\n    return null;\n  }\n\n  try {\n    const authenticator = createAuthenticator({\n      apiKey: settings.auth.apiKey,\n      apiUrl: settings.auth.apiUrl,\n    });\n    const user = await authenticator.whoami();\n    return user;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction validateParams(\n  i18nConfig: I18nConfig | null,\n  flags: ReturnType<typeof parseFlags>,\n) {\n  if (!i18nConfig) {\n    throw new CLIError({\n      message:\n        \"i18n.json not found. Please run `lingo.dev init` to initialize the project.\",\n      docUrl: \"i18nNotFound\",\n    });\n  } else if (!i18nConfig.buckets || !Object.keys(i18nConfig.buckets).length) {\n    throw new CLIError({\n      message:\n        \"No buckets found in i18n.json. Please add at least one bucket containing i18n content.\",\n      docUrl: \"bucketNotFound\",\n    });\n  } else if (\n    flags.locale?.some((locale) => !i18nConfig.locale.targets.includes(locale))\n  ) {\n    throw new CLIError({\n      message: `One or more specified locales do not exist in i18n.json locale.targets. Please add them to the list and try again.`,\n      docUrl: \"localeTargetNotFound\",\n    });\n  } else if (\n    flags.bucket?.some(\n      (bucket) =>\n        !i18nConfig.buckets[bucket as keyof typeof i18nConfig.buckets],\n    )\n  ) {\n    throw new CLIError({\n      message: `One or more specified buckets do not exist in i18n.json. Please add them to the list and try again.`,\n      docUrl: \"bucketNotFound\",\n    });\n  }\n}\n","const STEP_WAIT_INTERVAL = 250;\nconst MAX_WAIT_INTERVAL = 2000;\n\nexport function exitGracefully(elapsedMs = 0) {\n  // Check if there are any pending operations\n  const hasPendingOperations = checkForPendingOperations();\n\n  if (hasPendingOperations && elapsedMs < MAX_WAIT_INTERVAL) {\n    // Wait a bit longer if there are pending operations\n    setTimeout(\n      () => exitGracefully(elapsedMs + STEP_WAIT_INTERVAL),\n      STEP_WAIT_INTERVAL,\n    );\n  } else {\n    // Exit immediately if no pending operations\n    process.exit(0);\n  }\n}\n\nfunction checkForPendingOperations(): boolean {\n  // Check for active handles and requests using internal Node.js methods\n  const activeHandles = (process as any)._getActiveHandles?.() || [];\n  const activeRequests = (process as any)._getActiveRequests?.() || [];\n\n  // Filter out standard handles that are always present\n  const nonStandardHandles = activeHandles.filter((handle: any) => {\n    // Skip standard handles like process.stdin, process.stdout, etc.\n    if (\n      handle === process.stdin ||\n      handle === process.stdout ||\n      handle === process.stderr\n    ) {\n      return false;\n    }\n    // Skip timers that are part of the normal process\n    if (\n      handle &&\n      typeof handle === \"object\" &&\n      \"hasRef\" in handle &&\n      !handle.hasRef()\n    ) {\n      return false;\n    }\n    return true;\n  });\n\n  // Check if there are any file watchers or other async operations\n  const hasFileWatchers = nonStandardHandles.some(\n    (handle: any) => handle && typeof handle === \"object\" && \"close\" in handle,\n  );\n\n  // Check for pending promises or async operations\n  const hasPendingPromises = activeRequests.length > 0;\n\n  return nonStandardHandles.length > 0 || hasFileWatchers || hasPendingPromises;\n}\n","import { Command } from \"interactive-commander\";\nimport * as cp from \"node:child_process\";\nimport figlet from \"figlet\";\nimport chalk from \"chalk\";\nimport { vice } from \"gradient-string\";\nimport { setTimeout } from \"node:timers/promises\";\n\nexport const colors = {\n  orange: \"#ff6600\",\n  green: \"#6ae300\",\n  blue: \"#0090ff\",\n  yellow: \"#ffcc00\",\n  grey: \"#808080\",\n  red: \"#ff0000\",\n};\n\nexport default new Command()\n  .command(\"may-the-fourth\")\n  .description(\"May the Fourth be with you\")\n  .helpOption(\"-h, --help\", \"Show help\")\n  .action(async () => {\n    await renderClear();\n    await renderBanner();\n    await renderSpacer();\n\n    console.log(chalk.hex(colors.yellow)(\"Loading the Star Wars movie...\"));\n    await renderSpacer();\n\n    await new Promise<void>((resolve, reject) => {\n      const ssh = cp.spawn(\"ssh\", [\"starwarstel.net\"], {\n        stdio: \"inherit\",\n      });\n\n      ssh.on(\"close\", (code) => {\n        if (code !== 0) {\n          console.error(`SSH process exited with code ${code}`);\n          // Optionally reject the promise if the exit code is non-zero\n          // reject(new Error(`SSH process exited with code ${code}`));\n        }\n        resolve(); // Resolve the promise when SSH closes\n      });\n\n      ssh.on(\"error\", (err) => {\n        console.error(\"Failed to start SSH process:\", err);\n        reject(err); // Reject the promise on error\n      });\n    });\n\n    // This code now runs after the SSH process has finished\n    await renderSpacer();\n    console.log(\n      `${chalk.hex(colors.green)(\"We hope you enjoyed it! :)\")} ${chalk.hex(\n        colors.blue,\n      )(\"May the Fourth be with you! üöÄ\")}`,\n    );\n    await renderSpacer();\n    console.log(chalk.dim(`---`));\n    await renderSpacer();\n    await renderHero();\n  });\n\nasync function renderClear() {\n  console.log(\"\\x1Bc\");\n}\n\nasync function renderSpacer() {\n  console.log(\" \");\n}\n\nasync function renderBanner() {\n  console.log(\n    vice(\n      figlet.textSync(\"LINGO.DEV\", {\n        font: \"ANSI Shadow\",\n        horizontalLayout: \"default\",\n        verticalLayout: \"default\",\n      }),\n    ),\n  );\n}\n\nasync function renderHero() {\n  console.log(\n    `‚ö°Ô∏è ${chalk.hex(colors.green)(\n      \"Lingo.dev\",\n    )} - open-source, AI-powered i18n CLI for web & mobile localization.`,\n  );\n  console.log(\" \");\n  console.log(chalk.hex(colors.blue)(\"üìö Docs: https://lingo.dev/go/docs\"));\n  console.log(\n    chalk.hex(colors.blue)(\"‚≠ê Star the repo: https://lingo.dev/go/gh\"),\n  );\n  console.log(\n    chalk.hex(colors.blue)(\"üéÆ Join Discord: https://lingo.dev/go/discord\"),\n  );\n}\n","{\n  \"name\": \"lingo.dev\",\n  \"version\": \"0.115.0\",\n  \"description\": \"Lingo.dev CLI\",\n  \"private\": false,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"exports\": {\n    \"./cli\": {\n      \"types\": \"./build/cli.d.ts\",\n      \"import\": \"./build/cli.mjs\",\n      \"require\": \"./build/cli.cjs\"\n    },\n    \"./sdk\": {\n      \"types\": \"./build/sdk.d.ts\",\n      \"import\": \"./build/sdk.mjs\",\n      \"require\": \"./build/sdk.cjs\"\n    },\n    \"./spec\": {\n      \"types\": \"./build/spec.d.ts\",\n      \"import\": \"./build/spec.mjs\",\n      \"require\": \"./build/spec.cjs\"\n    },\n    \"./compiler\": {\n      \"types\": \"./build/compiler.d.ts\",\n      \"import\": \"./build/compiler.mjs\",\n      \"require\": \"./build/compiler.cjs\"\n    },\n    \"./react\": {\n      \"types\": \"./build/react.d.ts\",\n      \"import\": \"./build/react.mjs\",\n      \"require\": \"./build/react.cjs\"\n    },\n    \"./react-client\": {\n      \"types\": \"./build/react/client.d.ts\",\n      \"import\": \"./build/react/client.mjs\",\n      \"require\": \"./build/react/client.cjs\"\n    },\n    \"./react/client\": {\n      \"types\": \"./build/react/client.d.ts\",\n      \"import\": \"./build/react/client.mjs\",\n      \"require\": \"./build/react/client.cjs\"\n    },\n    \"./react-rsc\": {\n      \"types\": \"./build/react/rsc.d.ts\",\n      \"import\": \"./build/react/rsc.mjs\",\n      \"require\": \"./build/react/rsc.cjs\"\n    },\n    \"./react/rsc\": {\n      \"types\": \"./build/react/rsc.d.ts\",\n      \"import\": \"./build/react/rsc.mjs\",\n      \"require\": \"./build/react/rsc.cjs\"\n    },\n    \"./react-router\": {\n      \"types\": \"./build/react/react-router.d.ts\",\n      \"import\": \"./build/react/react-router.mjs\",\n      \"require\": \"./build/react/react-router.cjs\"\n    },\n    \"./react/react-router\": {\n      \"types\": \"./build/react/react-router.d.ts\",\n      \"import\": \"./build/react/react-router.mjs\",\n      \"require\": \"./build/react/react-router.cjs\"\n    },\n    \"./locale-codes\": {\n      \"types\": \"./build/locale-codes.d.ts\",\n      \"import\": \"./build/locale-codes.mjs\",\n      \"require\": \"./build/locale-codes.cjs\"\n    }\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"sdk\": [\n        \"./build/sdk.d.ts\"\n      ],\n      \"cli\": [\n        \"./build/cli.d.ts\"\n      ],\n      \"spec\": [\n        \"./build/spec.d.ts\"\n      ],\n      \"compiler\": [\n        \"./build/compiler.d.ts\"\n      ],\n      \"react\": [\n        \"./build/react.d.ts\"\n      ],\n      \"react/client\": [\n        \"./build/react/client.d.ts\"\n      ],\n      \"react/rsc\": [\n        \"./build/react/rsc.d.ts\"\n      ],\n      \"react/react-router\": [\n        \"./build/react/react-router.d.ts\"\n      ],\n      \"locale-codes\": [\n        \"./build/locale-codes.d.ts\"\n      ]\n    }\n  },\n  \"bin\": {\n    \"lingo.dev\": \"./bin/cli.mjs\"\n  },\n  \"files\": [\n    \"bin\",\n    \"build\",\n    \"assets\"\n  ],\n  \"scripts\": {\n    \"lingo.dev\": \"node --inspect=9229 ./bin/cli.mjs\",\n    \"dev\": \"tsup --watch\",\n    \"build\": \"pnpm typecheck && tsup\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"clean\": \"rm -rf build\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"@ai-sdk/anthropic\": \"^1.2.11\",\n    \"@ai-sdk/google\": \"^1.2.19\",\n    \"@ai-sdk/mistral\": \"^1.2.8\",\n    \"@ai-sdk/openai\": \"^1.3.22\",\n    \"@babel/generator\": \"^7.27.1\",\n    \"@babel/parser\": \"^7.27.1\",\n    \"@babel/traverse\": \"^7.27.4\",\n    \"@babel/types\": \"^7.27.1\",\n    \"@biomejs/js-api\": \"^3.0.0\",\n    \"@biomejs/wasm-nodejs\": \"^2.2.4\",\n    \"@datocms/cma-client-node\": \"^4.0.1\",\n    \"@gitbeaker/rest\": \"^39.34.3\",\n    \"@inkjs/ui\": \"^2.0.0\",\n    \"@inquirer/prompts\": \"^7.8.0\",\n    \"@lingo.dev/_compiler\": \"workspace:*\",\n    \"@lingo.dev/_locales\": \"workspace:*\",\n    \"@lingo.dev/_react\": \"workspace:*\",\n    \"@lingo.dev/_sdk\": \"workspace:*\",\n    \"@lingo.dev/_spec\": \"workspace:*\",\n    \"@markdoc/markdoc\": \"^0.5.4\",\n    \"@modelcontextprotocol/sdk\": \"^1.5.0\",\n    \"@openrouter/ai-sdk-provider\": \"^0.7.1\",\n    \"@paralleldrive/cuid2\": \"^2.2.2\",\n    \"@types/ejs\": \"^3.1.5\",\n    \"ai\": \"^4.3.15\",\n    \"bitbucket\": \"^2.12.0\",\n    \"chalk\": \"^5.4.1\",\n    \"chokidar\": \"^4.0.3\",\n    \"cli-progress\": \"^3.12.0\",\n    \"cli-table3\": \"^0.6.5\",\n    \"cors\": \"^2.8.5\",\n    \"csv-parse\": \"^5.6.0\",\n    \"csv-stringify\": \"^6.5.2\",\n    \"date-fns\": \"^4.1.0\",\n    \"dedent\": \"^1.5.3\",\n    \"diff\": \"^7.0.0\",\n    \"dotenv\": \"^16.4.7\",\n    \"ejs\": \"^3.1.10\",\n    \"express\": \"^5.1.0\",\n    \"external-editor\": \"^3.1.0\",\n    \"figlet\": \"^1.8.2\",\n    \"flat\": \"^6.0.1\",\n    \"gettext-parser\": \"^8.0.0\",\n    \"glob\": \"<11.0.0\",\n    \"gradient-string\": \"^3.0.0\",\n    \"gray-matter\": \"^4.0.3\",\n    \"ini\": \"^5.0.0\",\n    \"ink\": \"^4.2.0\",\n    \"ink-progress-bar\": \"^3.0.0\",\n    \"ink-spinner\": \"^5.0.0\",\n    \"inquirer\": \"^12.6.0\",\n    \"interactive-commander\": \"^0.5.194\",\n    \"is-url\": \"^1.2.4\",\n    \"jsdom\": \"^25.0.1\",\n    \"json5\": \"^2.2.3\",\n    \"jsonc-parser\": \"^3.3.1\",\n    \"jsonrepair\": \"^3.11.2\",\n    \"listr2\": \"^8.3.2\",\n    \"lodash\": \"^4.17.21\",\n    \"marked\": \"^15.0.6\",\n    \"mdast-util-from-markdown\": \"^2.0.2\",\n    \"mdast-util-gfm\": \"^3.1.0\",\n    \"micromark-extension-gfm\": \"^3.0.0\",\n    \"node-machine-id\": \"^1.1.12\",\n    \"node-webvtt\": \"^1.9.4\",\n    \"object-hash\": \"^3.0.0\",\n    \"octokit\": \"^4.0.2\",\n    \"ollama-ai-provider\": \"^1.2.0\",\n    \"open\": \"^10.2.0\",\n    \"ora\": \"^8.1.1\",\n    \"p-limit\": \"^6.2.0\",\n    \"php-array-reader\": \"^2.1.2\",\n    \"plist\": \"^3.1.0\",\n    \"posthog-node\": \"^5.8.1\",\n    \"prettier\": \"^3.4.2\",\n    \"react\": \"^18.3.1\",\n    \"rehype-stringify\": \"^10.0.1\",\n    \"remark-disable-tokenizers\": \"^1.1.1\",\n    \"remark-frontmatter\": \"^5.0.0\",\n    \"remark-gfm\": \"^4.0.1\",\n    \"remark-mdx\": \"^3.1.0\",\n    \"remark-mdx-frontmatter\": \"^5.1.0\",\n    \"remark-parse\": \"^11.0.0\",\n    \"remark-rehype\": \"^11.1.2\",\n    \"remark-stringify\": \"^11.0.0\",\n    \"sax\": \"^1.4.1\",\n    \"srt-parser-2\": \"^1.2.3\",\n    \"unified\": \"^11.0.5\",\n    \"unist-util-visit\": \"^5.0.0\",\n    \"vfile\": \"^6.0.3\",\n    \"xliff\": \"^6.2.1\",\n    \"xml2js\": \"^0.6.2\",\n    \"xpath\": \"^0.0.34\",\n    \"yaml\": \"^2.7.0\",\n    \"zod\": \"^3.25.76\"\n  },\n  \"devDependencies\": {\n    \"@types/babel__generator\": \"^7.27.0\",\n    \"@types/chokidar\": \"^2.1.7\",\n    \"@types/cli-progress\": \"^3.11.6\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/diff\": \"^7.0.0\",\n    \"@types/express\": \"^5.0.3\",\n    \"@types/figlet\": \"^1.7.0\",\n    \"@types/gettext-parser\": \"^4.0.4\",\n    \"@types/glob\": \"^8.1.0\",\n    \"@types/ini\": \"^4.1.1\",\n    \"@types/is-url\": \"^1.2.32\",\n    \"@types/jsdom\": \"^21.1.7\",\n    \"@types/lodash\": \"^4.17.16\",\n    \"@types/mdast\": \"^4.0.4\",\n    \"@types/node\": \"^22.10.2\",\n    \"@types/node-gettext\": \"^3.0.6\",\n    \"@types/object-hash\": \"^3.0.6\",\n    \"@types/plist\": \"^3.0.5\",\n    \"@types/react\": \"^18.3.20\",\n    \"@types/xml2js\": \"^0.4.14\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.1.2\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"packageManager\": \"pnpm@9.12.3\"\n}\n","import { Command } from \"interactive-commander\";\nimport _ from \"lodash\";\nimport Ora from \"ora\";\nimport { getConfig } from \"../utils/config\";\nimport { getBuckets } from \"../utils/buckets\";\nimport { resolveOverriddenLocale } from \"@lingo.dev/_spec\";\nimport createBucketLoader from \"../loaders\";\nimport { minimatch } from \"minimatch\";\nimport { confirm } from \"@inquirer/prompts\";\n\ninterface PurgeOptions {\n  bucket?: string[];\n  file?: string[];\n  key?: string;\n  locale?: string[];\n  yesReally?: boolean;\n}\n\nexport default new Command()\n  .command(\"purge\")\n  .description(\n    \"WARNING: Permanently delete translation entries from bucket path patterns defined in i18n.json. This is a destructive operation that cannot be undone. Without any filters, ALL managed keys will be removed from EVERY target locale.\",\n  )\n  .helpOption(\"-h, --help\", \"Show help\")\n  .option(\n    \"--bucket <bucket>\",\n    \"Limit the purge to specific bucket types defined under `buckets` in i18n.json. Repeat the flag to include multiple bucket types. Defaults to all buckets\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--file [files...]\",\n    \"Filter which file paths to purge by matching against path patterns. Only paths containing any of these values will be processed. Examples: --file messages.json --file admin/\",\n  )\n  .option(\n    \"--key <key>\",\n    \"Filter which keys to delete using prefix matching on dot-separated key paths. Example: 'auth.login' matches all keys starting with auth.login. Omit this option to delete ALL keys. Keys marked as locked or ignored in i18n.json are automatically skipped\",\n    (val: string) => encodeURIComponent(val),\n  )\n  .option(\n    \"--locale <locale>\",\n    \"Limit purging to specific target locale codes from i18n.json. Repeat the flag to include multiple locales. Defaults to all configured target locales. Warning: Including the source locale will delete content from it as well.\",\n    (val: string, prev: string[]) => (prev ? [...prev, val] : [val]),\n  )\n  .option(\n    \"--yes-really\",\n    \"Bypass safety confirmations for destructive operations. Use with extreme caution - this will delete translation keys without asking for confirmation. Intended for automated scripts and CI environments only.\",\n  )\n  .action(async function (options: PurgeOptions) {\n    const ora = Ora();\n    try {\n      ora.start(\"Loading configuration...\");\n      const i18nConfig = getConfig();\n      if (!i18nConfig) {\n        throw new Error(\"i18n.json not found. Please run `lingo.dev init`.\");\n      }\n      ora.succeed(\"Configuration loaded\");\n\n      let buckets = getBuckets(i18nConfig);\n      if (options.bucket && options.bucket.length) {\n        buckets = buckets.filter((bucket) =>\n          options.bucket!.includes(bucket.type),\n        );\n      }\n      if (options.file && options.file.length) {\n        buckets = buckets\n          .map((bucket) => {\n            const paths = bucket.paths.filter((bucketPath) =>\n              options.file?.some((f) => bucketPath.pathPattern.includes(f)),\n            );\n            return { ...bucket, paths };\n          })\n          .filter((bucket) => bucket.paths.length > 0);\n        if (buckets.length === 0) {\n          ora.fail(\"All files were filtered out by --file option.\");\n          process.exit(1);\n        }\n      }\n      const sourceLocale = i18nConfig.locale.source;\n      const targetLocales =\n        options.locale && options.locale.length\n          ? options.locale\n          : i18nConfig.locale.targets;\n      let removedAny = false;\n      for (const bucket of buckets) {\n        console.log();\n        ora.info(`Processing bucket: ${bucket.type}`);\n        for (const bucketPath of bucket.paths) {\n          for (const _targetLocale of targetLocales) {\n            const targetLocale = resolveOverriddenLocale(\n              _targetLocale,\n              bucketPath.delimiter,\n            );\n            const bucketOra = Ora({ indent: 2 }).start(\n              `Processing path: ${bucketPath.pathPattern} [${targetLocale}]`,\n            );\n            try {\n              const bucketLoader = createBucketLoader(\n                bucket.type,\n                bucketPath.pathPattern,\n                {\n                  defaultLocale: sourceLocale,\n                  injectLocale: bucket.injectLocale,\n                  formatter: i18nConfig!.formatter,\n                },\n                bucket.lockedKeys,\n                bucket.lockedPatterns,\n                bucket.ignoredKeys,\n              );\n              await bucketLoader.init();\n              bucketLoader.setDefaultLocale(sourceLocale);\n              await bucketLoader.pull(sourceLocale);\n              let targetData = await bucketLoader.pull(targetLocale);\n              if (!targetData || Object.keys(targetData).length === 0) {\n                bucketOra.info(\n                  `No translations found for ${bucketPath.pathPattern} [${targetLocale}]`,\n                );\n                continue;\n              }\n              let newData = { ...targetData };\n              let keysToRemove: string[] = [];\n              if (options.key) {\n                // minimatch for key patterns\n                keysToRemove = Object.keys(newData).filter((k) =>\n                  minimatch(k, options.key!),\n                );\n              } else {\n                // No key specified: remove all keys\n                keysToRemove = Object.keys(newData);\n              }\n              if (keysToRemove.length > 0) {\n                // Show what will be deleted\n                if (options.key) {\n                  bucketOra.info(\n                    `About to delete ${keysToRemove.length} key(s) matching '${options.key}' from ${bucketPath.pathPattern} [${targetLocale}]:\\n  ${keysToRemove.slice(0, 10).join(\", \")}${keysToRemove.length > 10 ? \", ...\" : \"\"}`,\n                  );\n                } else {\n                  bucketOra.info(\n                    `About to delete all (${keysToRemove.length}) keys from ${bucketPath.pathPattern} [${targetLocale}]`,\n                  );\n                }\n\n                if (!options.yesReally) {\n                  bucketOra.warn(\n                    \"This is a destructive operation. If you are sure, type 'y' to continue. (Use --yes-really to skip this check.)\",\n                  );\n                  const confirmed = await confirm({\n                    message: `Delete these keys from ${bucketPath.pathPattern} [${targetLocale}]?`,\n                    default: false,\n                  });\n                  if (!confirmed) {\n                    bucketOra.info(\"Skipped by user.\");\n                    continue;\n                  }\n                }\n                for (const key of keysToRemove) {\n                  delete newData[key];\n                }\n                removedAny = true;\n                await bucketLoader.push(targetLocale, newData);\n                if (options.key) {\n                  bucketOra.succeed(\n                    `Removed ${keysToRemove.length} key(s) matching '${options.key}' from ${bucketPath.pathPattern} [${targetLocale}]`,\n                  );\n                } else {\n                  bucketOra.succeed(\n                    `Removed all keys (${keysToRemove.length}) from ${bucketPath.pathPattern} [${targetLocale}]`,\n                  );\n                }\n              } else if (options.key) {\n                bucketOra.info(\n                  `No keys matching '${options.key}' found in ${bucketPath.pathPattern} [${targetLocale}]`,\n                );\n              } else {\n                bucketOra.info(\"No keys to remove.\");\n              }\n            } catch (error) {\n              const err = error as Error;\n              bucketOra.fail(`Failed: ${err.message}`);\n            }\n          }\n        }\n      }\n      if (!removedAny) {\n        ora.info(\"No keys were removed.\");\n      } else {\n        ora.succeed(\"Purge completed.\");\n      }\n    } catch (error) {\n      const err = error as Error;\n      ora.fail(err.message);\n      process.exit(1);\n    }\n  });\n"],"mappings":"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","names":["InteractiveCommand","figlet","vice","defaults","Command","Ora","readline","Command","Ora","readline","Command","Ora","Command","Ora","Ora","fs","path","resolveLocaleCode","fs","path","_","checkbox","confirm","path","_","ext","match","fs","path","ext","fs","path","fs","path","open","path","resolveLocaleCode","value","fs","Ora","_","checkbox","confirm","auth","Command","Command","_","fs","path","defaultConfig","Command","Ora","Command","Ora","Command","Ora","_","path","glob","_","path","glob","match","resolveOverriddenLocale","Command","Ora","path","Command","Ora","resolveOverriddenLocale","input","input","input","path","input","_","input","fs","path","_","path","fs","input","input","_","input","_","require","input","match","parse","_","parse","input","_","input","path","YAML","YAML","input","YAML","FM_ATTR_PREFIX","input","YAML","path","_","input","input","_","input","_","input","match","_","input","_","input","_","path","path","path","fs","path","fs","_","input","_","JSDOM","input","match","indent","parseStringPromise","input","parseStringPromise","input","fs","JSON5","Z","_","input","_","_","_","_","input","_","input","_","path","fs","JSON5","input","_","input","_","match","_","input","_","indent","items","match","input","jsonrepair","input","match","jsonrepair","parse","_","input","_","parse","path","_","z","glob","i","acc","ext","glob","_","start","final","ext","path","qmark","star","regExpEscape","_","open","_","path","_","_","matter","YAML","input","yamlEngine","YAML","matter","input","_","match","input","input","_","input","match","input","_","_","input","match","_","input","_","input","_","_","input","_","path","resolveOverriddenLocale","Command","Ora","Command","Ora","Command","Ora","Command","Command","Command","chalk","_","Command","chalk","_","Command","chalk","dedent","_","Command","dedent","chalk","_","Command","chalk","_","dedent","Command","chalk","_","config_default","Command","resolveOverriddenLocale","Command","Z","_","Ora","chalk","inquirer","chalk","dedent","input","_","input","result","dedent","chalk","_","fs","path","path","YAML","_","Command","Ora","inquirer","path","resolveOverriddenLocale","_","deltaProcessor","checksums","Z","chalk","Command","Z","Ora","fs","path","Z","YAML","MD5","_","resolveOverriddenLocale","Command","Ora","resolveOverriddenLocale","Z","resolveOverriddenLocale","Command","_","Ora","Command","Ora","resolveOverriddenLocale","_","Command","Z","Command","_","Z","Command","execSync","path","Command","path","os","chalk","chalk","chalk","dedent","chalk","LingoDotDevEngine","dedent","chalk","LingoDotDevEngine","input","createAnthropic","createGoogleGenerativeAI","createOpenAI","createOpenRouter","createMistral","chalk","dedent","generateText","jsonrepair","createOllama","dedent","chalk","createOpenAI","createAnthropic","createGoogleGenerativeAI","createOpenRouter","createMistral","generateText","input","input","chalk","chalk","Listr","resolveOverriddenLocale","input","chalk","Listr","resolveOverriddenLocale","chalk","Listr","_","input","chalk","Listr","_","t","chalk","watch","chalk","path","bucketTypeSchema","z","flagsSchema","chalk","Listr","_","resolveOverriddenLocale","input","chalk","Listr","_","path","os","Command","flagsSchema","watch","path","execSync","error","execSync","Z","execSync","Z","execSync","Z","Z","Z","Z","Command","bucketTypeSchema","localeCodeSchema","resolveOverriddenLocale","Command","Z","Ora","chalk","Command","Ora","parseFlags","validateParams","path","resolveOverriddenLocale","chalk","Z","localeCodeSchema","bucketTypeSchema","Command","figlet","chalk","vice","colors","renderClear","renderBanner","renderSpacer","renderHero","Command","Ora","resolveOverriddenLocale","confirm","Command","Ora","resolveOverriddenLocale","InteractiveCommand","vice","figlet","config_default"]}