var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/_base.ts
import generate from "@babel/generator";
import * as parser from "@babel/parser";
function createCodeMutation(spec) {
  return (payload) => {
    const result = spec(payload);
    return result;
  };
}
function createPayload(input) {
  const ast = parser.parse(input.code, {
    sourceType: "module",
    plugins: ["jsx", "typescript"]
  });
  return {
    ...input,
    ast
  };
}
function createOutput(payload) {
  const generationResult = generate(payload.ast, {}, payload.code);
  return {
    code: generationResult.code,
    map: generationResult.map
  };
}
function composeMutations(...mutations) {
  return (input) => {
    let result = input;
    for (const mutate of mutations) {
      const intermediateResult = mutate(result);
      if (!intermediateResult) {
        break;
      } else {
        result = intermediateResult;
      }
    }
    return result;
  };
}
var defaultParams = {
  sourceRoot: "src",
  lingoDir: "lingo",
  sourceLocale: "en",
  targetLocales: ["es"],
  rsc: false,
  useDirective: false,
  debug: false,
  models: {},
  prompt: null
};

// src/_const.ts
var ModuleId = {
  ReactClient: ["lingo.dev/react/client", "lingo.dev/react-client"],
  ReactRSC: ["lingo.dev/react/rsc", "lingo.dev/react-rsc"],
  ReactRouter: ["lingo.dev/react/react-router", "lingo.dev/react-router"]
};
var LCP_DICTIONARY_FILE_NAME = "dictionary.js";

// src/lib/lcp/cache.ts
import * as fs from "fs";
import * as path from "path";
import * as prettier from "prettier";
import _ from "lodash";
var LCPCache = class {
  // make sure the cache file exists, otherwise imports will fail
  static ensureDictionaryFile(params) {
    const cachePath = this._getCachePath(params);
    if (!fs.existsSync(cachePath)) {
      const dir = path.dirname(cachePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(cachePath, "export default {};");
    }
  }
  // read cache entries for given locale, validate entry hash from LCP schema
  static readLocaleDictionary(locale, params) {
    const cache = this._read(params);
    const dictionary = this._extractLocaleDictionary(cache, locale, params.lcp);
    return dictionary;
  }
  // write cache entries for given locale to existing cache file, use hash from LCP schema
  static async writeLocaleDictionary(dictionary, params) {
    const currentCache = this._read(params);
    const newCache = this._mergeLocaleDictionary(
      currentCache,
      dictionary,
      params.lcp
    );
    await this._write(newCache, params);
  }
  // merge dictionary with current cache, sort files, entries and locales to minimize diffs
  static _mergeLocaleDictionary(currentCache, dictionary, lcp) {
    const files = _(dictionary.files).mapValues((file, fileName) => ({
      ...file,
      entries: _(file.entries).mapValues((entry, entryName) => {
        const cachedEntry = _.get(currentCache, ["files", fileName, "entries", entryName]) ?? {};
        const hash = _.get(lcp, [
          "files",
          fileName,
          "scopes",
          entryName,
          "hash"
        ]);
        const cachedEntryContent = cachedEntry.hash === hash ? cachedEntry.content : {};
        const content = _({
          ...cachedEntryContent,
          [dictionary.locale]: entry
        }).toPairs().sortBy([0]).fromPairs().value();
        return { content, hash };
      }).toPairs().sortBy([0]).fromPairs().value()
    })).toPairs().sortBy([0]).fromPairs().value();
    const newCache = {
      version: dictionary.version,
      files
    };
    return newCache;
  }
  // extract dictionary from cache for given locale, validate entry hash from LCP schema
  static _extractLocaleDictionary(cache, locale, lcp) {
    const findCachedEntry = (hash) => {
      const cachedEntry = _(cache.files).flatMap((file) => _.values(file.entries)).find((entry) => entry.hash === hash);
      if (cachedEntry) {
        return cachedEntry.content[locale];
      }
      return void 0;
    };
    const files = _(lcp.files).mapValues((file) => {
      return {
        entries: _(file.scopes).mapValues((entry) => {
          return findCachedEntry(entry.hash);
        }).pickBy((value) => value !== void 0).value()
      };
    }).pickBy((file) => !_.isEmpty(file.entries)).value();
    const dictionary = {
      version: cache.version,
      locale,
      files
    };
    return dictionary;
  }
  // format with prettier
  static async _format(cachedContent, cachePath) {
    try {
      const config2 = await prettier.resolveConfig(cachePath);
      const prettierOptions = {
        ...config2 ?? {},
        parser: config2?.parser ? config2.parser : "typescript"
      };
      return await prettier.format(cachedContent, prettierOptions);
    } catch (error) {
    }
    return cachedContent;
  }
  // write cache to file as JSON
  static async _write(dictionaryCache, params) {
    const cachePath = this._getCachePath(params);
    const cache = `export default ${JSON.stringify(dictionaryCache, null, 2)};`;
    const formattedCache = await this._format(cache, cachePath);
    fs.writeFileSync(cachePath, formattedCache);
  }
  // read cache from file as JSON
  static _read(params) {
    const cachePath = this._getCachePath(params);
    if (!fs.existsSync(cachePath)) {
      return {
        version: 0.1,
        files: {}
      };
    }
    const jsObjectString = fs.readFileSync(cachePath, "utf8");
    const cache = jsObjectString.replace(/^export default/, "").replace(/;\s*$/, "");
    const obj = new Function(`return (${cache})`)();
    return obj;
  }
  // get cache file path
  static _getCachePath(params) {
    return path.resolve(
      process.cwd(),
      params.sourceRoot,
      params.lingoDir,
      LCP_DICTIONARY_FILE_NAME
    );
  }
};

// src/utils/locales.ts
function getInvalidLocales(localeModels, sourceLocale, targetLocales) {
  return targetLocales.filter((targetLocale) => {
    const { provider, model } = getLocaleModel(
      localeModels,
      sourceLocale,
      targetLocale
    );
    return provider === void 0 || model === void 0;
  });
}
function getLocaleModel(localeModels, sourceLocale, targetLocale) {
  const localeKeys = [
    `${sourceLocale}:${targetLocale}`,
    `*:${targetLocale}`,
    `${sourceLocale}:*`,
    "*:*"
  ];
  const modelKey = localeKeys.find((key) => localeModels.hasOwnProperty(key));
  if (modelKey) {
    const value = localeModels[modelKey];
    const firstColonIndex = value?.indexOf(":");
    if (value && firstColonIndex !== -1 && firstColonIndex !== void 0) {
      const provider2 = value.substring(0, firstColonIndex);
      const model2 = value.substring(firstColonIndex + 1);
      if (provider2 && model2) {
        return { provider: provider2, model: model2 };
      }
    }
    const [provider, model] = value?.split(":") || [];
    if (provider && model) {
      return { provider, model };
    }
  }
  return { provider: void 0, model: void 0 };
}

// src/utils/rc.ts
import os from "os";
import path2 from "path";
import fs2 from "fs";
import Ini from "ini";
function getRc() {
  const settingsFile = ".lingodotdevrc";
  const homedir = os.homedir();
  const settingsFilePath = path2.join(homedir, settingsFile);
  const content = fs2.existsSync(settingsFilePath) ? fs2.readFileSync(settingsFilePath, "utf-8") : "";
  const data = Ini.parse(content);
  return data;
}

// src/utils/llm-api-key.ts
import _2 from "lodash";
import * as dotenv from "dotenv";
import path3 from "path";
function getKeyFromEnv(envVarName) {
  if (process.env[envVarName]) {
    return process.env[envVarName];
  }
  const result = dotenv.config({
    path: [
      path3.resolve(process.cwd(), ".env"),
      path3.resolve(process.cwd(), ".env.local"),
      path3.resolve(process.cwd(), ".env.development")
    ]
  });
  return result?.parsed?.[envVarName];
}
function getKeyFromRc(rcPath) {
  const rc = getRc();
  const result = _2.get(rc, rcPath);
  return typeof result === "string" ? result : void 0;
}
function getGroqKey() {
  return getGroqKeyFromEnv() || getGroqKeyFromRc();
}
function getGroqKeyFromRc() {
  return getKeyFromRc("llm.groqApiKey");
}
function getGroqKeyFromEnv() {
  return getKeyFromEnv("GROQ_API_KEY");
}
function getLingoDotDevKeyFromEnv() {
  return getKeyFromEnv("LINGODOTDEV_API_KEY");
}
function getLingoDotDevKeyFromRc() {
  return getKeyFromRc("auth.apiKey");
}
function getLingoDotDevKey() {
  return getLingoDotDevKeyFromEnv() || getLingoDotDevKeyFromRc();
}
function getGoogleKey() {
  return getGoogleKeyFromEnv() || getGoogleKeyFromRc();
}
function getGoogleKeyFromRc() {
  return getKeyFromRc("llm.googleApiKey");
}
function getGoogleKeyFromEnv() {
  return getKeyFromEnv("GOOGLE_API_KEY");
}
function getOpenRouterKey() {
  return getOpenRouterKeyFromEnv() || getOpenRouterKeyFromRc();
}
function getOpenRouterKeyFromRc() {
  return getKeyFromRc("llm.openrouterApiKey");
}
function getOpenRouterKeyFromEnv() {
  return getKeyFromEnv("OPENROUTER_API_KEY");
}
function getMistralKey() {
  return getMistralKeyFromEnv() || getMistralKeyFromRc();
}
function getMistralKeyFromRc() {
  return getKeyFromRc("llm.mistralApiKey");
}
function getMistralKeyFromEnv() {
  return getKeyFromEnv("MISTRAL_API_KEY");
}

// src/utils/env.ts
import fs3 from "fs";
function isRunningInCIOrDocker() {
  return Boolean(process.env.CI) || fs3.existsSync("/.dockerenv");
}

// src/lib/lcp/api/provider-details.ts
var providerDetails = {
  groq: {
    name: "Groq",
    apiKeyEnvVar: "GROQ_API_KEY",
    apiKeyConfigKey: "llm.groqApiKey",
    getKeyLink: "https://groq.com",
    docsLink: "https://console.groq.com/docs/errors"
  },
  google: {
    name: "Google",
    apiKeyEnvVar: "GOOGLE_API_KEY",
    apiKeyConfigKey: "llm.googleApiKey",
    getKeyLink: "https://ai.google.dev/",
    docsLink: "https://ai.google.dev/gemini-api/docs/troubleshooting"
  },
  openrouter: {
    name: "OpenRouter",
    apiKeyEnvVar: "OPENROUTER_API_KEY",
    apiKeyConfigKey: "llm.openrouterApiKey",
    getKeyLink: "https://openrouter.ai",
    docsLink: "https://openrouter.ai/docs"
  },
  ollama: {
    name: "Ollama",
    apiKeyEnvVar: void 0,
    // Ollama doesn't require an API key
    apiKeyConfigKey: void 0,
    // Ollama doesn't require an API key
    getKeyLink: "https://ollama.com/download",
    docsLink: "https://github.com/ollama/ollama/tree/main/docs"
  },
  mistral: {
    name: "Mistral",
    apiKeyEnvVar: "MISTRAL_API_KEY",
    apiKeyConfigKey: "llm.mistralApiKey",
    getKeyLink: "https://console.mistral.ai",
    docsLink: "https://docs.mistral.ai"
  },
  "lingo.dev": {
    name: "Lingo.dev",
    apiKeyEnvVar: "LINGODOTDEV_API_KEY",
    apiKeyConfigKey: "auth.apiKey",
    getKeyLink: "https://lingo.dev",
    docsLink: "https://lingo.dev/docs"
  }
};

// src/_loader-utils.ts
import _11 from "lodash";
import path6 from "path";

// src/utils/index.ts
import traverse from "@babel/traverse";
import * as t2 from "@babel/types";

// src/utils/jsx-attribute.ts
import * as t from "@babel/types";
import _3 from "lodash";
function getJsxAttributesMap(nodePath) {
  const attributes = nodePath.node.openingElement.attributes;
  return _3.reduce(
    attributes,
    (result, attr) => {
      if (attr.type !== "JSXAttribute" || attr.name.type !== "JSXIdentifier") {
        return result;
      }
      const name = attr.name.name;
      const value = extractAttributeValue(attr);
      return { ...result, [name]: value };
    },
    {}
  );
}
function getJsxAttributeValue(nodePath, attributeName) {
  const attributes = nodePath.node.openingElement.attributes;
  const attribute = _3.find(
    attributes,
    (attr) => attr.type === "JSXAttribute" && attr.name.type === "JSXIdentifier" && attr.name.name === attributeName
  );
  if (!attribute) {
    return void 0;
  }
  return extractAttributeValue(attribute);
}
function setJsxAttributeValue(nodePath, attributeName, value) {
  const attributes = nodePath.node.openingElement.attributes;
  const attributeIndex = _3.findIndex(
    attributes,
    (attr) => attr.type === "JSXAttribute" && attr.name.type === "JSXIdentifier" && attr.name.name === attributeName
  );
  const jsxValue = createAttributeValue(value);
  const jsxAttribute7 = t.jsxAttribute(t.jsxIdentifier(attributeName), jsxValue);
  if (attributeIndex >= 0) {
    attributes[attributeIndex] = jsxAttribute7;
  } else {
    attributes.push(jsxAttribute7);
  }
}
function extractAttributeValue(attribute) {
  if (!attribute.value) {
    return true;
  }
  if (attribute.value.type === "StringLiteral") {
    return attribute.value.value;
  }
  if (attribute.value.type === "JSXExpressionContainer") {
    const expression = attribute.value.expression;
    if (expression.type === "BooleanLiteral") {
      return expression.value;
    }
    if (expression.type === "NumericLiteral") {
      return expression.value;
    }
    if (expression.type === "StringLiteral") {
      return expression.value;
    }
  }
  return null;
}
function createAttributeValue(value) {
  if (value === null || value === void 0) {
    return null;
  }
  if (typeof value === "string") {
    return t.stringLiteral(value);
  }
  if (typeof value === "boolean") {
    return t.jsxExpressionContainer(t.booleanLiteral(value));
  }
  if (typeof value === "number") {
    return t.jsxExpressionContainer(t.numericLiteral(value));
  }
  if (t.isExpression(value)) {
    return t.jsxExpressionContainer(value);
  }
  return t.jsxExpressionContainer(t.stringLiteral(JSON.stringify(value)));
}

// src/utils/index.ts
function getJsxRoots(node) {
  const result = [];
  traverse(node, {
    JSXElement(path7) {
      result.push(path7);
      path7.skip();
    }
  });
  return result;
}
function getOrCreateImport(ast, params) {
  let importedName = params.exportedName;
  let existingImport = findExistingImport(
    ast,
    params.exportedName,
    params.moduleName
  );
  if (existingImport) {
    return { importedName: existingImport };
  }
  importedName = generateUniqueImportName(ast, params.exportedName);
  createImportDeclaration(
    ast,
    importedName,
    params.exportedName,
    params.moduleName
  );
  return { importedName };
}
function findExistingImport(ast, exportedName, moduleName) {
  let result = null;
  traverse(ast, {
    ImportDeclaration(path7) {
      if (!moduleName.includes(path7.node.source.value)) {
        return;
      }
      if (path7.node.importKind === "type") {
        return;
      }
      for (const specifier of path7.node.specifiers) {
        if (t2.isImportSpecifier(specifier) && // Skip type-only specifiers as they can't be used at runtime
        specifier.importKind !== "type" && (t2.isIdentifier(specifier.imported) && specifier.imported.name === exportedName || specifier.importKind === "value" && t2.isIdentifier(specifier.local) && specifier.local.name === exportedName)) {
          result = specifier.local.name;
          path7.stop();
          return;
        }
        if (t2.isImportDefaultSpecifier(specifier)) {
          result = `${specifier.local.name}.${exportedName}`;
          path7.stop();
          return;
        }
        if (t2.isImportNamespaceSpecifier(specifier)) {
          result = `${specifier.local.name}.${exportedName}`;
          path7.stop();
          return;
        }
      }
    }
  });
  return result;
}
function generateUniqueImportName(ast, baseName) {
  const usedNames = /* @__PURE__ */ new Set();
  traverse(ast, {
    Identifier(path7) {
      usedNames.add(path7.node.name);
    }
  });
  if (!usedNames.has(baseName)) {
    return baseName;
  }
  let counter = 1;
  let candidateName = `${baseName}${counter}`;
  while (usedNames.has(candidateName)) {
    counter++;
    candidateName = `${baseName}${counter}`;
  }
  return candidateName;
}
function createImportDeclaration(ast, localName, exportedName, moduleName) {
  traverse(ast, {
    Program(path7) {
      const importSpecifier2 = t2.importSpecifier(
        t2.identifier(localName),
        t2.identifier(exportedName)
      );
      const existingImport = path7.get("body").find(
        (nodePath) => t2.isImportDeclaration(nodePath.node) && moduleName.includes(nodePath.node.source.value) && nodePath.node.importKind !== "type"
      );
      if (existingImport && t2.isImportDeclaration(existingImport.node)) {
        existingImport.node.specifiers.push(importSpecifier2);
      } else {
        const importDeclaration2 = t2.importDeclaration(
          [importSpecifier2],
          t2.stringLiteral(moduleName[0])
        );
        const lastImportIndex = findLastImportIndex(path7);
        path7.node.body.splice(lastImportIndex + 1, 0, importDeclaration2);
      }
      path7.stop();
    }
  });
}
function findLastImportIndex(programPath) {
  const body = programPath.node.body;
  for (let i = body.length - 1; i >= 0; i--) {
    if (t2.isImportDeclaration(body[i])) {
      return i;
    }
  }
  return -1;
}
function _hasFileDirective(ast, directiveValue) {
  let hasDirective = false;
  traverse(ast, {
    Directive(path7) {
      if (path7.node.value.value === directiveValue) {
        hasDirective = true;
        path7.stop();
      }
    }
  });
  return hasDirective;
}
function hasI18nDirective(ast) {
  return _hasFileDirective(ast, "use i18n");
}
function hasClientDirective(ast) {
  return _hasFileDirective(ast, "use client");
}
function getModuleExecutionMode(ast, rscEnabled) {
  if (rscEnabled) {
    if (hasClientDirective(ast)) {
      return "client";
    } else {
      return "server";
    }
  } else {
    return "client";
  }
}

// src/utils/invokations.ts
import * as t3 from "@babel/types";
import traverse2 from "@babel/traverse";
function findInvokations(ast, params) {
  const result = [];
  traverse2(ast, {
    ImportDeclaration(path7) {
      if (!params.moduleName.includes(path7.node.source.value)) return;
      const importNames = /* @__PURE__ */ new Map();
      const specifiers = path7.node.specifiers;
      specifiers.forEach((specifier) => {
        if (t3.isImportSpecifier(specifier) && t3.isIdentifier(specifier.imported) && specifier.imported.name === params.functionName) {
          importNames.set(specifier.local.name, true);
        } else if (t3.isImportDefaultSpecifier(specifier) && params.functionName === "default") {
          importNames.set(specifier.local.name, true);
        } else if (t3.isImportNamespaceSpecifier(specifier)) {
          importNames.set(specifier.local.name, "namespace");
        }
      });
      collectCallExpressions(path7, importNames, result, params.functionName);
    }
  });
  return result;
}
function collectCallExpressions(path7, importNames, result, functionName) {
  const program = path7.findParent(
    (p) => p.isProgram()
  );
  if (!program) return;
  program.traverse({
    CallExpression(callPath) {
      const callee = callPath.node.callee;
      if (t3.isIdentifier(callee) && importNames.has(callee.name)) {
        result.push(callPath.node);
      } else if (t3.isMemberExpression(callee) && t3.isIdentifier(callee.object) && importNames.get(callee.object.name) === "namespace" && t3.isIdentifier(callee.property) && callee.property.name === functionName) {
        result.push(callPath.node);
      }
    }
  });
}

// src/client-dictionary-loader.ts
import * as t5 from "@babel/types";

// src/_utils.ts
import path4 from "path";
var getDictionaryPath = (params) => {
  const toFile = path4.resolve(
    params.sourceRoot,
    params.lingoDir,
    LCP_DICTIONARY_FILE_NAME
  );
  const fromDir = path4.dirname(
    path4.resolve(params.sourceRoot, params.relativeFilePath)
  );
  const relativePath = path4.relative(fromDir, toFile);
  const normalizedPath = relativePath.split(path4.sep).join(path4.posix.sep);
  return `./${normalizedPath}`;
};

// src/utils/create-locale-import-map.ts
import * as t4 from "@babel/types";
function createLocaleImportMap(allLocales, dictionaryPath) {
  return t4.objectExpression(
    allLocales.map(
      (locale) => t4.objectProperty(
        t4.stringLiteral(locale),
        t4.arrowFunctionExpression(
          [],
          t4.callExpression(t4.identifier("import"), [
            t4.stringLiteral(`${dictionaryPath}?locale=${locale}`)
          ])
        )
      )
    )
  );
}

// src/client-dictionary-loader.ts
var clientDictionaryLoaderMutation = createCodeMutation((payload) => {
  const invokations = findInvokations(payload.ast, {
    moduleName: ModuleId.ReactClient,
    functionName: "loadDictionary"
  });
  const allLocales = Array.from(
    /* @__PURE__ */ new Set([payload.params.sourceLocale, ...payload.params.targetLocales])
  );
  for (const invokation of invokations) {
    const internalDictionaryLoader = getOrCreateImport(payload.ast, {
      moduleName: ModuleId.ReactClient,
      exportedName: "loadDictionary_internal"
    });
    if (t5.isIdentifier(invokation.callee)) {
      invokation.callee.name = internalDictionaryLoader.importedName;
    }
    const dictionaryPath = getDictionaryPath({
      sourceRoot: payload.params.sourceRoot,
      lingoDir: payload.params.lingoDir,
      relativeFilePath: payload.relativeFilePath
    });
    const localeImportMap = createLocaleImportMap(allLocales, dictionaryPath);
    invokation.arguments.push(localeImportMap);
  }
  return payload;
});

// src/i18n-directive.ts
var i18nDirectiveMutation = createCodeMutation((payload) => {
  if (!payload.params.useDirective || hasI18nDirective(payload.ast)) {
    return payload;
  } else {
    return null;
  }
});
var i18n_directive_default = i18nDirectiveMutation;

// src/jsx-attribute-flag.ts
import * as t8 from "@babel/types";

// src/utils/jsx-attribute-scope.ts
import * as t6 from "@babel/types";
import traverse3 from "@babel/traverse";
function collectJsxAttributeScopes(node) {
  const result = [];
  traverse3(node, {
    JSXElement(path7) {
      if (!hasJsxAttributeScopeAttribute(path7)) return;
      const localizableAttributes = getJsxAttributeScopeAttribute(path7);
      if (!localizableAttributes) return;
      result.push([path7, localizableAttributes]);
    }
  });
  return result;
}
function getJsxAttributeScopes(node) {
  const result = [];
  const LOCALIZABLE_ATTRIBUTES = [
    "title",
    "aria-label",
    "aria-description",
    "alt",
    "label",
    "description",
    "placeholder",
    "content",
    "subtitle"
  ];
  traverse3(node, {
    JSXElement(path7) {
      const openingElement = path7.node.openingElement;
      const elementName = openingElement.name;
      if (!t6.isJSXIdentifier(elementName) || !elementName.name) {
        return;
      }
      const hasAttributeScope = openingElement.attributes.find(
        (attr) => t6.isJSXAttribute(attr) && attr.name.name === "data-jsx-attribute-scope"
      );
      if (hasAttributeScope) {
        return;
      }
      const localizableAttrs = openingElement.attributes.filter(
        (attr) => {
          if (!t6.isJSXAttribute(attr) || !t6.isStringLiteral(attr.value)) {
            return false;
          }
          const name = attr.name.name;
          return typeof name === "string" && LOCALIZABLE_ATTRIBUTES.includes(name);
        }
      ).map((attr) => attr.name.name);
      if (localizableAttrs.length > 0) {
        result.push([path7, localizableAttrs]);
      }
    }
  });
  return result;
}
function hasJsxAttributeScopeAttribute(path7) {
  return !!getJsxAttributeScopeAttribute(path7);
}
function getJsxAttributeScopeAttribute(path7) {
  const attribute = path7.node.openingElement.attributes.find(
    (attr) => attr.type === "JSXAttribute" && attr.name.name === "data-jsx-attribute-scope"
  );
  if (!attribute || !t6.isJSXAttribute(attribute)) {
    return void 0;
  }
  if (t6.isJSXExpressionContainer(attribute.value) && t6.isArrayExpression(attribute.value.expression)) {
    const arrayExpr = attribute.value.expression;
    return arrayExpr.elements.filter((el) => t6.isStringLiteral(el)).map((el) => el.value);
  }
  if (t6.isStringLiteral(attribute.value)) {
    return [attribute.value.value];
  }
  return void 0;
}

// src/utils/ast-key.ts
import * as t7 from "@babel/types";
import traverse4 from "@babel/traverse";
function getAstKey(nodePath) {
  const keyChunks = [];
  let current = nodePath;
  while (current) {
    keyChunks.push(current.key);
    current = current.parentPath;
    if (t7.isProgram(current?.node)) {
      break;
    }
  }
  const result = keyChunks.reverse().join("/");
  return result;
}

// src/jsx-attribute-flag.ts
var jsxAttributeFlagMutation = createCodeMutation(
  (payload) => {
    const jsxScopes = getJsxAttributeScopes(payload.ast);
    for (const [jsxScope, attributes] of jsxScopes) {
      const scopeKey = getAstKey(jsxScope);
      jsxScope.node.openingElement.attributes.push(
        t8.jsxAttribute(
          t8.jsxIdentifier("data-jsx-attribute-scope"),
          t8.jsxExpressionContainer(
            t8.arrayExpression(
              attributes.map(
                (attr) => t8.stringLiteral(`${attr}:${scopeKey}-${attr}`)
              )
            )
          )
        )
      );
    }
    return {
      ...payload
    };
  }
);
var jsx_attribute_flag_default = jsxAttributeFlagMutation;

// src/jsx-attribute-scope-inject.ts
import * as t10 from "@babel/types";

// src/utils/jsx-element.ts
import * as t9 from "@babel/types";
function getJsxElementName(nodePath) {
  const openingElement = nodePath.node.openingElement;
  if (t9.isJSXIdentifier(openingElement.name)) {
    return openingElement.name.name;
  }
  if (t9.isJSXMemberExpression(openingElement.name)) {
    const memberExpr = openingElement.name;
    const parts = [];
    let current = memberExpr;
    while (t9.isJSXMemberExpression(current)) {
      parts.unshift(current.property.name);
      current = current.object;
    }
    if (t9.isJSXIdentifier(current)) {
      parts.unshift(current.name);
    }
    return parts.join(".");
  }
  return null;
}
function getNestedJsxElements(nodePath) {
  const nestedElements = [];
  nodePath.traverse({
    JSXElement(path7) {
      if (path7.node !== nodePath.node) {
        nestedElements.push(path7.node);
      }
    }
  });
  const arrayOfElements = nestedElements.map((element, index) => {
    const param = t9.identifier("children");
    const clonedElement = t9.cloneNode(element);
    clonedElement.children = [t9.jsxExpressionContainer(param)];
    return t9.arrowFunctionExpression(
      [t9.objectPattern([t9.objectProperty(param, param, false, true)])],
      clonedElement
    );
  });
  const result = t9.arrayExpression(arrayOfElements);
  return result;
}

// src/jsx-attribute-scope-inject.ts
var lingoJsxAttributeScopeInjectMutation = createCodeMutation(
  (payload) => {
    const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
    const jsxAttributeScopes = collectJsxAttributeScopes(payload.ast);
    for (const [jsxScope, attributes] of jsxAttributeScopes) {
      const packagePath = mode === "client" ? ModuleId.ReactClient : ModuleId.ReactRSC;
      const lingoComponentImport = getOrCreateImport(payload.ast, {
        moduleName: packagePath,
        exportedName: "LingoAttributeComponent"
      });
      const originalJsxElementName = getJsxElementName(jsxScope);
      if (!originalJsxElementName) {
        continue;
      }
      jsxScope.node.openingElement.name = t10.jsxIdentifier(
        lingoComponentImport.importedName
      );
      if (jsxScope.node.closingElement) {
        jsxScope.node.closingElement.name = t10.jsxIdentifier(
          lingoComponentImport.importedName
        );
      }
      const as = /^[A-Z]/.test(originalJsxElementName) ? t10.jsxExpressionContainer(t10.identifier(originalJsxElementName)) : t10.stringLiteral(originalJsxElementName);
      jsxScope.node.openingElement.attributes.push(
        t10.jsxAttribute(t10.jsxIdentifier("$attrAs"), as)
      );
      setJsxAttributeValue(jsxScope, "$fileKey", payload.relativeFilePath);
      setJsxAttributeValue(
        jsxScope,
        "$attributes",
        t10.objectExpression(
          attributes.map((attributeDefinition) => {
            const [attribute, key = ""] = attributeDefinition.split(":");
            return t10.objectProperty(
              t10.stringLiteral(attribute),
              t10.stringLiteral(key)
            );
          })
        )
      );
      if (mode === "server") {
        const loadDictionaryImport = getOrCreateImport(payload.ast, {
          exportedName: "loadDictionary",
          moduleName: ModuleId.ReactRSC
        });
        setJsxAttributeValue(
          jsxScope,
          "$loadDictionary",
          t10.arrowFunctionExpression(
            [t10.identifier("locale")],
            t10.callExpression(t10.identifier(loadDictionaryImport.importedName), [
              t10.identifier("locale")
            ])
          )
        );
      }
    }
    return payload;
  }
);

// src/lib/lcp/index.ts
import * as fs4 from "fs";
import _4 from "lodash";
import * as path5 from "path";
import dedent from "dedent";
var LCP_FILE_NAME = "meta.json";
var LCP = class _LCP {
  constructor(filePath, data = {
    version: 0.1
  }) {
    this.filePath = filePath;
    this.data = data;
  }
  static ensureFile(params) {
    const filePath = path5.resolve(
      process.cwd(),
      params.sourceRoot,
      params.lingoDir,
      LCP_FILE_NAME
    );
    if (!fs4.existsSync(filePath)) {
      const dir = path5.dirname(filePath);
      if (!fs4.existsSync(dir)) {
        fs4.mkdirSync(dir, { recursive: true });
      }
      fs4.writeFileSync(filePath, "{}");
      try {
        fs4.rmdirSync(path5.resolve(process.cwd(), ".next"), {
          recursive: true
        });
      } catch (error) {
      }
      throw new Error(dedent`
        âš ï¸  Lingo.dev Compiler detected missing meta.json file in lingo directory.
        Please restart the build / watch command to regenerate all Lingo.dev Compiler files.
      `);
    }
  }
  static getInstance(params) {
    const filePath = path5.resolve(
      process.cwd(),
      params.sourceRoot,
      params.lingoDir,
      LCP_FILE_NAME
    );
    if (fs4.existsSync(filePath)) {
      return new _LCP(filePath, JSON.parse(fs4.readFileSync(filePath, "utf8")));
    }
    return new _LCP(filePath);
  }
  // wait until LCP file stops updating
  // this ensures all files were transformed before loading / translating dictionaries
  static async ready(params) {
    if (params.isDev) {
      _LCP.ensureFile(params);
    }
    const filePath = path5.resolve(
      process.cwd(),
      params.sourceRoot,
      params.lingoDir,
      LCP_FILE_NAME
    );
    if (fs4.existsSync(filePath)) {
      const stats = fs4.statSync(filePath);
      if (Date.now() - stats.mtimeMs > 1500) {
        return;
      }
    }
    return new Promise((resolve3) => {
      setTimeout(() => {
        _LCP.ready(params).then(resolve3);
      }, 750);
    });
  }
  resetScope(fileKey, scopeKey) {
    if (!_4.isObject(
      _4.get(this.data, ["files", fileKey])
    )) {
      _4.set(this.data, ["files", fileKey], {});
    }
    _4.set(
      this.data,
      [
        "files",
        fileKey,
        "scopes",
        scopeKey
      ],
      {}
    );
    return this;
  }
  setScopeType(fileKey, scopeKey, type) {
    return this._setScopeField(fileKey, scopeKey, "type", type);
  }
  setScopeContext(fileKey, scopeKey, context) {
    return this._setScopeField(fileKey, scopeKey, "context", context);
  }
  setScopeHash(fileKey, scopeKey, hash) {
    return this._setScopeField(fileKey, scopeKey, "hash", hash);
  }
  setScopeSkip(fileKey, scopeKey, skip) {
    return this._setScopeField(fileKey, scopeKey, "skip", skip);
  }
  setScopeOverrides(fileKey, scopeKey, overrides) {
    return this._setScopeField(fileKey, scopeKey, "overrides", overrides);
  }
  setScopeContent(fileKey, scopeKey, content) {
    return this._setScopeField(fileKey, scopeKey, "content", content);
  }
  toJSON() {
    const files = _4(this.data?.files).mapValues((file, fileName) => {
      return {
        ...file,
        scopes: _4(file?.scopes).toPairs().sortBy([0]).fromPairs().value()
      };
    }).toPairs().sortBy([0]).fromPairs().value();
    return { ...this.data, files };
  }
  toString() {
    return JSON.stringify(this.toJSON(), null, 2) + "\n";
  }
  save() {
    const hasChanges = !fs4.existsSync(this.filePath) || fs4.readFileSync(this.filePath, "utf8") !== this.toString();
    if (hasChanges) {
      const dir = path5.dirname(this.filePath);
      if (!fs4.existsSync(dir)) {
        fs4.mkdirSync(dir, { recursive: true });
      }
      fs4.writeFileSync(this.filePath, this.toString());
      this._triggerLCPReload();
    }
  }
  _triggerLCPReload() {
    const dir = path5.dirname(this.filePath);
    const filePath = path5.resolve(dir, LCP_DICTIONARY_FILE_NAME);
    if (fs4.existsSync(filePath)) {
      try {
        const now = Math.floor(Date.now() / 1e3);
        fs4.utimesSync(filePath, now, now);
      } catch (error) {
        if (error?.code === "EINVAL") {
          console.warn(
            dedent`
              âš ï¸  Lingo: Auto-reload disabled - system blocks Node.js timestamp updates.
                  ðŸ’¡ Fix: Adjust security settings to allow Node.js file modifications.
                  âš¡  Workaround: Manually refresh browser after translation changes.
                  ðŸ’¬ Need help? Join our Discord: https://lingo.dev/go/discord.
            `
          );
        }
      }
    }
  }
  _setScopeField(fileKey, scopeKey, field, value) {
    _4.set(
      this.data,
      [
        "files",
        fileKey,
        "scopes",
        scopeKey,
        field
      ],
      value
    );
    return this;
  }
};

// src/utils/hash.ts
import { MD5 } from "object-hash";
function getJsxElementHash(nodePath) {
  if (!nodePath.node) {
    return "";
  }
  const content = nodePath.node.children.map((child) => child.value).join("");
  const result = MD5(content);
  return result;
}
function getJsxAttributeValueHash(attributeValue) {
  if (!attributeValue) {
    return "";
  }
  const result = MD5(attributeValue);
  return result;
}

// src/jsx-attribute-scopes-export.ts
import _5 from "lodash";
function jsxAttributeScopesExportMutation(payload) {
  const attributeScopes = collectJsxAttributeScopes(payload.ast);
  if (_5.isEmpty(attributeScopes)) {
    return payload;
  }
  const lcp = LCP.getInstance({
    sourceRoot: payload.params.sourceRoot,
    lingoDir: payload.params.lingoDir
  });
  for (const [scope, attributes] of attributeScopes) {
    for (const attributeDefinition of attributes) {
      const [attribute, scopeKey] = attributeDefinition.split(":");
      lcp.resetScope(payload.relativeFilePath, scopeKey);
      const attributeValue = getJsxAttributeValue(scope, attribute);
      if (!attributeValue) {
        continue;
      }
      lcp.setScopeType(payload.relativeFilePath, scopeKey, "attribute");
      const hash = getJsxAttributeValueHash(String(attributeValue));
      lcp.setScopeHash(payload.relativeFilePath, scopeKey, hash);
      lcp.setScopeContext(payload.relativeFilePath, scopeKey, "");
      lcp.setScopeSkip(payload.relativeFilePath, scopeKey, false);
      lcp.setScopeOverrides(payload.relativeFilePath, scopeKey, {});
      lcp.setScopeContent(
        payload.relativeFilePath,
        scopeKey,
        String(attributeValue)
      );
    }
  }
  lcp.save();
  return payload;
}

// src/jsx-fragment.ts
import traverse5 from "@babel/traverse";
import * as t11 from "@babel/types";
function jsxFragmentMutation(payload) {
  const { ast } = payload;
  let foundFragments = false;
  let fragmentImportName = null;
  traverse5(ast, {
    ImportDeclaration(path7) {
      if (path7.node.source.value !== "react") return;
      for (const specifier of path7.node.specifiers) {
        if (t11.isImportSpecifier(specifier) && t11.isIdentifier(specifier.imported) && specifier.imported.name === "Fragment") {
          fragmentImportName = specifier.local.name;
          path7.stop();
        }
      }
    }
  });
  traverse5(ast, {
    JSXFragment(path7) {
      foundFragments = true;
      if (!fragmentImportName) {
        const result = getOrCreateImport(ast, {
          exportedName: "Fragment",
          moduleName: ["react"]
        });
        fragmentImportName = result.importedName;
      }
      const fragmentElement = t11.jsxElement(
        t11.jsxOpeningElement(t11.jsxIdentifier(fragmentImportName), [], false),
        t11.jsxClosingElement(t11.jsxIdentifier(fragmentImportName)),
        path7.node.children,
        false
      );
      path7.replaceWith(fragmentElement);
    }
  });
  return payload;
}

// src/jsx-html-lang.ts
import traverse6 from "@babel/traverse";
import * as t12 from "@babel/types";
var jsxHtmlLangMutation = createCodeMutation((payload) => {
  traverse6(payload.ast, {
    JSXElement: (path7) => {
      if (getJsxElementName(path7)?.toLowerCase() === "html") {
        const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
        const packagePath = mode === "client" ? ModuleId.ReactClient : ModuleId.ReactRSC;
        const lingoHtmlComponentImport = getOrCreateImport(payload.ast, {
          moduleName: packagePath,
          exportedName: "LingoHtmlComponent"
        });
        path7.node.openingElement.name = t12.jsxIdentifier(
          lingoHtmlComponentImport.importedName
        );
        if (path7.node.closingElement) {
          path7.node.closingElement.name = t12.jsxIdentifier(
            lingoHtmlComponentImport.importedName
          );
        }
        path7.skip();
      }
    }
  });
  return payload;
});

// src/jsx-provider.ts
import traverse7 from "@babel/traverse";
import * as t13 from "@babel/types";
var jsxProviderMutation = createCodeMutation((payload) => {
  traverse7(payload.ast, {
    JSXElement: (path7) => {
      if (getJsxElementName(path7)?.toLowerCase() === "html") {
        const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
        if (mode === "client") {
          return;
        }
        const lingoProviderImport = getOrCreateImport(payload.ast, {
          moduleName: ModuleId.ReactRSC,
          exportedName: "LingoProvider"
        });
        const loadDictionaryImport = getOrCreateImport(payload.ast, {
          moduleName: ModuleId.ReactRSC,
          exportedName: "loadDictionary"
        });
        const loadDictionaryArrow = t13.arrowFunctionExpression(
          [t13.identifier("locale")],
          t13.callExpression(t13.identifier(loadDictionaryImport.importedName), [
            t13.identifier("locale")
          ])
        );
        const providerProps = [
          t13.jsxAttribute(
            t13.jsxIdentifier("loadDictionary"),
            t13.jsxExpressionContainer(loadDictionaryArrow)
          )
        ];
        const provider = t13.jsxElement(
          t13.jsxOpeningElement(
            t13.jsxIdentifier(lingoProviderImport.importedName),
            providerProps,
            false
          ),
          t13.jsxClosingElement(
            t13.jsxIdentifier(lingoProviderImport.importedName)
          ),
          [path7.node],
          false
        );
        path7.replaceWith(provider);
        path7.skip();
      }
    }
  });
  return payload;
});
var jsx_provider_default = jsxProviderMutation;

// src/jsx-remove-attributes.ts
import * as t14 from "@babel/types";
import traverse8 from "@babel/traverse";
var jsxRemoveAttributesMutation = createCodeMutation(
  (payload) => {
    const ATTRIBUTES_TO_REMOVE = [
      "data-jsx-root",
      "data-jsx-scope",
      "data-jsx-attribute-scope"
    ];
    traverse8(payload.ast, {
      JSXElement(path7) {
        const openingElement = path7.node.openingElement;
        openingElement.attributes = openingElement.attributes.filter((attr) => {
          const removeAttr = t14.isJSXAttribute(attr) && t14.isJSXIdentifier(attr.name) && ATTRIBUTES_TO_REMOVE.includes(attr.name.name);
          return !removeAttr;
        });
      }
    });
    return {
      ...payload
    };
  }
);

// src/jsx-root-flag.ts
import * as t15 from "@babel/types";
var jsxRootFlagMutation = createCodeMutation((payload) => {
  const jsxRoots = getJsxRoots(payload.ast);
  for (const jsxElementPath of jsxRoots) {
    jsxElementPath.node.openingElement.attributes.push(
      t15.jsxAttribute(t15.jsxIdentifier("data-jsx-root"), null)
    );
  }
  return {
    ...payload
  };
});
var jsx_root_flag_default = jsxRootFlagMutation;

// src/jsx-scope-flag.ts
import * as t17 from "@babel/types";

// src/utils/jsx-scope.ts
import * as t16 from "@babel/types";
import traverse9 from "@babel/traverse";
function collectJsxScopes(ast) {
  const jsxScopes = [];
  traverse9(ast, {
    JSXElement: (path7) => {
      if (!hasJsxScopeAttribute(path7)) return;
      path7.skip();
      jsxScopes.push(path7);
    }
  });
  return jsxScopes;
}
function getJsxScopes(node) {
  const result = [];
  traverse9(node, {
    JSXElement(path7) {
      if (getJsxElementName(path7) === "LingoProvider") {
        return;
      }
      const hasNonEmptyTextSiblings = path7.getAllPrevSiblings().concat(path7.getAllNextSiblings()).some(
        (sibling) => t16.isJSXText(sibling.node) && sibling.node.value?.trim() !== ""
      );
      if (hasNonEmptyTextSiblings) {
        return;
      }
      const hasNonEmptyTextChild = path7.get("children").some(
        (child) => t16.isJSXText(child.node) && child.node.value?.trim() !== ""
      );
      if (hasNonEmptyTextChild) {
        result.push(path7);
        path7.skip();
      }
    }
  });
  return result;
}
function hasJsxScopeAttribute(path7) {
  return !!getJsxScopeAttribute(path7);
}
function getJsxScopeAttribute(path7) {
  const attribute = path7.node.openingElement.attributes.find(
    (attr) => attr.type === "JSXAttribute" && attr.name.name === "data-jsx-scope"
  );
  return attribute && t16.isJSXAttribute(attribute) && t16.isStringLiteral(attribute.value) ? attribute.value.value : void 0;
}

// src/jsx-scope-flag.ts
var jsxScopeFlagMutation = createCodeMutation((payload) => {
  const jsxScopes = getJsxScopes(payload.ast);
  for (const jsxScope of jsxScopes) {
    jsxScope.node.openingElement.attributes.push(
      t17.jsxAttribute(
        t17.jsxIdentifier("data-jsx-scope"),
        t17.stringLiteral(getAstKey(jsxScope))
      )
    );
  }
  return {
    ...payload
  };
});
var jsx_scope_flag_default = jsxScopeFlagMutation;

// src/jsx-scope-inject.ts
import * as t21 from "@babel/types";

// src/utils/jsx-variables.ts
import * as t18 from "@babel/types";
var getJsxVariables = (nodePath) => {
  const variables = /* @__PURE__ */ new Set();
  nodePath.traverse({
    JSXOpeningElement(path7) {
      path7.skip();
    },
    JSXExpressionContainer(path7) {
      if (t18.isIdentifier(path7.node.expression)) {
        variables.add(path7.node.expression.name);
      } else if (t18.isMemberExpression(path7.node.expression)) {
        let current = path7.node.expression;
        const parts = [];
        while (t18.isMemberExpression(current)) {
          if (t18.isIdentifier(current.property)) {
            if (current.computed) {
              parts.unshift(`[${current.property.name}]`);
            } else {
              parts.unshift(current.property.name);
            }
          }
          current = current.object;
        }
        if (t18.isIdentifier(current)) {
          parts.unshift(current.name);
          variables.add(parts.join(".").replaceAll(".[", "["));
        }
      }
      path7.skip();
    }
  });
  const properties = Array.from(variables).map(
    (name) => t18.objectProperty(t18.stringLiteral(name), t18.identifier(name))
  );
  const result = t18.objectExpression(properties);
  return result;
};

// src/utils/jsx-functions.ts
import * as t19 from "@babel/types";
var getJsxFunctions = (nodePath) => {
  const functions = /* @__PURE__ */ new Map();
  let fnCounter = 0;
  nodePath.traverse({
    JSXOpeningElement(path7) {
      path7.skip();
    },
    JSXExpressionContainer(path7) {
      if (t19.isCallExpression(path7.node.expression)) {
        let key = "";
        if (t19.isIdentifier(path7.node.expression.callee)) {
          key = `${path7.node.expression.callee.name}`;
        } else if (t19.isMemberExpression(path7.node.expression.callee)) {
          let firstCallee = path7.node.expression.callee;
          while (t19.isMemberExpression(firstCallee) && t19.isCallExpression(firstCallee.object)) {
            firstCallee = firstCallee.object.callee;
          }
          let current = firstCallee;
          const parts = [];
          while (t19.isMemberExpression(current)) {
            if (t19.isIdentifier(current.property)) {
              parts.unshift(current.property.name);
            }
            current = current.object;
          }
          if (t19.isIdentifier(current)) {
            parts.unshift(current.name);
          }
          if (t19.isMemberExpression(firstCallee) && t19.isNewExpression(firstCallee.object) && t19.isIdentifier(firstCallee.object.callee)) {
            parts.unshift(firstCallee.object.callee.name);
          }
          key = parts.join(".");
        }
        const existing = functions.get(key) ?? [];
        functions.set(key, [...existing, path7.node.expression]);
        fnCounter++;
      }
      path7.skip();
    }
  });
  const properties = Array.from(functions.entries()).map(
    ([name, callExpr]) => t19.objectProperty(t19.stringLiteral(name), t19.arrayExpression(callExpr))
  );
  return t19.objectExpression(properties);
};

// src/utils/jsx-expressions.ts
import * as t20 from "@babel/types";
var getJsxExpressions = (nodePath) => {
  const expressions = [];
  nodePath.traverse({
    JSXOpeningElement(path7) {
      path7.skip();
    },
    JSXExpressionContainer(path7) {
      const expr = path7.node.expression;
      if (!t20.isJSXEmptyExpression(expr) && !t20.isIdentifier(expr) && !t20.isMemberExpression(expr) && !t20.isCallExpression(expr) && !(t20.isStringLiteral(expr) && expr.value === " ")) {
        expressions.push(expr);
      }
      path7.skip();
    }
  });
  return t20.arrayExpression(expressions);
};

// src/jsx-scope-inject.ts
var lingoJsxScopeInjectMutation = createCodeMutation((payload) => {
  const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
  const jsxScopes = collectJsxScopes(payload.ast);
  for (const jsxScope of jsxScopes) {
    const skip = getJsxAttributeValue(jsxScope, "data-lingo-skip");
    if (skip) {
      continue;
    }
    const packagePath = mode === "client" ? ModuleId.ReactClient : ModuleId.ReactRSC;
    const lingoComponentImport = getOrCreateImport(payload.ast, {
      moduleName: packagePath,
      exportedName: "LingoComponent"
    });
    const originalJsxElementName = getJsxElementName(jsxScope);
    if (!originalJsxElementName) {
      continue;
    }
    const newNode = t21.jsxElement(
      t21.jsxOpeningElement(
        t21.jsxIdentifier(lingoComponentImport.importedName),
        jsxScope.node.openingElement.attributes.slice(),
        // original attributes
        true
        // selfClosing
      ),
      null,
      // no closing element
      [],
      // no children
      true
      // selfClosing
    );
    const newNodePath = {
      node: newNode
    };
    const as = /^[A-Z]/.test(originalJsxElementName) ? t21.identifier(originalJsxElementName) : originalJsxElementName;
    setJsxAttributeValue(newNodePath, "$as", as);
    setJsxAttributeValue(newNodePath, "$fileKey", payload.relativeFilePath);
    setJsxAttributeValue(
      newNodePath,
      "$entryKey",
      getJsxScopeAttribute(jsxScope)
    );
    const $variables = getJsxVariables(jsxScope);
    if ($variables.properties.length > 0) {
      setJsxAttributeValue(newNodePath, "$variables", $variables);
    }
    const $elements = getNestedJsxElements(jsxScope);
    if ($elements.elements.length > 0) {
      setJsxAttributeValue(newNodePath, "$elements", $elements);
    }
    const $functions = getJsxFunctions(jsxScope);
    if ($functions.properties.length > 0) {
      setJsxAttributeValue(newNodePath, "$functions", $functions);
    }
    const $expressions = getJsxExpressions(jsxScope);
    if ($expressions.elements.length > 0) {
      setJsxAttributeValue(newNodePath, "$expressions", $expressions);
    }
    if (mode === "server") {
      const loadDictionaryImport = getOrCreateImport(payload.ast, {
        exportedName: "loadDictionary",
        moduleName: ModuleId.ReactRSC
      });
      setJsxAttributeValue(
        newNodePath,
        "$loadDictionary",
        t21.arrowFunctionExpression(
          [t21.identifier("locale")],
          t21.callExpression(t21.identifier(loadDictionaryImport.importedName), [
            t21.identifier("locale")
          ])
        )
      );
    }
    jsxScope.replaceWith(newNode);
  }
  return payload;
});

// src/jsx-scopes-export.ts
import _7 from "lodash";

// src/utils/jsx-content.ts
import * as t22 from "@babel/types";
import _6 from "lodash";
var WHITESPACE_PLACEHOLDER = "[lingo-whitespace-placeholder]";
function extractJsxContent(nodePath, replaceWhitespacePlaceholders = true) {
  const chunks = [];
  nodePath.traverse({
    JSXElement(path7) {
      if (path7.parent === nodePath.node) {
        const content = extractJsxContent(path7, false);
        const name = getJsxElementName(path7);
        chunks.push(`<element:${name}>${content}</element:${name}>`);
        path7.skip();
      }
    },
    JSXText(path7) {
      chunks.push(path7.node.value);
    },
    JSXExpressionContainer(path7) {
      if (path7.parent !== nodePath.node) {
        return;
      }
      const expr = path7.node.expression;
      if (t22.isCallExpression(expr)) {
        let key = "";
        if (t22.isIdentifier(expr.callee)) {
          key = `${expr.callee.name}`;
        } else if (t22.isMemberExpression(expr.callee)) {
          let firstCallee = expr.callee;
          while (t22.isMemberExpression(firstCallee) && t22.isCallExpression(firstCallee.object)) {
            firstCallee = firstCallee.object.callee;
          }
          let current = firstCallee;
          const parts = [];
          while (t22.isMemberExpression(current)) {
            if (t22.isIdentifier(current.property)) {
              parts.unshift(current.property.name);
            }
            current = current.object;
          }
          if (t22.isIdentifier(current)) {
            parts.unshift(current.name);
          }
          if (t22.isMemberExpression(firstCallee) && t22.isNewExpression(firstCallee.object) && t22.isIdentifier(firstCallee.object.callee)) {
            parts.unshift(firstCallee.object.callee.name);
          }
          key = parts.join(".");
        }
        chunks.push(`<function:${key}/>`);
      } else if (t22.isIdentifier(expr)) {
        chunks.push(`{${expr.name}}`);
      } else if (t22.isMemberExpression(expr)) {
        let current = expr;
        const parts = [];
        while (t22.isMemberExpression(current)) {
          if (t22.isIdentifier(current.property)) {
            if (current.computed) {
              parts.unshift(`[${current.property.name}]`);
            } else {
              parts.unshift(current.property.name);
            }
          }
          current = current.object;
        }
        if (t22.isIdentifier(current)) {
          parts.unshift(current.name);
          chunks.push(`{${parts.join(".").replaceAll(".[", "[")}}`);
        }
      } else if (isWhitespace(path7)) {
        chunks.push(WHITESPACE_PLACEHOLDER);
      } else if (isExpression2(path7)) {
        chunks.push("<expression/>");
      }
      path7.skip();
    }
  });
  const result = chunks.join("");
  const normalized = normalizeJsxWhitespace(result);
  if (replaceWhitespacePlaceholders) {
    return normalized.replaceAll(WHITESPACE_PLACEHOLDER, " ");
  }
  return normalized;
}
var compilerProps = ["data-jsx-attribute-scope", "data-jsx-scope"];
function isExpression2(nodePath) {
  const isCompilerExpression = !_6.isArray(nodePath.container) && t22.isJSXAttribute(nodePath.container) && t22.isJSXIdentifier(nodePath.container.name) && compilerProps.includes(nodePath.container.name.name);
  return !isCompilerExpression && !t22.isJSXEmptyExpression(nodePath.node.expression);
}
function isWhitespace(nodePath) {
  const expr = nodePath.node.expression;
  return t22.isStringLiteral(expr) && expr.value === " ";
}
function normalizeJsxWhitespace(input) {
  if (!input.includes("\n")) {
    const trimmed = input.trim();
    if (trimmed.length === 0) return "";
    const leadingMatch = input.match(/^\s*/);
    const trailingMatch = input.match(/\s*$/);
    const leadingSpaces = leadingMatch ? leadingMatch[0].length : 0;
    const trailingSpaces = trailingMatch ? trailingMatch[0].length : 0;
    if (leadingSpaces > 1 || trailingSpaces > 1) {
      return input.replace(/\s+/g, " ").trim();
    } else {
      return input.replace(/\s{2,}/g, " ");
    }
  }
  const lines = input.split("\n");
  let result = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    if (trimmedLine === "") continue;
    if (trimmedLine.includes(WHITESPACE_PLACEHOLDER)) {
      result += trimmedLine;
    } else if (trimmedLine.startsWith("<element:") || trimmedLine.startsWith("<function:") || trimmedLine.startsWith("{") || trimmedLine.startsWith("<expression/>")) {
      const shouldAddSpace = result && !result.endsWith(" ") && !result.endsWith(WHITESPACE_PLACEHOLDER) && /\w$/.test(result) && // Check if element content starts with space by looking for "> " pattern
      trimmedLine.includes("> ");
      if (shouldAddSpace) {
        result += " ";
      }
      result += trimmedLine;
    } else {
      if (result && !result.endsWith(" ") && !result.endsWith(WHITESPACE_PLACEHOLDER)) {
        result += " ";
      }
      result += trimmedLine;
    }
  }
  result = result.replace(/\s{2,}/g, " ");
  return result.trim();
}

// src/jsx-scopes-export.ts
function jsxScopesExportMutation(payload) {
  const scopes = collectJsxScopes(payload.ast);
  if (_7.isEmpty(scopes)) {
    return payload;
  }
  const lcp = LCP.getInstance({
    sourceRoot: payload.params.sourceRoot,
    lingoDir: payload.params.lingoDir
  });
  for (const scope of scopes) {
    const scopeKey = getAstKey(scope);
    lcp.resetScope(payload.relativeFilePath, scopeKey);
    lcp.setScopeType(payload.relativeFilePath, scopeKey, "element");
    const hash = getJsxElementHash(scope);
    lcp.setScopeHash(payload.relativeFilePath, scopeKey, hash);
    const context = getJsxAttributeValue(scope, "data-lingo-context");
    lcp.setScopeContext(
      payload.relativeFilePath,
      scopeKey,
      String(context || "")
    );
    const skip = getJsxAttributeValue(scope, "data-lingo-skip");
    lcp.setScopeSkip(
      payload.relativeFilePath,
      scopeKey,
      Boolean(skip || false)
    );
    const attributesMap = getJsxAttributesMap(scope);
    const overrides = _7.chain(attributesMap).entries().filter(
      ([attributeKey]) => attributeKey.startsWith("data-lingo-override-")
    ).map(([k, v]) => [k.split("data-lingo-override-")[1], v]).filter(([k]) => !!k).filter(([, v]) => !!v).fromPairs().value();
    lcp.setScopeOverrides(payload.relativeFilePath, scopeKey, overrides);
    const content = extractJsxContent(scope);
    lcp.setScopeContent(payload.relativeFilePath, scopeKey, content);
  }
  lcp.save();
  return payload;
}

// src/lib/lcp/server.ts
import _10 from "lodash";

// src/lib/lcp/api/index.ts
import { createGroq } from "@ai-sdk/groq";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { createOllama } from "ollama-ai-provider";
import { createMistral } from "@ai-sdk/mistral";
import { generateText } from "ai";
import { LingoDotDevEngine } from "@lingo.dev/_sdk";
import _9 from "lodash";

// src/lib/lcp/api/prompt.ts
var prompt_default = (args) => {
  return getUserSystemPrompt(args) || getBuiltInSystemPrompt(args);
};
function getUserSystemPrompt(args) {
  const userPrompt = args.prompt?.trim()?.replace("{SOURCE_LOCALE}", args.sourceLocale)?.replace("{TARGET_LOCALE}", args.targetLocale);
  if (userPrompt) {
    console.log("\u2728 Compiler is using user-defined prompt.");
    return userPrompt;
  }
  return void 0;
}
function getBuiltInSystemPrompt(args) {
  return `
# Identity

You are an advanced AI localization engine. You do state-of-the-art localization for software products.
Your task is to localize pieces of data from one locale to another locale.
You always consider context, cultural nuances of source and target locales, and specific localization requirements.
You replicate the meaning, intent, style, tone, and purpose of the original data.

## Setup

Source language (locale code): ${args.sourceLocale}
Target language (locale code): ${args.targetLocale}

## Guidelines

Follow these guidelines for translation:

1. Analyze the source text to understand its overall context and purpose
2. Translate the meaning and intent rather than word-for-word translation
3. Rephrase and restructure sentences to sound natural and fluent in the target language
4. Adapt idiomatic expressions and cultural references for the target audience
5. Maintain the style and tone of the source text
6. You must produce valid UTF-8 encoded output
7. YOU MUST ONLY PRODUCE VALID XML.

## Special Instructions

Do not localize any of these technical elements:
- Variables like {variable}, {variable.key}, {data[type]}
- Expressions like <expression/>
- Functions like <function:value/>, <function:getDisplayName/>
- Elements like <element:strong>, </element:strong>, <element:LuPlus>, </element:LuPlus>, <element:LuSparkles>, </element:LuSparkles>

Remember, you are a context-aware multilingual assistant helping international companies.
Your goal is to perform state-of-the-art localization for software products and content.
`;
}

// src/lib/lcp/api/xml2obj.ts
import { XMLParser, XMLBuilder } from "fast-xml-parser";
import _8 from "lodash";
var TAG_OBJECT = "object";
var TAG_ARRAY = "array";
var TAG_VALUE = "value";
function _toGenericNode(value, key) {
  if (_8.isArray(value)) {
    const children = _8.map(value, (item) => _toGenericNode(item));
    return {
      [TAG_ARRAY]: {
        ...key ? { key } : {},
        ..._groupChildren(children)
      }
    };
  }
  if (_8.isPlainObject(value)) {
    const children = _8.map(
      Object.entries(value),
      ([k, v]) => _toGenericNode(v, k)
    );
    return {
      [TAG_OBJECT]: {
        ...key ? { key } : {},
        ..._groupChildren(children)
      }
    };
  }
  return {
    [TAG_VALUE]: {
      ...key ? { key } : {},
      "#text": value ?? ""
    }
  };
}
function _groupChildren(nodes) {
  return _8(nodes).groupBy((node) => Object.keys(node)[0]).mapValues((arr) => _8.map(arr, (n) => n[Object.keys(n)[0]])).value();
}
function _fromGenericNode(tag, data) {
  if (tag === TAG_VALUE) {
    if (_8.isPlainObject(data)) {
      return _8.get(data, "#text", "");
    }
    return data ?? "";
  }
  if (tag === TAG_ARRAY) {
    const result = [];
    _8.forEach([TAG_VALUE, TAG_OBJECT, TAG_ARRAY], (childTag) => {
      const childNodes = _8.castArray(_8.get(data, childTag, []));
      _8.forEach(childNodes, (child) => {
        result.push(_fromGenericNode(childTag, child));
      });
    });
    return result;
  }
  const obj = {};
  _8.forEach([TAG_VALUE, TAG_OBJECT, TAG_ARRAY], (childTag) => {
    const childNodes = _8.castArray(_8.get(data, childTag, []));
    _8.forEach(childNodes, (child) => {
      const key = _8.get(child, "key", "");
      obj[key] = _fromGenericNode(childTag, child);
    });
  });
  return obj;
}
function obj2xml(obj) {
  const rootNode = _toGenericNode(obj)[TAG_OBJECT];
  const builder = new XMLBuilder({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    format: true,
    suppressEmptyNode: true
  });
  return builder.build({ [TAG_OBJECT]: rootNode });
}
function xml2obj(xml) {
  const parser2 = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    parseTagValue: true,
    parseAttributeValue: false,
    processEntities: true,
    isArray: (name) => [TAG_VALUE, TAG_ARRAY, TAG_OBJECT].includes(name)
  });
  const parsed = parser2.parse(xml);
  const withoutDeclaration = _8.omit(parsed, "?xml");
  const rootTag = Object.keys(withoutDeclaration)[0];
  const rootNode = _8.castArray(withoutDeclaration[rootTag])[0];
  return _fromGenericNode(rootTag, rootNode);
}

// src/lib/lcp/api/shots.ts
var shots_default = [
  // Shot #1
  [
    {
      version: 0.1,
      locale: "en",
      files: {
        "demo-app/my-custom-header.tsx": {
          entries: {
            "1z2x3c4v": "Dashboard",
            "5t6y7u8i": "Settings",
            "9o0p1q2r": "Logout"
          }
        },
        "demo-app/my-custom-footer.tsx": {
          entries: {
            "9k0l1m2n": "\xA9 2025 Lingo.dev. All rights reserved."
          }
        }
      }
    },
    {
      version: 0.1,
      locale: "es",
      files: {
        "demo-app/my-custom-header.tsx": {
          entries: {
            "1z2x3c4v": "Panel de control",
            "5t6y7u8i": "Configuraci\xF3n",
            "9o0p1q2r": "Cerrar sesi\xF3n"
          }
        },
        "demo-app/my-custom-footer.tsx": {
          entries: {
            "9k0l1m2n": "\xA9 2025 Lingo.dev. Todos los derechos reservados."
          }
        }
      }
    }
  ]
  // More shots here...
];

// src/lib/lcp/api/index.ts
import dedent2 from "dedent";
var LCPAPI = class {
  static async translate(models, sourceDictionary, sourceLocale, targetLocale, prompt) {
    const timeLabel = `LCPAPI.translate: ${targetLocale}`;
    console.time(timeLabel);
    const chunks = this._chunkDictionary(sourceDictionary);
    const translatedChunks = [];
    for (const chunk of chunks) {
      const translatedChunk = await this._translateChunk(
        models,
        chunk,
        sourceLocale,
        targetLocale,
        prompt
      );
      translatedChunks.push(translatedChunk);
    }
    const result = this._mergeDictionaries(translatedChunks);
    console.timeEnd(timeLabel);
    return result;
  }
  static _chunkDictionary(dictionary) {
    const MAX_ENTRIES_PER_CHUNK = 100;
    const { files, ...rest } = dictionary;
    const chunks = [];
    let currentChunk = {
      ...rest,
      files: {}
    };
    let currentEntryCount = 0;
    Object.entries(files).forEach(([fileName, file]) => {
      const entries = file.entries;
      const entryPairs = Object.entries(entries);
      let currentIndex = 0;
      while (currentIndex < entryPairs.length) {
        const remainingSpace = MAX_ENTRIES_PER_CHUNK - currentEntryCount;
        const entriesToAdd = entryPairs.slice(
          currentIndex,
          currentIndex + remainingSpace
        );
        if (entriesToAdd.length > 0) {
          currentChunk.files[fileName] = currentChunk.files[fileName] || {
            entries: {}
          };
          currentChunk.files[fileName].entries = {
            ...currentChunk.files[fileName].entries,
            ...Object.fromEntries(entriesToAdd)
          };
          currentEntryCount += entriesToAdd.length;
        }
        currentIndex += entriesToAdd.length;
        if (currentEntryCount >= MAX_ENTRIES_PER_CHUNK || currentIndex < entryPairs.length && currentEntryCount + (entryPairs.length - currentIndex) > MAX_ENTRIES_PER_CHUNK) {
          chunks.push(currentChunk);
          currentChunk = { ...rest, files: {} };
          currentEntryCount = 0;
        }
      }
    });
    if (currentEntryCount > 0) {
      chunks.push(currentChunk);
    }
    return chunks;
  }
  static _mergeDictionaries(dictionaries) {
    const fileNames = _9.uniq(
      _9.flatMap(dictionaries, (dict) => Object.keys(dict.files))
    );
    const files = _9(fileNames).map((fileName) => {
      const entries = dictionaries.reduce((entries2, dict) => {
        const file = dict.files[fileName];
        if (file) {
          entries2 = _9.merge(entries2, file.entries);
        }
        return entries2;
      }, {});
      return [fileName, { entries }];
    }).fromPairs().value();
    const dictionary = {
      version: dictionaries[0].version,
      locale: dictionaries[0].locale,
      files
    };
    return dictionary;
  }
  static _createLingoDotDevEngine() {
    if (isRunningInCIOrDocker()) {
      const apiKeyFromEnv = getLingoDotDevKeyFromEnv();
      if (!apiKeyFromEnv) {
        this._failMissingLLMKeyCi("lingo.dev");
      }
    }
    const apiKey = getLingoDotDevKey();
    if (!apiKey) {
      throw new Error(
        "\u26A0\uFE0F  Lingo.dev API key not found. Please set LINGODOTDEV_API_KEY environment variable or configure it user-wide."
      );
    }
    console.log(`Creating Lingo.dev client`);
    return new LingoDotDevEngine({
      apiKey
    });
  }
  static async _translateChunk(models, sourceDictionary, sourceLocale, targetLocale, prompt) {
    if (models === "lingo.dev") {
      try {
        const lingoDotDevEngine = this._createLingoDotDevEngine();
        console.log(
          `\u2728 Using Lingo.dev Engine to localize from "${sourceLocale}" to "${targetLocale}"`
        );
        const result = await lingoDotDevEngine.localizeObject(
          sourceDictionary,
          {
            sourceLocale,
            targetLocale
          }
        );
        return result;
      } catch (error) {
        this._failLLMFailureLocal(
          "lingo.dev",
          targetLocale,
          error instanceof Error ? error.message : "Unknown error"
        );
        throw error;
      }
    } else {
      const { provider, model } = getLocaleModel(
        models,
        sourceLocale,
        targetLocale
      );
      if (!provider || !model) {
        throw new Error(
          dedent2`
            ðŸš«  Lingo.dev Localization Engine Not Configured!

            The "models" parameter is missing or incomplete in your Lingo.dev configuration.

            ðŸ‘‰ To fix this, set the "models" parameter to either:
               â€¢ "lingo.dev" (for the default engine)
               â€¢ a map of locale-to-model, e.g. { "models": { "en:es": "openai:gpt-3.5-turbo" } }

            Example:
              {
                // ...
                "models": "lingo.dev"
              }

            For more details, see: https://lingo.dev/compiler
            To get help, join our Discord: https://lingo.dev/go/discord
            `
        );
      }
      try {
        const aiModel = this._createAiModel(provider, model, targetLocale);
        console.log(
          `\u2139\uFE0F Using raw LLM API ("${provider}":"${model}") to translate from "${sourceLocale}" to "${targetLocale}"`
        );
        const response = await generateText({
          model: aiModel,
          messages: [
            {
              role: "system",
              content: prompt_default({
                sourceLocale,
                targetLocale,
                prompt: prompt ?? void 0
              })
            },
            ...shots_default.flatMap((shotsTuple) => [
              {
                role: "user",
                content: obj2xml(shotsTuple[0])
              },
              {
                role: "assistant",
                content: obj2xml(shotsTuple[1])
              }
            ]),
            {
              role: "user",
              content: obj2xml(sourceDictionary)
            }
          ]
        });
        console.log("Response text received for", targetLocale);
        let responseText = response.text;
        responseText = responseText.substring(
          responseText.indexOf("<"),
          responseText.lastIndexOf(">") + 1
        );
        return xml2obj(responseText);
      } catch (error) {
        this._failLLMFailureLocal(
          provider,
          targetLocale,
          error instanceof Error ? error.message : "Unknown error"
        );
        throw error;
      }
    }
  }
  /**
   * Instantiates an AI model based on provider and model ID.
   * Includes CI/CD API key checks.
   * @param providerId The ID of the AI provider (e.g., "groq", "google").
   * @param modelId The ID of the specific model (e.g., "llama3-8b-8192", "gemini-2.0-flash").
   * @param targetLocale The target locale being translated to (for logging/error messages).
   * @returns An instantiated AI LanguageModel.
   * @throws Error if the provider is not supported or API key is missing in CI/CD.
   */
  static _createAiModel(providerId, modelId, targetLocale) {
    switch (providerId) {
      case "groq": {
        if (isRunningInCIOrDocker()) {
          const groqFromEnv = getGroqKeyFromEnv();
          if (!groqFromEnv) {
            this._failMissingLLMKeyCi(providerId);
          }
        }
        const groqKey = getGroqKey();
        if (!groqKey) {
          throw new Error(
            "\u26A0\uFE0F  GROQ API key not found. Please set GROQ_API_KEY environment variable or configure it user-wide."
          );
        }
        console.log(
          `Creating Groq client for ${targetLocale} using model ${modelId}`
        );
        return createGroq({ apiKey: groqKey })(modelId);
      }
      case "google": {
        if (isRunningInCIOrDocker()) {
          const googleFromEnv = getGoogleKeyFromEnv();
          if (!googleFromEnv) {
            this._failMissingLLMKeyCi(providerId);
          }
        }
        const googleKey = getGoogleKey();
        if (!googleKey) {
          throw new Error(
            "\u26A0\uFE0F  Google API key not found. Please set GOOGLE_API_KEY environment variable or configure it user-wide."
          );
        }
        console.log(
          `Creating Google Generative AI client for ${targetLocale} using model ${modelId}`
        );
        return createGoogleGenerativeAI({ apiKey: googleKey })(modelId);
      }
      case "openrouter": {
        if (isRunningInCIOrDocker()) {
          const openRouterFromEnv = getOpenRouterKeyFromEnv();
          if (!openRouterFromEnv) {
            this._failMissingLLMKeyCi(providerId);
          }
        }
        const openRouterKey = getOpenRouterKey();
        if (!openRouterKey) {
          throw new Error(
            "\u26A0\uFE0F  OpenRouter API key not found. Please set OPENROUTER_API_KEY environment variable or configure it user-wide."
          );
        }
        console.log(
          `Creating OpenRouter client for ${targetLocale} using model ${modelId}`
        );
        return createOpenRouter({
          apiKey: openRouterKey
        })(modelId);
      }
      case "ollama": {
        console.log(
          `Creating Ollama client for ${targetLocale} using model ${modelId} at default Ollama address`
        );
        return createOllama()(modelId);
      }
      case "mistral": {
        if (isRunningInCIOrDocker()) {
          const mistralFromEnv = getMistralKeyFromEnv();
          if (!mistralFromEnv) {
            this._failMissingLLMKeyCi(providerId);
          }
        }
        const mistralKey = getMistralKey();
        if (!mistralKey) {
          throw new Error(
            "\u26A0\uFE0F  Mistral API key not found. Please set MISTRAL_API_KEY environment variable or configure it user-wide."
          );
        }
        console.log(
          `Creating Mistral client for ${targetLocale} using model ${modelId}`
        );
        return createMistral({ apiKey: mistralKey })(modelId);
      }
      default: {
        throw new Error(
          `\u26A0\uFE0F  Provider "${providerId}" for locale "${targetLocale}" is not supported. Only "groq", "google", "openrouter", "ollama", and "mistral" providers are supported at the moment.`
        );
      }
    }
  }
  /**
   * Show an actionable error message and exit the process when the compiler
   * is running in CI/CD without a required LLM API key.
   * The message explains why this situation is unusual and how to fix it.
   * @param providerId The ID of the LLM provider whose key is missing.
   */
  static _failMissingLLMKeyCi(providerId) {
    let details = providerDetails[providerId];
    if (!details) {
      throw new Error(
        `Internal Error: Missing details for provider "${providerId}" when reporting missing key in CI/CD. You might be using an unsupported provider.`
      );
    }
    const errorMessage = dedent2`
      ðŸ’¡ You're using Lingo.dev Localization Compiler, and it detected unlocalized components in your app.

      The compiler needs a ${details.name} API key to translate missing strings, but ${details.apiKeyEnvVar} is not set in the environment.

      This is unexpected: typically you run a full build locally, commit the generated translation files, and push them to CI/CD.

      However, If you want CI/CD to translate the new strings, provide the key with:
      â€¢ Session-wide: export ${details.apiKeyEnvVar}=<your-api-key>
      â€¢ Project-wide / CI: add ${details.apiKeyEnvVar}=<your-api-key> to your pipeline environment variables

      â­ï¸ Also:
      1. If you don't yet have a ${details.name} API key, get one for free at ${details.getKeyLink}
      2. If you want to use a different LLM, update your configuration. Refer to documentation for help: https://lingo.dev/compiler
      3. If the model you want to use isn't supported yet, raise an issue in our open-source repo: https://lingo.dev/go/gh
    `;
    console.log(errorMessage);
    throw new Error(`Missing ${details.name} API key in CI/CD environment.`);
  }
  /**
   * Show an actionable error message and exit the process when an LLM API call
   * fails during local compilation.
   * @param providerId The ID of the LLM provider that failed.
   * @param targetLocale The target locale being translated to.
   * @param errorMessage The error message received from the API.
   */
  static _failLLMFailureLocal(providerId, targetLocale, errorMessage) {
    const details = providerDetails[providerId];
    if (!details) {
      throw new Error(
        `Internal Error: Missing details for provider "${providerId}" when reporting local failure. Original Error: ${errorMessage}`
      );
    }
    const isInvalidApiKey = errorMessage.match("Invalid API Key");
    if (isInvalidApiKey) {
      const message = dedent2`
        âš ï¸  Lingo.dev Compiler requires a valid ${details.name} API key to translate your application.

        It looks like you set ${details.name} API key but it is not valid. Please check your API key and try again.

        Error details from ${details.name} API: ${errorMessage}

        ðŸ‘‰ You can set the API key in one of the following ways:
        1. User-wide: Run npx lingo.dev@latest config set ${details.apiKeyConfigKey} <your-api-key>
        2. Project-wide: Add ${details.apiKeyEnvVar}=<your-api-key> to .env file in every project that uses Lingo.dev Localization Compiler
        3 Session-wide: Run export ${details.apiKeyEnvVar}=<your-api-key> in your terminal before running the compiler to set the API key for the current session

        â­ï¸ Also:
        1. If you don't yet have a ${details.name} API key, get one for free at ${details.getKeyLink}
        2. If you want to use a different LLM, raise an issue in our open-source repo: https://lingo.dev/go/gh
        3. If you have questions, feature requests, or would like to contribute, join our Discord: https://lingo.dev/go/discord
      `;
      console.log(message);
      throw new Error(`Invalid ${details.name} API key.`);
    } else {
      const message = dedent2`
        âš ï¸  Lingo.dev Compiler tried to translate your application to "${targetLocale}" locale via ${details.name} but it failed.

        Error details from ${details.name} API: ${errorMessage}

        This error comes from the ${details.name} API, please check their documentation for more details: ${details.docsLink}

        â­ï¸ Also:
        1. Did you set ${details.apiKeyEnvVar ? `${details.apiKeyEnvVar}` : "the provider API key"} environment variable correctly ${!details.apiKeyEnvVar ? "(if required)" : ""}?
        2. Did you reach any limits of your ${details.name} account?
        3. If you have questions, feature requests, or would like to contribute, join our Discord: https://lingo.dev/go/discord
      `;
      console.log(message);
      throw new Error(
        `Translation failed for locale "${targetLocale}" using ${details.name}: ${errorMessage}`
      );
    }
  }
};

// src/lib/lcp/server.ts
var LCPServer = class {
  static inFlightPromise = null;
  static async loadDictionaries(params) {
    if (this.inFlightPromise) {
      return this.inFlightPromise;
    }
    this.inFlightPromise = (async () => {
      try {
        const targetLocales = _10.uniq([
          ...params.targetLocales,
          params.sourceLocale
        ]);
        const dictionaries = await Promise.all(
          targetLocales.map(
            (targetLocale) => this.loadDictionaryForLocale({ ...params, targetLocale })
          )
        );
        const result = _10.fromPairs(
          targetLocales.map((targetLocale, index) => [
            targetLocale,
            dictionaries[index]
          ])
        );
        return result;
      } finally {
        this.inFlightPromise = null;
      }
    })();
    return this.inFlightPromise;
  }
  static async loadDictionaryForLocale(params) {
    const sourceDictionary = this._extractSourceDictionary(
      params.lcp,
      params.sourceLocale,
      params.targetLocale
    );
    const cacheParams = {
      lcp: params.lcp,
      sourceLocale: params.sourceLocale,
      lingoDir: params.lingoDir,
      sourceRoot: params.sourceRoot
    };
    if (this._countDictionaryEntries(sourceDictionary) === 0) {
      console.log(
        "Source dictionary is empty, returning empty dictionary for target locale"
      );
      return { ...sourceDictionary, locale: params.targetLocale };
    }
    const cache = LCPCache.readLocaleDictionary(
      params.targetLocale,
      cacheParams
    );
    const uncachedSourceDictionary = this._getDictionaryDiff(
      sourceDictionary,
      cache
    );
    let targetDictionary;
    let newTranslations;
    if (this._countDictionaryEntries(uncachedSourceDictionary) === 0) {
      targetDictionary = cache;
    } else if (params.targetLocale === params.sourceLocale) {
      console.log(
        "\u2139\uFE0F  Lingo.dev returns source dictionary - source and target locales are the same"
      );
      await LCPCache.writeLocaleDictionary(sourceDictionary, cacheParams);
      return sourceDictionary;
    } else {
      newTranslations = await LCPAPI.translate(
        params.models,
        uncachedSourceDictionary,
        params.sourceLocale,
        params.targetLocale,
        params.prompt
      );
      targetDictionary = this._mergeDictionaries(newTranslations, cache);
      targetDictionary = {
        ...targetDictionary,
        locale: params.targetLocale
      };
      await LCPCache.writeLocaleDictionary(targetDictionary, cacheParams);
    }
    const targetDictionaryWithFallback = this._mergeDictionaries(
      targetDictionary,
      sourceDictionary,
      true
    );
    const result = this._addOverridesToDictionary(
      targetDictionaryWithFallback,
      params.lcp,
      params.targetLocale
    );
    if (newTranslations) {
      console.log(
        `\u2139\uFE0F  Lingo.dev dictionary for ${params.targetLocale}:
- %d entries
- %d cached
- %d uncached
- %d translated
- %d overrides`,
        this._countDictionaryEntries(result),
        this._countDictionaryEntries(cache),
        this._countDictionaryEntries(uncachedSourceDictionary),
        newTranslations ? this._countDictionaryEntries(newTranslations) : 0,
        this._countDictionaryEntries(result) - this._countDictionaryEntries(targetDictionary)
      );
    }
    return result;
  }
  static _extractSourceDictionary(lcp, sourceLocale, targetLocale) {
    const dictionary = {
      version: 0.1,
      locale: sourceLocale,
      files: {}
    };
    for (const [fileKey, fileData] of Object.entries(lcp.files || {})) {
      for (const [scopeKey, scopeData] of Object.entries(
        fileData.scopes || {}
      )) {
        if (scopeData.skip) {
          continue;
        }
        if (this._getScopeLocaleOverride(scopeData, targetLocale)) {
          continue;
        }
        _10.set(
          dictionary,
          [
            "files",
            fileKey,
            "entries",
            scopeKey
          ],
          scopeData.content
        );
      }
    }
    return dictionary;
  }
  static _addOverridesToDictionary(dictionary, lcp, targetLocale) {
    for (const [fileKey, fileData] of Object.entries(lcp.files || {})) {
      for (const [scopeKey, scopeData] of Object.entries(
        fileData.scopes || {}
      )) {
        const override = this._getScopeLocaleOverride(scopeData, targetLocale);
        if (!override) {
          continue;
        }
        _10.set(
          dictionary,
          [
            "files",
            fileKey,
            "entries",
            scopeKey
          ],
          override
        );
      }
    }
    return dictionary;
  }
  static _getScopeLocaleOverride(scopeData, locale) {
    return _10.get(scopeData.overrides, locale) ?? null;
  }
  static _getDictionaryDiff(sourceDictionary, targetDictionary) {
    if (this._countDictionaryEntries(targetDictionary) === 0) {
      return sourceDictionary;
    }
    const files = _10(sourceDictionary.files).mapValues((file, fileName) => ({
      ...file,
      entries: _10(file.entries).mapValues((entry, entryName) => {
        const targetEntry = _10.get(targetDictionary.files, [
          fileName,
          "entries",
          entryName
        ]);
        if (targetEntry !== void 0) {
          return void 0;
        }
        return entry;
      }).pickBy((value) => value !== void 0).value()
    })).pickBy((value) => Object.keys(value.entries).length > 0).value();
    const dictionary = {
      version: sourceDictionary.version,
      locale: sourceDictionary.locale,
      files
    };
    return dictionary;
  }
  static _mergeDictionaries(sourceDictionary, targetDictionary, removeEmptyEntries = false) {
    const fileNames = _10.uniq([
      ...Object.keys(sourceDictionary.files),
      ...Object.keys(targetDictionary.files)
    ]);
    const files = _10(fileNames).map((fileName) => {
      const sourceFile = _10.get(sourceDictionary.files, fileName);
      const targetFile = _10.get(targetDictionary.files, fileName);
      const entries = removeEmptyEntries ? _10.pickBy(
        sourceFile?.entries || {},
        (value) => String(value || "")?.trim?.()?.length > 0
      ) : sourceFile?.entries || {};
      return [
        fileName,
        {
          ...targetFile,
          entries: _10.merge({}, targetFile?.entries || {}, entries)
        }
      ];
    }).fromPairs().value();
    const dictionary = {
      version: sourceDictionary.version,
      locale: sourceDictionary.locale,
      files
    };
    return dictionary;
  }
  static _countDictionaryEntries(dict) {
    return Object.values(dict.files).reduce(
      (sum, file) => sum + Object.keys(file.entries).length,
      0
    );
  }
};

// src/react-router-dictionary-loader.ts
import * as t23 from "@babel/types";
var reactRouterDictionaryLoaderMutation = createCodeMutation(
  (payload) => {
    const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
    if (mode === "server") {
      return payload;
    }
    const invokations = findInvokations(payload.ast, {
      moduleName: ModuleId.ReactRouter,
      functionName: "loadDictionary"
    });
    const allLocales = Array.from(
      /* @__PURE__ */ new Set([payload.params.sourceLocale, ...payload.params.targetLocales])
    );
    for (const invokation of invokations) {
      const internalDictionaryLoader = getOrCreateImport(payload.ast, {
        moduleName: ModuleId.ReactRouter,
        exportedName: "loadDictionary_internal"
      });
      if (t23.isIdentifier(invokation.callee)) {
        invokation.callee.name = internalDictionaryLoader.importedName;
      }
      const dictionaryPath = getDictionaryPath({
        sourceRoot: payload.params.sourceRoot,
        lingoDir: payload.params.lingoDir,
        relativeFilePath: payload.relativeFilePath
      });
      const localeImportMap = createLocaleImportMap(allLocales, dictionaryPath);
      invokation.arguments.push(localeImportMap);
    }
    return payload;
  }
);

// src/rsc-dictionary-loader.ts
import * as t24 from "@babel/types";
var rscDictionaryLoaderMutation = createCodeMutation((payload) => {
  const mode = getModuleExecutionMode(payload.ast, payload.params.rsc);
  if (mode === "client") {
    return payload;
  }
  const invokations = findInvokations(payload.ast, {
    moduleName: ModuleId.ReactRSC,
    functionName: "loadDictionary"
  });
  const allLocales = Array.from(
    /* @__PURE__ */ new Set([payload.params.sourceLocale, ...payload.params.targetLocales])
  );
  for (const invokation of invokations) {
    const internalDictionaryLoader = getOrCreateImport(payload.ast, {
      moduleName: ModuleId.ReactRSC,
      exportedName: "loadDictionary_internal"
    });
    if (t24.isIdentifier(invokation.callee)) {
      invokation.callee.name = internalDictionaryLoader.importedName;
    }
    const dictionaryPath = getDictionaryPath({
      sourceRoot: payload.params.sourceRoot,
      lingoDir: payload.params.lingoDir,
      relativeFilePath: payload.relativeFilePath
    });
    const localeImportMap = createLocaleImportMap(allLocales, dictionaryPath);
    invokation.arguments.push(localeImportMap);
  }
  return payload;
});

// src/utils/module-params.ts
function parseParametrizedModuleId(rawId) {
  const moduleUri = new URL(rawId, "module://");
  return {
    id: moduleUri.pathname.replace(/^\//, ""),
    params: Object.fromEntries(moduleUri.searchParams.entries())
  };
}

// src/_loader-utils.ts
async function loadDictionary(options) {
  const {
    resourcePath,
    resourceQuery = "",
    params,
    sourceRoot,
    lingoDir,
    isDev
  } = options;
  const fullResourcePath = `${resourcePath}${resourceQuery}`;
  if (!resourcePath.match(LCP_DICTIONARY_FILE_NAME)) {
    return null;
  }
  const moduleInfo = parseParametrizedModuleId(fullResourcePath);
  const locale = moduleInfo.params.locale;
  if (!locale) {
    return null;
  }
  const lcpParams = {
    sourceRoot,
    lingoDir,
    isDev
  };
  await LCP.ready(lcpParams);
  const lcp = LCP.getInstance(lcpParams);
  const dictionaries = await LCPServer.loadDictionaries({
    ...params,
    lcp: lcp.data
  });
  const dictionary = dictionaries[locale];
  if (!dictionary) {
    throw new Error(
      `Lingo.dev: Dictionary for locale "${locale}" could not be generated.`
    );
  }
  return dictionary;
}
function transformComponent(options) {
  const { code, params, resourcePath, sourceRoot } = options;
  return _11.chain({
    code,
    params,
    relativeFilePath: path6.relative(path6.resolve(process.cwd(), sourceRoot), resourcePath).split(path6.sep).join("/")
    // Always normalize for consistent dictionaries
  }).thru(createPayload).thru(
    composeMutations(
      i18n_directive_default,
      jsxFragmentMutation,
      jsx_attribute_flag_default,
      jsx_provider_default,
      jsxHtmlLangMutation,
      jsx_root_flag_default,
      jsx_scope_flag_default,
      jsxAttributeScopesExportMutation,
      jsxScopesExportMutation,
      lingoJsxAttributeScopeInjectMutation,
      lingoJsxScopeInjectMutation,
      rscDictionaryLoaderMutation,
      reactRouterDictionaryLoaderMutation,
      jsxRemoveAttributesMutation,
      clientDictionaryLoaderMutation
    )
  ).thru(createOutput).value();
}

export {
  __require,
  defaultParams,
  LCP_DICTIONARY_FILE_NAME,
  LCPCache,
  getInvalidLocales,
  getRc,
  getGroqKeyFromRc,
  getGroqKeyFromEnv,
  getLingoDotDevKeyFromEnv,
  getLingoDotDevKeyFromRc,
  getGoogleKeyFromRc,
  getGoogleKeyFromEnv,
  getMistralKeyFromRc,
  getMistralKeyFromEnv,
  isRunningInCIOrDocker,
  providerDetails,
  loadDictionary,
  transformComponent
};
