import {
  LCPCache,
  LCP_DICTIONARY_FILE_NAME,
  __require,
  defaultParams,
  getGoogleKeyFromEnv,
  getGoogleKeyFromRc,
  getGroqKeyFromEnv,
  getGroqKeyFromRc,
  getInvalidLocales,
  getLingoDotDevKeyFromEnv,
  getLingoDotDevKeyFromRc,
  getMistralKeyFromEnv,
  getMistralKeyFromRc,
  getRc,
  isRunningInCIOrDocker,
  loadDictionary,
  providerDetails,
  transformComponent
} from "./chunk-COKHINWO.mjs";

// src/index.ts
import { createUnplugin } from "unplugin";

// package.json
var package_default = {
  name: "@lingo.dev/_compiler",
  version: "0.7.17",
  description: "Lingo.dev Compiler",
  private: false,
  publishConfig: {
    access: "public"
  },
  sideEffects: false,
  type: "module",
  main: "build/index.cjs",
  types: "build/index.d.ts",
  module: "build/index.mjs",
  files: [
    "build"
  ],
  scripts: {
    dev: "tsup --watch",
    build: "pnpm typecheck && tsup",
    typecheck: "tsc --noEmit",
    clean: "rm -rf build",
    test: "vitest --run",
    "test:watch": "vitest -w"
  },
  keywords: [],
  author: "",
  license: "ISC",
  devDependencies: {
    "@types/babel__generator": "^7.6.8",
    "@types/babel__traverse": "^7.20.6",
    "@types/ini": "^4.1.1",
    "@types/lodash": "^4.17.4",
    "@types/object-hash": "^3.0.6",
    "@types/react": "^18.3.18",
    next: "15.2.4",
    tsup: "^8.3.5",
    typescript: "^5.4.5",
    vitest: "^2.1.4"
  },
  dependencies: {
    "@ai-sdk/google": "^1.2.19",
    "@ai-sdk/groq": "^1.2.3",
    "@ai-sdk/mistral": "^1.2.8",
    "@babel/generator": "^7.26.5",
    "@babel/parser": "^7.26.7",
    "@babel/traverse": "^7.27.4",
    "@babel/types": "^7.26.7",
    "@lingo.dev/_sdk": "workspace:*",
    "@lingo.dev/_spec": "workspace:*",
    "@openrouter/ai-sdk-provider": "^0.7.1",
    "@prettier/sync": "^0.6.1",
    ai: "^4.2.10",
    dedent: "^1.6.0",
    dotenv: "^16.4.5",
    "fast-xml-parser": "^5.0.8",
    ini: "^5.0.0",
    lodash: "^4.17.21",
    "object-hash": "^3.0.0",
    "ollama-ai-provider": "^1.2.0",
    prettier: "^3.4.2",
    unplugin: "^2.1.2",
    zod: "^3.25.76",
    "posthog-node": "^5.5.1",
    "node-machine-id": "^1.1.12"
  },
  packageManager: "pnpm@9.12.3"
};

// src/index.ts
import _ from "lodash";
import dedent from "dedent";

// src/utils/observability.ts
import { machineId } from "node-machine-id";
async function trackEvent(event, properties) {
  if (process.env.DO_NOT_TRACK) {
    return;
  }
  try {
    const actualId = await getActualId();
    const { PostHog } = await import("posthog-node");
    const posthog = new PostHog(
      "phc_eR0iSoQufBxNY36k0f0T15UvHJdTfHlh8rJcxsfhfXk",
      {
        host: "https://eu.i.posthog.com",
        flushAt: 1,
        flushInterval: 0
      }
    );
    await posthog.capture({
      distinctId: actualId,
      event,
      properties: {
        ...properties,
        isByokMode: properties?.models !== "lingo.dev",
        meta: {
          version: process.env.npm_package_version,
          isCi: process.env.CI === "true"
        }
      }
    });
    await posthog.shutdown();
  } catch (error) {
    if (process.env.DEBUG) {
      console.error(error);
    }
  }
}
async function getActualId() {
  const rc = getRc();
  const apiKey = process.env.LINGODOTDEV_API_KEY || rc?.auth?.apiKey;
  const apiUrl = process.env.LINGODOTDEV_API_URL || rc?.auth?.apiUrl || "https://engine.lingo.dev";
  if (apiKey) {
    try {
      const res = await fetch(`${apiUrl}/whoami`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          ContentType: "application/json"
        }
      });
      if (res.ok) {
        const payload = await res.json();
        if (payload?.email) {
          return payload.email;
        }
      }
    } catch (err) {
    }
  }
  const id = await machineId();
  return `device-${id}`;
}

// src/index.ts
var keyCheckers = {
  groq: {
    checkEnv: getGroqKeyFromEnv,
    checkRc: getGroqKeyFromRc
  },
  google: {
    checkEnv: getGoogleKeyFromEnv,
    checkRc: getGoogleKeyFromRc
  },
  mistral: {
    checkEnv: getMistralKeyFromEnv,
    checkRc: getMistralKeyFromRc
  },
  "lingo.dev": {
    checkEnv: getLingoDotDevKeyFromEnv,
    checkRc: getLingoDotDevKeyFromRc
  }
};
var alreadySentBuildEvent = { value: false };
function sendBuildEvent(framework, config, isDev) {
  if (alreadySentBuildEvent.value) return;
  alreadySentBuildEvent.value = true;
  trackEvent("compiler.build.start", {
    framework,
    configuration: config,
    isDevMode: isDev
  });
}
var unplugin = createUnplugin(
  (_params, _meta) => {
    console.log("\u2139\uFE0F  Starting Lingo.dev compiler...");
    const params = _.defaults(_params, defaultParams);
    if (!isRunningInCIOrDocker()) {
      if (params.models === "lingo.dev") {
        validateLLMKeyDetails(["lingo.dev"]);
      } else {
        const configuredProviders = getConfiguredProviders(params.models);
        validateLLMKeyDetails(configuredProviders);
        const invalidLocales = getInvalidLocales(
          params.models,
          params.sourceLocale,
          params.targetLocales
        );
        if (invalidLocales.length > 0) {
          throw new Error(dedent`
            ‚ö†Ô∏è  Lingo.dev Localization Compiler requires LLM model setup for the following locales: ${invalidLocales.join(
            ", "
          )}.

            ‚≠êÔ∏è Next steps:
            1. Refer to documentation for help: https://lingo.dev/compiler
            2. If you want to use a different LLM, raise an issue in our open-source repo: https://lingo.dev/go/gh
            3. If you have questions, feature requests, or would like to contribute, join our Discord: https://lingo.dev/go/discord
          `);
        }
      }
    }
    LCPCache.ensureDictionaryFile({
      sourceRoot: params.sourceRoot,
      lingoDir: params.lingoDir
    });
    const isDev = "dev" in _meta ? !!_meta.dev : process.env.NODE_ENV !== "production";
    sendBuildEvent("unplugin", params, isDev);
    return {
      name: package_default.name,
      loadInclude: (id) => !!id.match(LCP_DICTIONARY_FILE_NAME),
      async load(id) {
        const dictionary = await loadDictionary({
          resourcePath: id,
          resourceQuery: "",
          params: {
            ...params,
            models: params.models,
            sourceLocale: params.sourceLocale,
            targetLocales: params.targetLocales
          },
          sourceRoot: params.sourceRoot,
          lingoDir: params.lingoDir,
          isDev
        });
        if (!dictionary) {
          return null;
        }
        return {
          code: `export default ${JSON.stringify(dictionary, null, 2)}`
        };
      },
      transformInclude: (id) => id.endsWith(".tsx") || id.endsWith(".jsx"),
      enforce: "pre",
      transform(code, id) {
        try {
          const result = transformComponent({
            code,
            params,
            resourcePath: id,
            sourceRoot: params.sourceRoot
          });
          return result;
        } catch (error) {
          console.error("\u26A0\uFE0F  Lingo.dev compiler failed to localize your app");
          console.error("\u26A0\uFE0F  Details:", error);
          return code;
        }
      }
    };
  }
);
var src_default = {
  /**
   * Initializes Lingo.dev Compiler for Next.js (App Router).
   *
   * @param compilerParams - The compiler parameters.
   *
   * @returns The Next.js configuration.
   *
   * @example Configuration for Next.js's default template
   * ```ts
   * import lingoCompiler from "lingo.dev/compiler";
   * import type { NextConfig } from "next";
   *
   * const nextConfig: NextConfig = {
   *   /* config options here *\/
   * };
   *
   * export default lingoCompiler.next({
   *   sourceRoot: "app",
   *   models: "lingo.dev",
   * })(nextConfig);
   * ```
   */
  next: (compilerParams) => (nextConfig = {}) => {
    const mergedParams = _.merge(
      {},
      defaultParams,
      {
        rsc: true,
        turbopack: {
          enabled: "auto",
          useLegacyTurbo: false
        }
      },
      compilerParams
    );
    const isDev = process.env.NODE_ENV !== "production";
    sendBuildEvent("Next.js", mergedParams, isDev);
    let turbopackEnabled;
    if (mergedParams.turbopack?.enabled === "auto") {
      turbopackEnabled = process.env.TURBOPACK === "1" || process.env.TURBOPACK === "true";
    } else {
      turbopackEnabled = mergedParams.turbopack?.enabled === true;
    }
    const supportLegacyTurbo = mergedParams.turbopack?.useLegacyTurbo === true;
    const hasWebpackConfig = typeof nextConfig.webpack === "function";
    const hasTurbopackConfig = typeof nextConfig.turbopack === "function";
    if (hasWebpackConfig && turbopackEnabled) {
      console.warn(
        "\u26A0\uFE0F  Turbopack is enabled in the Lingo.dev compiler, but you have webpack config. Lingo.dev will still apply turbopack configuration."
      );
    }
    if (hasTurbopackConfig && !turbopackEnabled) {
      console.warn(
        "\u26A0\uFE0F  Turbopack is disabled in the Lingo.dev compiler, but you have turbopack config. Lingo.dev will not apply turbopack configuration."
      );
    }
    const originalWebpack = nextConfig.webpack;
    nextConfig.webpack = (config, options) => {
      if (!turbopackEnabled) {
        console.log("Applying Lingo.dev webpack configuration...");
        config.plugins.unshift(unplugin.webpack(mergedParams));
      }
      if (typeof originalWebpack === "function") {
        return originalWebpack(config, options);
      }
      return config;
    };
    if (turbopackEnabled) {
      console.log("Applying Lingo.dev Turbopack configuration...");
      let turbopackConfigPath = nextConfig.turbopack ??= {};
      if (supportLegacyTurbo) {
        turbopackConfigPath = (nextConfig.experimental ??= {}).turbo ??= {};
      }
      turbopackConfigPath.rules ??= {};
      const rules = turbopackConfigPath.rules;
      const lingoGlob = `**/*.{ts,tsx,js,jsx}`;
      const lingoLoaderPath = __require.resolve("./lingo-turbopack-loader.cjs");
      rules[lingoGlob] = {
        loaders: [
          {
            loader: lingoLoaderPath,
            options: mergedParams
          }
        ]
      };
    }
    return nextConfig;
  },
  /**
   * Initializes Lingo.dev Compiler for Vite.
   *
   * @param compilerParams - The compiler parameters.
   *
   * @returns The Vite configuration.
   *
   * @example Configuration for Vite's "react-ts" template
   * ```ts
   * import { defineConfig, type UserConfig } from "vite";
   * import react from "@vitejs/plugin-react";
   * import lingoCompiler from "lingo.dev/compiler";
   *
   * // https://vite.dev/config/
   * const viteConfig: UserConfig = {
   *   plugins: [react()],
   * };
   *
   * export default defineConfig(() =>
   *   lingoCompiler.vite({
   *     models: "lingo.dev",
   *   })(viteConfig)
   * );
   * ```
   *
   * @example Configuration for React Router's default template
   * ```ts
   * import { reactRouter } from "@react-router/dev/vite";
   * import tailwindcss from "@tailwindcss/vite";
   * import lingoCompiler from "lingo.dev/compiler";
   * import { defineConfig, type UserConfig } from "vite";
   * import tsconfigPaths from "vite-tsconfig-paths";
   *
   * const viteConfig: UserConfig = {
   *   plugins: [tailwindcss(), reactRouter(), tsconfigPaths()],
   * };
   *
   * export default defineConfig(() =>
   *   lingoCompiler.vite({
   *     sourceRoot: "app",
   *     models: "lingo.dev",
   *   })(viteConfig)
   * );
   * ```
   */
  vite: (compilerParams) => (config) => {
    const mergedParams = _.merge(
      {},
      defaultParams,
      { rsc: false },
      compilerParams
    );
    const isDev = process.env.NODE_ENV !== "production";
    const isReactRouter = config.plugins?.flat()?.some((plugin) => plugin.name === "react-router");
    const framework = isReactRouter ? "React Router" : "Vite";
    sendBuildEvent(framework, mergedParams, isDev);
    config.plugins.unshift(unplugin.vite(mergedParams));
    return config;
  }
};
function getConfiguredProviders(models) {
  return _.chain(Object.values(models)).map((modelString) => modelString.split(":")[0]).filter(Boolean).uniq().filter(
    (providerId) => providerDetails.hasOwnProperty(providerId) && keyCheckers.hasOwnProperty(providerId)
  ).value();
}
function validateLLMKeyDetails(configuredProviders) {
  if (configuredProviders.length === 0) {
    return;
  }
  const keyStatuses = {};
  const missingProviders = [];
  const foundProviders = [];
  for (const providerId of configuredProviders) {
    const details = providerDetails[providerId];
    const checkers = keyCheckers[providerId];
    if (!details || !checkers) continue;
    const foundInEnv = !!checkers.checkEnv();
    const foundInRc = !!checkers.checkRc();
    keyStatuses[providerId] = { foundInEnv, foundInRc, details };
    if (!foundInEnv && !foundInRc) {
      missingProviders.push(providerId);
    } else {
      foundProviders.push(providerId);
    }
  }
  if (missingProviders.length > 0) {
    console.log(dedent`
      \n
      üí° Lingo.dev Localization Compiler is configured to use the following LLM provider(s): ${configuredProviders.join(
      ", "
    )}.

      The compiler requires API keys for these providers to work, but the following keys are missing:
    `);
    for (const providerId of missingProviders) {
      const status = keyStatuses[providerId];
      if (!status) continue;
      console.log(dedent`
          ‚ö†Ô∏è  ${status.details.name} API key is missing. Set ${status.details.apiKeyEnvVar} environment variable.

          üëâ You can set the API key in one of the following ways:
          1. User-wide: Run npx lingo.dev@latest config set ${status.details.apiKeyConfigKey || "<config-key-not-available>"} <your-api-key>
          2. Project-wide: Add ${status.details.apiKeyEnvVar}=<your-api-key> to .env file in every project that uses Lingo.dev Localization Compiler
          3. Session-wide: Run export ${status.details.apiKeyEnvVar}=<your-api-key> in your terminal before running the compiler to set the API key for the current session

          ‚≠êÔ∏è If you don't yet have a ${status.details.name} API key, get one for free at ${status.details.getKeyLink}
        `);
    }
    const errorMessage = dedent`
      \n
      ‚≠êÔ∏è Also:
      1. If you want to use a different LLM, update your configuration. Refer to documentation for help: https://lingo.dev/compiler
      2. If the model/provider you want to use isn't supported yet, raise an issue in our open-source repo: https://lingo.dev/go/gh
      3. If you have questions, feature requests, or would like to contribute, join our Discord: https://lingo.dev/go/discord
    `;
    console.log(errorMessage);
    throw new Error("Missing required LLM API keys. See details above.");
  } else if (foundProviders.length > 0) {
    console.log(dedent`
        \n
        üîë  LLM API keys detected for configured providers: ${foundProviders.join(
      ", "
    )}.
      `);
    for (const providerId of foundProviders) {
      const status = keyStatuses[providerId];
      if (!status) continue;
      let sourceMessage = "";
      if (status.foundInEnv && status.foundInRc) {
        sourceMessage = `from both environment variables (${status.details.apiKeyEnvVar}) and your user-wide configuration. The key from the environment will be used because it has higher priority.`;
      } else if (status.foundInEnv) {
        sourceMessage = `from environment variables (${status.details.apiKeyEnvVar}).`;
      } else if (status.foundInRc) {
        sourceMessage = `from your user-wide configuration${status.details.apiKeyConfigKey ? ` (${status.details.apiKeyConfigKey})` : ""}.`;
      }
      console.log(dedent`
          ‚Ä¢ ${status.details.name} API key loaded ${sourceMessage}
        `);
    }
    console.log("\u2728");
  }
}
export {
  src_default as default
};
