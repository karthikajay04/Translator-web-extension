import { jsx } from "react/jsx-runtime";
import { describe, it, expect, vi, beforeEach } from "vitest";
import { act, render, screen, waitFor } from "@testing-library/react";
import React from "react";
import { LingoProvider, LingoProviderWrapper } from "./provider.js";
import { LingoContext } from "./context.js";
vi.mock("./utils", async (orig) => {
  const actual = await orig();
  return {
    ...actual,
    getLocaleFromCookies: vi.fn(() => "en")
  };
});
describe("client/provider", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  describe("LingoProvider", () => {
    it("throws when dictionary is missing", () => {
      expect(
        () => render(
          /* @__PURE__ */ jsx(LingoProvider, { dictionary: void 0, children: /* @__PURE__ */ jsx("div", {}) })
        )
      ).toThrowError(/dictionary is not provided/i);
    });
    it("provides dictionary via context", () => {
      const dict = { locale: "en", files: {} };
      const Probe = () => {
        return /* @__PURE__ */ jsx(LingoContext.Consumer, { children: (value) => /* @__PURE__ */ jsx("div", { "data-testid": "probe", "data-locale": value.dictionary.locale }) });
      };
      render(
        /* @__PURE__ */ jsx(LingoProvider, { dictionary: dict, children: /* @__PURE__ */ jsx(Probe, {}) })
      );
      const el = screen.getByTestId("probe");
      expect(el.getAttribute("data-locale")).toBe("en");
    });
  });
  describe("LingoProviderWrapper", () => {
    it("renders nothing while loading by default, then shows children", async () => {
      const deferred = createDeferred();
      const loadDictionary = vi.fn(() => deferred.promise);
      const Child = () => /* @__PURE__ */ jsx("div", { "data-testid": "child", children: "ok" });
      const { container, findByTestId } = render(
        /* @__PURE__ */ jsx(LingoProviderWrapper, { loadDictionary, children: /* @__PURE__ */ jsx(Child, {}) })
      );
      expect(container.firstChild).toBeNull();
      await act(async () => {
        deferred.resolve({ locale: "en", files: {} });
        await deferred.promise;
      });
      await waitFor(() => expect(loadDictionary).toHaveBeenCalled());
      const child = await findByTestId("child");
      expect(child).not.toBeNull();
    });
    it("supports a custom fallback", () => {
      const loadDictionary = vi.fn(() => new Promise(() => {
      }));
      render(
        /* @__PURE__ */ jsx(
          LingoProviderWrapper,
          {
            loadDictionary,
            fallback: /* @__PURE__ */ jsx("div", { "data-testid": "fallback", children: "waiting" }),
            children: /* @__PURE__ */ jsx("div", {})
          }
        )
      );
      const fallback = screen.getByTestId("fallback");
      expect(fallback).not.toBeNull();
      expect(fallback.textContent).toBe("waiting");
    });
    it("propagates load errors to the nearest error boundary", async () => {
      const loadDictionary = vi.fn().mockRejectedValue(new Error("boom"));
      const onError = vi.fn();
      const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {
      });
      render(
        /* @__PURE__ */ jsx(TestErrorBoundary, { onError, children: /* @__PURE__ */ jsx(LingoProviderWrapper, { loadDictionary, children: /* @__PURE__ */ jsx("div", {}) }) })
      );
      await waitFor(() => expect(onError).toHaveBeenCalled());
      expect(onError.mock.calls[0][0]).toBeInstanceOf(Error);
      expect(onError.mock.calls[0][0].message).toBe("boom");
      const errorBoundary = await screen.findByTestId("boundary-error");
      expect(errorBoundary).not.toBeNull();
      expect(errorBoundary.textContent).toBe("error");
      consoleSpy.mockRestore();
    });
  });
});
function createDeferred() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
class TestErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error) {
    this.props.onError(error);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsx("div", { "data-testid": "boundary-error", children: "error" });
    }
    return this.props.children;
  }
}
