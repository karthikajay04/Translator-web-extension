"use client";
import { jsx } from "react/jsx-runtime";
import { Suspense, useMemo } from "react";
import { LingoContext } from "./context.js";
import { getLocaleFromCookies } from "./utils.js";
export function LingoProvider(props) {
  if (!props.dictionary) {
    throw new Error("LingoProvider: dictionary is not provided.");
  }
  return /* @__PURE__ */ jsx(
    LingoContext.Provider,
    {
      value: { dictionary: props.dictionary },
      children: props.children
    }
  );
}
export function LingoProviderWrapper(props) {
  const locale = useMemo(() => getLocaleFromCookies(), []);
  const resource = useMemo(
    () => createDictionaryResource({
      load: () => props.loadDictionary(locale),
      locale
    }),
    [props.loadDictionary, locale]
  );
  return /* @__PURE__ */ jsx(Suspense, { fallback: props.fallback, children: /* @__PURE__ */ jsx(DictionaryBoundary, { resource, children: props.children }) });
}
function DictionaryBoundary(props) {
  const dictionary = props.resource.read();
  return /* @__PURE__ */ jsx(LingoProvider, { dictionary, children: props.children });
}
function createDictionaryResource(options) {
  let status = "pending";
  let value;
  let error;
  const { locale } = options;
  console.log(`[Lingo.dev] Loading dictionary file for locale ${locale}...`);
  const suspender = options.load().then((result) => {
    value = result;
    status = "success";
    return result;
  }).catch((err) => {
    console.log("[Lingo.dev] Failed to load dictionary:", err);
    error = err;
    status = "error";
    throw err;
  });
  return {
    read() {
      if (status === "pending") {
        throw suspender;
      }
      if (status === "error") {
        throw error;
      }
      return value;
    }
  };
}
export function LingoProviderFallback() {
  return /* @__PURE__ */ jsx(
    "div",
    {
      role: "status",
      "aria-live": "polite",
      "aria-busy": "true",
      className: "lingo-provider-fallback",
      children: "Loading translations..."
    }
  );
}
