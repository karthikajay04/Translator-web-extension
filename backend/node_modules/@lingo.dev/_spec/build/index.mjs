// src/locales.ts
import Z from "zod";
import { isValidLocale } from "@lingo.dev/_locales";
var localeMap = {
  // Urdu (Pakistan)
  ur: ["ur-PK"],
  // Vietnamese (Vietnam)
  vi: ["vi-VN"],
  // Turkish (Turkey)
  tr: ["tr-TR"],
  // Tamil (India)
  ta: [
    "ta-IN",
    // India
    "ta-SG"
    // Singapore
  ],
  // Serbian
  sr: [
    "sr-RS",
    // Serbian (Latin)
    "sr-Latn-RS",
    // Serbian (Latin)
    "sr-Cyrl-RS"
    // Serbian (Cyrillic)
  ],
  // Hungarian (Hungary)
  hu: ["hu-HU"],
  // Hebrew (Israel)
  he: ["he-IL"],
  // Estonian (Estonia)
  et: ["et-EE"],
  // Greek
  el: [
    "el-GR",
    // Greece
    "el-CY"
    // Cyprus
  ],
  // Danish (Denmark)
  da: ["da-DK"],
  // Azerbaijani (Azerbaijan)
  az: ["az-AZ"],
  // Thai (Thailand)
  th: ["th-TH"],
  // Swedish (Sweden)
  sv: ["sv-SE"],
  // English
  en: [
    "en-US",
    // United States
    "en-GB",
    // United Kingdom
    "en-AU",
    // Australia
    "en-CA",
    // Canada
    "en-SG",
    // Singapore
    "en-IE"
    // Ireland
  ],
  // Spanish
  es: [
    "es-ES",
    // Spain
    "es-419",
    // Latin America
    "es-MX",
    // Mexico
    "es-AR"
    // Argentina
  ],
  // French
  fr: [
    "fr-FR",
    // France
    "fr-CA",
    // Canada
    "fr-BE",
    // Belgium
    "fr-LU"
    // Luxembourg
  ],
  // Catalan (Spain)
  ca: ["ca-ES"],
  // Japanese (Japan)
  ja: ["ja-JP"],
  // Kazakh (Kazakhstan)
  kk: ["kk-KZ"],
  // German
  de: [
    "de-DE",
    // Germany
    "de-AT",
    // Austria
    "de-CH"
    // Switzerland
  ],
  // Portuguese
  pt: [
    "pt-PT",
    // Portugal
    "pt-BR"
    // Brazil
  ],
  // Italian
  it: [
    "it-IT",
    // Italy
    "it-CH"
    // Switzerland
  ],
  // Russian
  ru: [
    "ru-RU",
    // Russia
    "ru-BY"
    // Belarus
  ],
  // Ukrainian (Ukraine)
  uk: ["uk-UA"],
  // Belarusian (Belarus)
  be: ["be-BY"],
  // Hindi (India)
  hi: ["hi-IN"],
  // Chinese
  zh: [
    "zh-CN",
    // Simplified Chinese (China)
    "zh-TW",
    // Traditional Chinese (Taiwan)
    "zh-HK",
    // Traditional Chinese (Hong Kong)
    "zh-SG",
    // Simplified Chinese (Singapore)
    "zh-Hans",
    // Simplified Chinese
    "zh-Hant",
    // Traditional Chinese
    "zh-Hant-HK",
    // Traditional Chinese (Hong Kong)
    "zh-Hant-TW",
    // Traditional Chinese (Taiwan)
    "zh-Hant-CN",
    // Traditional Chinese (China)
    "zh-Hans-HK",
    // Simplified Chinese (Hong Kong)
    "zh-Hans-TW",
    // Simplified Chinese (China)
    "zh-Hans-CN"
    // Simplified Chinese (China)
  ],
  // Korean (South Korea)
  ko: ["ko-KR"],
  // Arabic
  ar: [
    "ar-EG",
    // Egypt
    "ar-SA",
    // Saudi Arabia
    "ar-AE",
    // United Arab Emirates
    "ar-MA"
    // Morocco
  ],
  // Bulgarian (Bulgaria)
  bg: ["bg-BG"],
  // Czech (Czech Republic)
  cs: ["cs-CZ"],
  // Welsh (Wales)
  cy: ["cy-GB"],
  // Dutch
  nl: [
    "nl-NL",
    // Netherlands
    "nl-BE"
    // Belgium
  ],
  // Polish (Poland)
  pl: ["pl-PL"],
  // Indonesian (Indonesia)
  id: ["id-ID"],
  is: ["is-IS"],
  // Malay (Malaysia)
  ms: ["ms-MY"],
  // Finnish (Finland)
  fi: ["fi-FI"],
  // Basque (Spain)
  eu: ["eu-ES"],
  // Croatian (Croatia)
  hr: ["hr-HR"],
  // Hebrew (Israel) - alternative code
  iw: ["iw-IL"],
  // Khmer (Cambodia)
  km: ["km-KH"],
  // Latvian (Latvia)
  lv: ["lv-LV"],
  // Lithuanian (Lithuania)
  lt: ["lt-LT"],
  // Norwegian
  no: [
    "no-NO",
    // Norway (legacy)
    "nb-NO",
    // Norwegian BokmÃ¥l
    "nn-NO"
    // Norwegian Nynorsk
  ],
  // Romanian (Romania)
  ro: ["ro-RO"],
  // Slovak (Slovakia)
  sk: ["sk-SK"],
  // Swahili
  sw: [
    "sw-TZ",
    // Tanzania
    "sw-KE",
    // Kenya
    "sw-UG",
    // Uganda
    "sw-CD",
    // Democratic Republic of Congo
    "sw-RW"
    // Rwanda
  ],
  // Persian (Iran)
  fa: ["fa-IR"],
  // Filipino (Philippines)
  fil: ["fil-PH"],
  // Punjabi
  pa: [
    "pa-IN",
    // India
    "pa-PK"
    // Pakistan
  ],
  // Bengali
  bn: [
    "bn-BD",
    // Bangladesh
    "bn-IN"
    // India
  ],
  // Irish (Ireland)
  ga: ["ga-IE"],
  // Galician (Spain)
  gl: ["gl-ES"],
  // Maltese (Malta)
  mt: ["mt-MT"],
  // Slovenian (Slovenia)
  sl: ["sl-SI"],
  // Albanian (Albania)
  sq: ["sq-AL"],
  // Bavarian (Germany)
  bar: ["bar-DE"],
  // Neapolitan (Italy)
  nap: ["nap-IT"],
  // Afrikaans (South Africa)
  af: ["af-ZA"],
  // Uzbek (Latin)
  uz: ["uz-Latn"],
  // Somali (Somalia)
  so: ["so-SO"],
  // Tigrinya (Ethiopia)
  ti: ["ti-ET"],
  // Standard Moroccan Tamazight (Morocco)
  zgh: ["zgh-MA"],
  // Tagalog (Philippines)
  tl: ["tl-PH"],
  // Telugu (India)
  te: ["te-IN"],
  // Kinyarwanda (Rwanda)
  rw: ["rw-RW"],
  // Georgian (Georgia)
  ka: ["ka-GE"],
  // Malayalam (India)
  ml: ["ml-IN"],
  // Armenian (Armenia)
  hy: ["hy-AM"],
  // Macedonian (Macedonia)
  mk: ["mk-MK"]
};
var localeCodesShort = Object.keys(localeMap);
var localeCodesFull = Object.values(
  localeMap
).flat();
var localeCodesFullUnderscore = localeCodesFull.map(
  (value) => value.replace("-", "_")
);
var localeCodesFullExplicitRegion = localeCodesFull.map((value) => {
  const chunks = value.split("-");
  const result = [chunks[0], "-r", chunks.slice(1).join("-")].join("");
  return result;
});
var localeCodes = [
  ...localeCodesShort,
  ...localeCodesFull,
  ...localeCodesFullUnderscore,
  ...localeCodesFullExplicitRegion
];
var localeCodeSchema = Z.string().refine(
  (value) => {
    const normalized = normalizeLocale(value);
    return isValidLocale(normalized);
  },
  {
    message: "Invalid locale code"
  }
);
var resolveLocaleCode = (value) => {
  const existingFullLocaleCode = Object.values(localeMap).flat().includes(value);
  if (existingFullLocaleCode) {
    return value;
  }
  const existingShortLocaleCode = Object.keys(localeMap).includes(value);
  if (existingShortLocaleCode) {
    const correspondingFullLocales = localeMap[value];
    const fallbackFullLocale = correspondingFullLocales[0];
    return fallbackFullLocale;
  }
  throw new Error(`Invalid locale code: ${value}`);
};
var getLocaleCodeDelimiter = (locale) => {
  if (locale.includes("_")) {
    return "_";
  } else if (locale.includes("-")) {
    return "-";
  } else {
    return null;
  }
};
var resolveOverriddenLocale = (locale, delimiter) => {
  if (!delimiter) {
    return locale;
  }
  const currentDelimiter = getLocaleCodeDelimiter(locale);
  if (!currentDelimiter) {
    return locale;
  }
  return locale.replace(currentDelimiter, delimiter);
};
function normalizeLocale(locale) {
  return locale.replaceAll("_", "-").replace(/([a-z]{2,3}-)r/, "$1");
}

// src/formats.ts
import Z2 from "zod";
var bucketTypes = [
  "android",
  "csv",
  "ejs",
  "flutter",
  "html",
  "json",
  "json5",
  "jsonc",
  "markdown",
  "markdoc",
  "mdx",
  "xcode-strings",
  "xcode-stringsdict",
  "xcode-xcstrings",
  "xcode-xcstrings-v2",
  "yaml",
  "yaml-root-key",
  "properties",
  "po",
  "xliff",
  "xml",
  "srt",
  "dato",
  "compiler",
  "vtt",
  "php",
  "po",
  "vue-json",
  "typescript",
  "txt",
  "json-dictionary"
];
var bucketTypeSchema = Z2.enum(bucketTypes);

// src/config.ts
import Z3 from "zod";
var localeSchema = Z3.object({
  source: localeCodeSchema.describe(
    "Primary source locale code of your content (e.g. 'en', 'en-US', 'pt_BR', or 'pt-rBR'). Must be one of the supported locale codes \u2013 either a short ISO-639 language code or a full locale identifier using '-', '_' or Android '-r' notation."
  ),
  targets: Z3.array(localeCodeSchema).describe(
    "List of target locale codes to translate to."
  )
}).describe("Locale configuration block.");
var createConfigDefinition = (definition) => definition;
var extendConfigDefinition = (definition, params) => {
  const schema = params.createSchema(definition.schema);
  const defaultValue = params.createDefaultValue(definition.defaultValue);
  const upgrader = (config) => params.createUpgrader(config, schema, defaultValue);
  return createConfigDefinition({
    schema,
    defaultValue,
    parse: (rawConfig) => {
      const safeResult = schema.safeParse(rawConfig);
      if (safeResult.success) {
        return safeResult.data;
      }
      const localeErrors = safeResult.error.errors.filter((issue) => issue.message.includes("Invalid locale code")).map((issue) => {
        let unsupportedLocale = "";
        const path = issue.path;
        const config = rawConfig;
        if (config.locale) {
          unsupportedLocale = path.reduce((acc, key) => {
            if (acc && typeof acc === "object" && key in acc) {
              return acc[key];
            }
            return acc;
          }, config.locale);
        }
        return `Unsupported locale: ${unsupportedLocale}`;
      });
      if (localeErrors.length > 0) {
        throw new Error(`
${localeErrors.join("\n")}`);
      }
      const baseConfig = definition.parse(rawConfig);
      const result = upgrader(baseConfig);
      return result;
    }
  });
};
var configV0Schema = Z3.object({
  version: Z3.union([Z3.number(), Z3.string()]).default(0).describe("The version number of the schema.")
});
var configV0Definition = createConfigDefinition({
  schema: configV0Schema,
  defaultValue: { version: 0 },
  parse: (rawConfig) => {
    return configV0Schema.parse(rawConfig);
  }
});
var configV1Definition = extendConfigDefinition(configV0Definition, {
  createSchema: (baseSchema) => baseSchema.extend({
    locale: localeSchema,
    buckets: Z3.record(Z3.string(), bucketTypeSchema).default({}).describe(
      "Mapping of source file paths (glob patterns) to bucket types."
    ).optional()
  }),
  createDefaultValue: () => ({
    version: 1,
    locale: {
      source: "en",
      targets: ["es"]
    },
    buckets: {}
  }),
  createUpgrader: () => ({
    version: 1,
    locale: {
      source: "en",
      targets: ["es"]
    },
    buckets: {}
  })
});
var configV1_1Definition = extendConfigDefinition(configV1Definition, {
  createSchema: (baseSchema) => baseSchema.extend({
    buckets: Z3.record(
      bucketTypeSchema,
      Z3.object({
        include: Z3.array(Z3.string()).default([]).describe(
          "File paths or glob patterns to include for this bucket."
        ),
        exclude: Z3.array(Z3.string()).default([]).optional().describe(
          "File paths or glob patterns to exclude from this bucket."
        )
      })
    ).default({})
  }),
  createDefaultValue: (baseDefaultValue) => ({
    ...baseDefaultValue,
    version: 1.1,
    buckets: {}
  }),
  createUpgrader: (oldConfig, schema) => {
    const upgradedConfig = {
      ...oldConfig,
      version: 1.1,
      buckets: {}
    };
    if (oldConfig.buckets) {
      for (const [bucketPath, bucketType] of Object.entries(
        oldConfig.buckets
      )) {
        if (!upgradedConfig.buckets[bucketType]) {
          upgradedConfig.buckets[bucketType] = {
            include: []
          };
        }
        upgradedConfig.buckets[bucketType]?.include.push(bucketPath);
      }
    }
    return upgradedConfig;
  }
});
var configV1_2Definition = extendConfigDefinition(
  configV1_1Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      locale: localeSchema.extend({
        extraSource: localeCodeSchema.optional().describe(
          "Optional extra source locale code used as fallback during translation."
        )
      })
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.2
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.2
    })
  }
);
var bucketItemSchema = Z3.object({
  path: Z3.string().describe("Path pattern containing a [locale] placeholder."),
  delimiter: Z3.union([Z3.literal("-"), Z3.literal("_"), Z3.literal(null)]).optional().describe(
    "Delimiter that replaces the [locale] placeholder in the path (default: no delimiter)."
  )
}).describe(
  "Bucket path item. Either a string path or an object specifying path and delimiter."
);
var bucketValueSchemaV1_3 = Z3.object({
  include: Z3.array(Z3.union([Z3.string(), bucketItemSchema])).default([]).describe("Glob patterns or bucket items to include for this bucket."),
  exclude: Z3.array(Z3.union([Z3.string(), bucketItemSchema])).default([]).optional().describe("Glob patterns or bucket items to exclude from this bucket."),
  injectLocale: Z3.array(Z3.string()).optional().describe(
    "Keys within files where the current locale should be injected or removed."
  )
}).describe("Configuration options for a translation bucket.");
var configV1_3Definition = extendConfigDefinition(
  configV1_2Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      buckets: Z3.record(bucketTypeSchema, bucketValueSchemaV1_3).default({})
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.3
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.3
    })
  }
);
var configSchema = "https://lingo.dev/schema/i18n.json";
var configV1_4Definition = extendConfigDefinition(
  configV1_3Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      $schema: Z3.string().default(configSchema)
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.4,
      $schema: configSchema
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.4,
      $schema: configSchema
    })
  }
);
var providerSchema = Z3.object({
  id: Z3.enum([
    "openai",
    "anthropic",
    "google",
    "ollama",
    "openrouter",
    "mistral"
  ]).describe("Identifier of the translation provider service."),
  model: Z3.string().describe("Model name to use for translations."),
  prompt: Z3.string().describe(
    "Prompt template used when requesting translations."
  ),
  baseUrl: Z3.string().optional().describe("Custom base URL for the provider API (optional).")
}).describe("Configuration for the machine-translation provider.");
var configV1_5Definition = extendConfigDefinition(
  configV1_4Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      provider: providerSchema.optional()
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.5
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.5
    })
  }
);
var bucketValueSchemaV1_6 = bucketValueSchemaV1_3.extend({
  lockedKeys: Z3.array(Z3.string()).default([]).optional().describe(
    "Keys that must remain unchanged and should never be overwritten by translations."
  )
});
var configV1_6Definition = extendConfigDefinition(
  configV1_5Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      buckets: Z3.record(bucketTypeSchema, bucketValueSchemaV1_6).default({})
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.6
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.6
    })
  }
);
var bucketValueSchemaV1_7 = bucketValueSchemaV1_6.extend({
  lockedPatterns: Z3.array(Z3.string()).default([]).optional().describe(
    "Regular expression patterns whose matched content should remain locked during translation."
  )
});
var configV1_7Definition = extendConfigDefinition(
  configV1_6Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      buckets: Z3.record(bucketTypeSchema, bucketValueSchemaV1_7).default({})
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.7
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.7
    })
  }
);
var bucketValueSchemaV1_8 = bucketValueSchemaV1_7.extend({
  ignoredKeys: Z3.array(Z3.string()).default([]).optional().describe(
    "Keys that should be completely ignored by translation processes."
  )
});
var configV1_8Definition = extendConfigDefinition(
  configV1_7Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      buckets: Z3.record(bucketTypeSchema, bucketValueSchemaV1_8).default({})
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.8
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.8
    })
  }
);
var configV1_9Definition = extendConfigDefinition(
  configV1_8Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      formatter: Z3.enum(["prettier", "biome"]).optional().describe(
        "Code formatter to use for all buckets. Defaults to 'prettier' if not specified and a prettier config is found."
      )
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: 1.9
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: 1.9
    })
  }
);
var modelSettingsSchema = Z3.object({
  temperature: Z3.number().min(0).max(2).optional().describe(
    "Controls randomness in model outputs (0=deterministic, 2=very random). Some models like GPT-5 require temperature=1."
  )
}).optional().describe("Model-specific settings for translation requests.");
var providerSchemaV1_10 = Z3.object({
  id: Z3.enum([
    "openai",
    "anthropic",
    "google",
    "ollama",
    "openrouter",
    "mistral"
  ]).describe("Identifier of the translation provider service."),
  model: Z3.string().describe("Model name to use for translations."),
  prompt: Z3.string().describe(
    "Prompt template used when requesting translations."
  ),
  baseUrl: Z3.string().optional().describe("Custom base URL for the provider API (optional)."),
  settings: modelSettingsSchema
}).describe("Configuration for the machine-translation provider.");
var configV1_10Definition = extendConfigDefinition(
  configV1_9Definition,
  {
    createSchema: (baseSchema) => baseSchema.extend({
      provider: providerSchemaV1_10.optional()
    }),
    createDefaultValue: (baseDefaultValue) => ({
      ...baseDefaultValue,
      version: "1.10"
    }),
    createUpgrader: (oldConfig) => ({
      ...oldConfig,
      version: "1.10"
    })
  }
);
var LATEST_CONFIG_DEFINITION = configV1_10Definition;
function parseI18nConfig(rawConfig) {
  try {
    const result = LATEST_CONFIG_DEFINITION.parse(rawConfig);
    return result;
  } catch (error) {
    throw new Error(`Failed to parse config: ${error.message}`);
  }
}
var defaultConfig = LATEST_CONFIG_DEFINITION.defaultValue;
export {
  LATEST_CONFIG_DEFINITION,
  bucketItemSchema,
  bucketTypeSchema,
  bucketTypes,
  bucketValueSchemaV1_3,
  bucketValueSchemaV1_6,
  bucketValueSchemaV1_7,
  bucketValueSchemaV1_8,
  configV0Definition,
  configV1Definition,
  configV1_10Definition,
  configV1_1Definition,
  configV1_2Definition,
  configV1_3Definition,
  configV1_4Definition,
  configV1_5Definition,
  configV1_6Definition,
  configV1_7Definition,
  configV1_8Definition,
  configV1_9Definition,
  defaultConfig,
  getLocaleCodeDelimiter,
  localeCodeSchema,
  localeCodes,
  localeCodesFull,
  localeCodesFullExplicitRegion,
  localeCodesFullUnderscore,
  localeCodesShort,
  localeSchema,
  normalizeLocale,
  parseI18nConfig,
  resolveLocaleCode,
  resolveOverriddenLocale
};
